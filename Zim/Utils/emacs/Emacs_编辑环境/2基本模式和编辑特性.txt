Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2011-04-14T21:57:03+08:00

====== 2基本模式和编辑特性 ======
Created Thursday 14 April 2011


===== 编辑模式 =====
Emacs 被划分为无模式 的编辑器，这意味着它与其他的编辑器（如 vi）有所不同，对于运行编辑器命令或者向缓冲区插入文本的插入模式，没有特殊的命令模式——正如您在本系列前面的教程中所看到的，可以在任何时候完成命令和文本插入。
然而，Emacs 也有它自己的编辑模式，这就是**扩展它的能力或者改变一些特性工作方式的函数**。这些模式通常用于编辑某种类型或类别的数据，如常规文档（使用任何印欧语言编写）、用特定的计算机编程语言（C、Fortran、Lisp 等等）编写的源代码、采用某种方式进行格式化（大纲、电子邮件消息、Usenet 文章、基于字符的示例等等）或使用标记语言（超文本标记语言 (HTML)、Nroff、TeX 和可扩展标记语言 (XML)）的文本。甚至专门有一种模式用于编辑非文本（二进制）的数据。另外，Emacs 还提供了许多特殊的模式，可用于其他数据类型和系统处理，包括网络连接和网际中继交谈 (IRC)、Shell 会话和 UNIX 文件系统自身。

这些模式可以划分为**主要模式和次要模式**。**主要模式规定了主要的编辑行为，并且仅应用于当前编辑会话中的缓冲区**。在任何时刻，每个缓冲区都有且仅有一个活动的主要模式。

尽管在任何时刻，一个缓冲区仅有一个活动的主要模式，但您可以根据需要在主要模式之间进行切换。**一些专门的主要模式还提供了额外的功能和辅助**（如上下文突出显示和颜色设置），当您在编辑某些类型的文档时，这是很有帮助的，但是您无需为编辑某种类型的文件或文档选择特定的模式——可在任何模式中编辑一个 C 程序源代码文件，正如它可在编辑 C 程序语言的特殊模式中完成。

**次要 模式通常提供了一些与任何特定的主要模式无关的特性或功能**。可以把它们看作用于控制这些特性的切换：使用其函数名来调用一个次要模式可以开启或关闭该模式，任何时候您都可以开启多个次要模式。

次要模式包括__ Overwrite __模式（本系列文章的第一部分教程对其进行了描述）、用于管理签入版本控制系统 (RCS) 的文件的 __RCS__ 模式、以及处理自动文字回绕的 __Auto Fill __模式。可以在任何时候同时激活所有这些次要模式以及许多其他类似的模式。

===== 查看哪些模式是活动的 =====

如本系列文章的第一个教程中所述，靠近 Emacs 窗口底部的突出显示栏，被称为模式行，可以告诉您当前缓冲区的所有情况——包括哪种模式当前是活动的。在模式行右边的括号里注明了当前的模式。__最先列出主要模式的缩写名称，后面是任何次要模式的缩写名称__。

当您启动 Emacs 编辑器而不打开任何文件时，则处于暂存缓冲区。在缺省情况下，这个缓冲区以 Lisp Interaction 模式打开，这是一个用于计算 Lisp 代码的特殊模式。
您可以用通常的方式启动 Emacs，观察模式行里写了些什么。
当您改变这些模式的时候，将在模式行里看到其反映出来了模式的改变。现在，请尝试下面的操作：按 Ins 键以打开 Overwrite 模式，并注意模式行的变化。（Ins 键与 overwrite-mode 函数进行了绑定)。
再次按 Ins 以关闭 Overwrite 模式。
当启用一个次要模式时，通常在括号里会有显示，紧接在主要模式的后面。然而，**并非所有的次要模式都有这种指示器**——有些次要模式是非常明了的（如 Tool Bar 模式），它在 Emacs 框架的顶部显示了图形工具栏。较新版本的 Emacs 中其他的次要模式都非常简单（并且始终处于开启状态），以至于如果要把它们全部显示出来，只会使显示变得非常混乱；例如，次要模式 Unify 8859 On Encoding 的目的是为各种 ISO 8859 字符集提供统一的编码方式，这样有助于进行国际化。
另外，一些模式提供了**额外的指示器**，这些指示器也会在模式行里显示出来。例如 Line Number 模式，通过在 L 后面跟上行号来表示，该行号是光标在缓冲区中的当前位置。

===== 获得当前模式的描述 =====

可以使用 describe-mode 函数，该函数与 **C-h m** 进行了绑定，用于获得当前模式的描述。当您运行这个函数时，将打开一个新的帮助缓冲区，其中列出了所有的键绑定，这些键绑定是您进行输入的缓冲区的当前主要模式所特有的，后面跟的是应用于任何处于打开状态的次要模式的绑定。

正如您所看见的，用于 Lisp Interaction 模式的特殊绑定之一是 Tab 键。在这个模式中，Tab 并不会像您希望的那样在打字机或文字处理应用程序中将光标移动到下一个制表位处，而是按照模式描述所说的，它会对当前 Lisp 代码行进行缩进。因为您没有在这个缓冲区中编写任何 Lisp 代码，所以 Tab 什么都不做——您可以试试看。

===== 缺省模式 =====

尽管暂存缓冲区通常设置为 Lisp Interaction 模式，但它并不是缺省 Emacs 模式。要找出缺省模式是什么，可以切换到一个新的缓冲区：输入 C-x b 并指定 lamb.txt 作为缓冲区的名称。输入 C-x 1 关闭帮助缓冲区。
您将看到这个新的 lamb.txt 缓冲区有了新的主要模式，即 **Fundamental 模式。这就是 Emacs 缓冲区的缺省模式**。在所有 Emacs 模式中，这种模式是最简单明了的，拥有最少的特殊键绑定和设置。在这种模式中，Tab 键将按照您所希望的方式进行工作。

再次键入 C-h m 继续工作并获取这些模式的描述。

当您在新的缓冲区中打开现有文件中的内容时，Emacs 将**基于该文件类型**为您选择一种模式。如果您打开的文件包含 C 程序源代码，那么 C 模式将成为主要模式；同样，如果您打开的文件包含口语（如英语）文本，那么 Emacs 会将 Text 模式设置为主要模式。

您可以不断地改变模式，并且您还可以对所有这些设置进行配置，这样一来，就始终能够以特定的模式打开某种文件或者某种类型的缓冲区。表 1 描述了常用的 Emacs 模式，并给出了它们的函数名。

===== 表 1. 常用的 Emacs 模式 =====
模式			函数			类型				描述
Fundamental		fundamental-mode 	主要模式			这一模式是缺省的 Emacs 模式，拥有最少设置和绑定。
Text			text-mode 		主要模式			这一模式是编辑文本的基本模式。
Abbrev			abbrev-mode 		次要模式			这一模式用于生成和使用缩写请参见 Abbrev 模式）。
Auto Fill		auto-fill-mode 		次要模式			这一模式用于自动文字回绕、填充较长的行和段落。
Overwrite		overwrite-mode 	次要模式			这一模式用于覆盖缓冲区中任何现有的文本，而不是在当前位置插入文本。在缺省情况下，它与 Ins 键绑定。
C			c-mode 		主要模式			这一模式用于编辑 C 程序源代码。
Line Number		line-number-mode 	次要模式			这一模式用于显示当前行号。
Lisp Interaction		lisp-interaction 		主要模式			这一模式用于编辑和编译 Lisp 代码。
Paragraph-Indent Text	paragraph-indent-text-mode 	主要模式		这一模式是 Text 模式的一种特殊变体，其中的段落移动命令可用于首行缩进的段落，而不仅仅是由空行隔开的段落。
TeX			tex-mode 		主要模式			这一模式用于编辑 TeX 文档。
WordStar		wordstar-mode 		主要模式			这一特殊模式提供了 WordStar 编辑器的键绑定。

===== 设置模式 =====

Emacs 模式是一些函数。要调用其中某个函数，您需要输入 M-x，然后给出模式名。
现在可以尝试在新的缓冲区中调用 Text 模式：输入 M-x text-mode 并按 Enter。您马上可以看到模式行中的变化，其中用 Text 替换了 Fundamental。
在 Text 模式中进行输入
Text 模式是一种基本的模式，与 Fundamental 模式相比仅有很少的改变，所以它的优势并不明显；但它是对口语（如英语）文本进行编辑的一个很好的基础。从 TeX 模式到 Outline 模式，许多用于编辑某类文本或文档的特殊模式都是基于 Text 模式的。
尝试在新的缓冲区中输入一些文本，继续上一个教程中 William Blake 的主题：
__Text 模式下，Tab 键被定义为相对于先前段落的缩进以缩进段落，__如果先前的段落没有缩进，按 Tab 插入一个逐字制表符，移动光标到下一个制表符止。
要了解 Text 模式如何处理制表符，可以输入一些带制表符和空格的行：

===== Abbrev 模式 =====

Emacs 的缩写 是用一个特定的字符串定义的特殊单词。当在缓冲区中输入一个缩写时（并且 Abbrev 模式已打开），将对这个缩写进行扩展 或者使用定义它的字符串来替换它。Abbrev 模式（一种次要模式）使得您可以对较长的字符串或者短语进行速记，但是您可能还会想到一些其他的使用方式。

==== 定义一个缩写（需要先启用abbrev-mode） ====

添加缩写的简单方式是，运行一个 inverse-add 缩写函数 __inverse-add-global-abbrev （C-x a i g）__或者__ inverse-add-local-abbrev（C-x a i l ）__。这些函数允许您为缓冲区中的某个单词定义一个缩写，第一个函数可以对当前 Emacs 会话中打开的**任何缓冲区**应用这一缩写，而第二个函数仅对与当前缓冲区具有相同的主要模式的缓冲区定义这一缩写。后者可用于定义仅适用于某些模式的缩写，例如对包含程序源代码的缓冲区中的长变量名进行定义。

尝试定义一个缩写，并使其应用于所有的缓冲区：
    在下一新行中，输入一个缩写单词 li,，以使得**光标位于这个单词的末尾**（即在 i 之后）。
    通过输入 C-x a i g，运行 inverse-add-global-abbrev 函数。
    在小缓冲区中给出提示的地方定义您的缩写：输入 Little lamb 并按 Enter。

请注意，您在缓冲区中输入的缩写使用定义它的字符串进行了替换，并且光标移到了这个定义的开头。
现在，将光标移动到一个新行，并按您刚刚用过的方法生成一个新的缩写，通过输入 x（缩写不区分大小写），并使用这个字符串 He is 来定义它。
现在您已经定义了两个缩写。然而，正如您在模式行里看到的，Abbrev 模式是关闭的。请打开它：输入 __M-x abbrev-mode__。用您刚刚生成的定义删除这两行，然后输入清单 1 中的代码。
li 和 x 的缩写按照您的输入进行了扩展，当您完成以上操作后，缓冲区看起来就应该与图 3 所示类似。

==== Emacs 缓冲区中的缩写扩展 ====

这个示例显示了如何定义在所有缓冲区中都可以使用的缩写。要定义一个缩写，以使其仅应用于当前模式的缓冲区，可以使用__ C-x a i l__。

==== 使用一个单词作为缩写的定义 ====

您还可以**为缓冲区中的单个单词定义缩写**。当您在编写程序源代码并且刚输入了一个较长的变量时，这种方式是特别有用的。
要为一个单词定义缩写，可以在光标位于这个单词之后时使用 __C-x a g__。在完成了这个操作之后，当 Abbrev 模式开启时，小缓冲区将提示您用缩写来替代那个单词。同样地，要定义一个仅应用于当前主要模式的缩写，可以使用__ C-x a l__。

==== 删除缩写 ====

要删除您在会话中定义的全部缩写，可以使用 kill-all-abbrevs 函数。
请尝试下面的操作：键入 __M-x kill-all-abbrevs__。
现在，在任何缓冲区（无论其处于何种模式）中都没有使用您所定义的缩写（li、x 和 c）对其进行扩展。再输入两行内容作为结束：

