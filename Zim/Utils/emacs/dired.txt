Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2011-04-08T17:08:50+08:00

====== Emacs -- 强大的文件管理器 ======

dired 是 Emacs 自带的文件管理器，操作非常方便，再加上一些扩展之后无疑是一个理想的文件管理器。看看这里来了解如何增强你的 dired 。

===== Mark & Flag =====

dired 最方便的一点就是可以**对许多文件进行标记，并进行批量操作**。标记的方法有很多，最普通的标记就是 __d __为当前文件贴上删除标签，之后可以使用 __x__ 来真正删除所有贴上删除标签的文件。
dired 还提供了许多预定义的方便的标记操作(当使用__ C-u 传递一个前缀参数时，他们执行相反操作__，即去掉标记)，例如：

通常这些命令可以方便地帮你清理垃圾，如果还不满意，可以使用__ % d __REGEXP <RET> 来输入自己的正则表达式，匹配到的文件会被贴上删除标签。

当然，能用的标签并不止是 __D (即删除标签)__，几乎任何一个字符都可以使用(但需要通过转换，默认的为D和*标签)，不过__最常用的还是 *__ ， m 命令即是以 * 标记当前文件。同样，dired 提供了很多方便的标记操作(这些命令在传递一个前缀参数的时候都会执行相反的操作，例如 C-u * * 会去掉所有可执行文件的标记)：
  
 dired 可以使用更多的字符进行标记，只是没有提供相应的快捷键操作而已，你可以先以 * 标记，然后使用 * c OLD-MARKCHAR NEW-MARKCHAR 来把 * 标记变换成其他标记，几乎任何字符(当然不包括中文这种多字节的字符)都可以作为标记，不过空格被特殊对待，用于表示所有未标记的文件。

===== 例子 =====

列举了这么多命令，多少有些枯燥，我们来把当前目录下的所有备份文件移动到 ~/backup 目录下。假设当前目录已经有一些文件被你以 D 标记，但是暂时还不想删除：

    选择个临时标记，比如 t ，只要保证当前 buffer 里面没有已经存在的这种标记就行了。
*c D t 把当前所有 D 标签换为 t 标签。
    ~ 以 D 标记所有备份文件。
*c D * 把 D 标签换为 * 标签。
    R ~/backup <RET> 来把所有标记为 * 的文件移动到 ~/backup 目录里面。
*c t D 恢复原来的 D 标记。

当然这要假设你原来没有设定其他的 * 标记，要不然你也可以再添加一个临时标记。总之操作和清晰也很方便，感觉像在汇编语言里面使用寄存器一样，__大多数批量操作都是针对 * 标记的，所以对某个标记操作之前需要把他先转换为 * 标记。__

===== 文件操作 =====

dired 内建了很多文件操作，对于操作的文件有一个统一的约定，按照顺序是：

    __如果你通过 C-u 传递一个前缀参数 N ，那么它对从当前行开始的 N 行执行操作( N 也可以是负数)。__
__    如果有被标记为 * 的文件，则以这些文件为操作对象。__
__    只对当前光标所在的文件进行操作。__

这些命令全部__绑定到大写字母__上，记忆也非常方便：

    C 拷贝文件。把 dired-recursive-copies 设为非 nil 的值可以递归拷贝目录，通常我们设定为 top ，这表示对于顶层目录 dired 会先进行询问是否要递归拷贝，而其中的子目录则不再询问。如果嫌询问太麻烦，可以直接设置为 always 。
    D 删除文件。类似的有一个 dired-recursive-deletes 变量可以控制递归删除。
    R 重命名文件，也就是移动文件。
    H 创建硬链接。
    S 创建软链接。
    M 修改权限位，即 shell 里面的 chmod 命令。
    G 修改文件所属的组。
    O 修改文件的所有者。
    T 修改文件的修改时间，类似于 shell 命令 touch 。
    P 打印文件。
    Z 压缩或解压文件。
    L 把 Elisp 文件加载进 Emacs 。
    B 对 Elisp 文件进行 Byte compile 。
   __ A 对文件内容__进行正则表达式搜索，搜索会在第一个匹配的地方停下，然后可以使用 __M-, __搜索下一个匹配。
    Q 对文件内容进行交互式的正则表达式__替换__。
   !command  对文件执行shell命令

===== 单字符命令 =====
	
	__#__ 为所有自动保存的文件(通常是文件名开始和结尾都是 # 的文件)贴上删除标签。
	__~__ 为所有备份文件(即文件名以 ~ 结尾的文件，Emacs 和 vi 等编辑器默认情况下都会产生这样的文件)贴上删除标签。
	__&__ 为“垃圾文件”(看 dired-garbage-files-regexp 的值可以知道 dired 把哪些文件当作了垃圾文件)贴上删除标签。
以上命令的标记为D
	a 在当前buffer打开目录(默认是在新的buffer打开目录)
	i 在当前buffer尾部打开目录，并设置标记
	k 隐藏标记为*的文件
	o 在新buffer中打开当前文件，并将光标移到其中
	q 关闭当前窗口(不是文件编辑窗口)
	n 下移一行
	p 上移一行
	空格 下移一行
	s 将文件按名称或修改时间排序
	d 将文件标记为删除
	u取消文件的标记状态
	U 取消整个文件的标记状态
	t 交换标记，将已加*与未加*的交换
	j 跳转到当前目录中一个文件，并设置标记
	g 现实k隐藏的文件
	x 执行标记对应的操作
	v 察看文件内容
	m 设置标记
	Break 删除上一行的标记
	y 察看当前文件类型
	! 对文件执行shell命令
	+ 创建目录

	__w 复制文件名，如果通过 C-u 传递一个前缀参数 0 ，则复制决定路径名，如果只是 C-u 则复制相对于 dired 当前目录的相对路径。__
	I 把当前文件以 info 文档的格式打开。
	N 把当前文件以 man 格式打开(使用 WoMan)。
	Y 为所有标记的文件创建一个到指定目录的相对符号连接(即使用相对路径进行引用，而不是绝对路径)。


===== *命令 =====
	** 标记所有可执行文件
	*@ 标记所有符号链接文件
	*/ 标记所有目录文件
	*s 标记所有文件为*
	*. 标记具有给定扩展名的文件
	* % REGEXP <RET>标记所有__文件名__匹配到给定的正则表达式的文件
	*? MARKCHAR 或 M-<DEL>   __去除所有以 MARKCHAR 标记的文件的标记__，如果传递一个前缀参数，则会对每一个文件要求你确认是否去除标记。
	__* c OLD-MARKCHAR NEW-MARKCHAR__  把 * 标记变换成其他标记
以上命令的标记为*

===== %命令(一般和正则表达式有关) =====
	%d REGEXP <RET>	把__文件名__符合正则表达式的文件标记为删除D
        % m REGEXP <RET> >标记所有__文件名__匹配到给定的正则表达式的文件
        % g REGEXP <RET> 标记所有__文件 内容__ 匹配到给定的正则表达式的文件
正则表达式语法为grep而非egrep

===== 强大的重命名功能 =====

dired 有一个文件名转换的理念，所以转换，并不一定是重命名，还可以是复制和创建链接。所以，除了 % u 和 % l 重命名原文件为大写、小写外，一个使用正则表达式进行转换的命令提供了四个选项： __% X 其中 X 可以是 R , C , H 和 S __，分别代表重命名、复制、创建硬链接和创建软链接，他们使用匹配和替换的机制，这有点像 rename 这个程序，例如： % R \.[^.]*$ <RET> .1\& <RET> 给原来的文件名加个标号 1 ，把 foo.txt 变成 foo.1.txt 。

另外，dired 还有一个叫做 __Wdired__ 的扩展可以直接在 dired 的 buffer 里面编辑文件名来达到重命名的效果。使用 __M-x wdired-change-to-wdired-mode__ 进入编辑模式，这个时候可以直接像编辑普通文本一样编辑文件名，还可以添加路径来实现把文件移动到其他目录(可以通过保存文件的方式来使更改生效)。除了文件名可以编辑以外，其他部分被标记为只读，但是如果把 __wdired-allow-to-change-permissions__ 设为 t 的话，还可以编辑文件的权限位。编辑完成之后使用 C-c C-c 来应用所做的编辑。非常方便。

===== 排序和过滤 =====

dired 有方便的排序功能，这里介绍了如何方便地使用排序功能。另外 dired 还有一个 __k__ 用于去掉不想显示出来的文件，它并不删除磁盘上的文件，只是临时从 dired 的 buffer 中去掉他们，__ g __刷新一下它们又会显示出来，这样，首先用强大的标记功能进行标记，然后使用 k 去掉，就实现了过滤的功能。
子目录操作

===== 同时操作当前目录和子目录 =====
dired 允许同时操作当前目录和子目录。在 dired-listing-switches 里面加入 R 选项就可以显示子目录，如果只是想临时显示某个子目录的内容，对该目录执行__ i __操作就会把该子目录的内容添加到 dired __当前 buffer 的末尾__并把光标移动到那里，dired 在__移动之前会先设置一个 mark__ ，所以可以使用 C-u C-<SPC> (对于我来说，我把 set-mark-command 绑定到了 M-<SPC> 上，这里自然就是使用 C-u M-<SPC> 了)回到原来的位置。


还有一些方便的功能，我把几个常用的命令列在这里：

 
