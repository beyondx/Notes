Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2011-04-18T14:53:04+08:00

====== LISP语言 ======
Created Monday 18 April 2011

对于Emacs，无论发现缺少何种功能，都可以动手用LISP程序实现它。实际上可以把Emacs看作是一个带有很多内部函数的LISP系统，其中很多函数是用来实现文本处理、
窗口管理、文件I/O和其它与文本编辑有关的函数。Emacs源代码使用C写的，它实现了LISP解释器、LISP指令和一些最基本的文本编辑命令。Emacs的其它功能时在它们基础上用
一个规模巨大的内部LISP代码层实现的。

===== 基本元素 =====
函数、变量、原子项是LISP语言的最基本元素，函数是LISP语言唯一的程序单元。
LISP中的函数定义为由上述基本元素组成的各种列表(list)，而且这种列表往往还嵌套调用其它现有的函数。一切函数都可以有返回值，调用的一个函数的返回值就是定义该函数时的最后一个列表项的值。嵌套在另外一个函数里的某个函数调用相当于其它程序设计语言中的一条语句(statement)。函数调用的语句
(function-name argument1 argument2 ...)
这条语句适合一切函数的调用，那些相当于其它程序语言中的算术或比较操作符的函数也不例外。
LISP中的变量没有类型的概念，一个变量可以去任意的类型。原子项时任意类型的值，可以是整数、浮点数、字符、字符串、布尔值、符号，同时也可以是编辑缓冲区、窗口、进程等特殊的Emacs类型。
整数
浮点数
字符：LISP字符必须要由一个前导的问号，不加引号，ESC，LINEFEED、TAB分别用\e,\n,\t表示，其它控制字符要加上前缀"\C-"如？\C-a
字符串：必须放在一对双引号中间，字符串中的引号和反斜线字符必须用转义字符引导。
布尔值：t表示真，nil表示假，任何一个不是nil的值意味着真，在需要nil的场合，null或空值表示假
符号:LISP语言中各种事物的名字，如变量名函数名。有时我们需要的事物的名字而不是他们的值，这就需在事物的名字前加一个单引号。

(setq auto-save-interval 80)
(setq	thisvar thisvalue
		thatvar thatvalue
		theotherval theothervalue)
setq的返回值就是最后一个赋值。

列表时LISP语言中的一个基本概念，它充分体现了堆栈结构的本质特性。列表时把LISP与其它程序设计语言区分开来的主要概念。这种数据结构有两部分组成：头元素和剩下的尾元素。出于历史原因，LISP称之为car和cdr,前者为列表里第一个东西，后者为列表中剩余的东西。如果给car和cdr提供一个列表参数，他们就返回列表的头和尾元素。cons函数带两个参数，而这两个参数分别设为列表的头元素和尾元素。list函数以多了元素为输入参数，用他们构造出一个列表。
(list 1 2 3 4)
(cons 1 (list 2 3 4))
上面两条语句功能相同。
堆栈可以很容易地用列表实现：
(setq	calc-stack	(cons	x	calc-stack))
获得栈顶的元素：
(car calc-stack)
弹出栈顶的元素:
(setq	calc-stack	(cdr	calc-stack))

列表的元素可以使其它包括列表在内的任何东西，这就是人们把列表称为递归数据结构的原因。事实上，对LISP语言里任何一种东西来说，如果他不是一个原子项，就会是一个列表。这里面也包括函数，它可以看作由一个函数名、参数、准备求值的表达式等元素组成的列表。

===== 函数的定义 =====
在LISP语法中，短划线字符时在变量名、函数名等语言元素中用作间隔符的字符，LISP是一种很古老的语言。因此语法对程序员并不是很友好，用LISP语言写出的程序会使用大量的列表，也就是使用大量的括号。人们习惯于将多个括号集中放在代码的末尾而不是把它们分别放在一行并于对应的左括号对齐。这导致其可读性变差。简单的函数实例如下：
(defun count-words-buffer ()                         1
  (interactive)							2
  (let ((count 0))						3
    (goto-char (point-min))				4
    (while (< (point) (point-max))			5
      (forward-word 1)					6
      (setq count (1+ count)))				7
    (message "buffer contains %d words." count)))   8
(count-words-buffer)					9

defun定义了一个函数和他的参数，defun本身也是一个函数，他会在被调用时定义一个新的函数，返回值是一个符号即定义的函数名，函数的参数都放在括号里，形成一个由变量名组成的列表，如果在某个参数前加一个&optional，就可以把这个参数设为可选参数，如果一个参数是可选的并且在调用时没有给出，他的取值就是nil。

let函数的基本调用格式是：
(let ((var1 value1)
      (var2 value2)
      ...)
      statement-block)

let先对变量var1 var2进行定义，并把他们的初始值设为value1 value2等，接着let执行他的语句块部分，语句块时顺序排列的一组函数调用。
let做了三件事：
 定义（或声明）了一个由变量组成的列表
给变量设置初始值
创建一个可以使用声明的变量的语句块，let的语句块也叫做变量的作用域。

LISP语言中while结构的基本格式是：
(while condition
  statement-block)
循环条件condition是一个值(一个原子项、一个变量或者是一个有返回值的某个函数)，while对其测试判断是否为nil。对于无限循环可以用C-g来结束LISP语句的执行。<函数及其它条件比较函数返回的都是一个布尔值。

(1+ count)，函数1+是(+ 1 variable-name)的缩写形式，主要函数的返回值是最后一个列表项。

内部函数message在辅助输入区中显示一条信息，其第一个参数是一个输出格式字符串，其它的为参数名。
%s 
%c
%d
%e
%f
%g

==== 把LISP函数转化为Emacs命令 ====
上述的函数有一个问题：在执行后，光标会移动到缓冲区的末尾。这是LISP命令普遍存在的问题，解决的方法是用save-exeurion函数：
(save-excursion
   statement-block)
用这个函数后，语句块中的语句被执行时引起的光标移动在Emacs的内部进行，不会显示在屏幕上。在执行完毕后，插入点和文本块标记将出现在原先的位置。save-excursion函数的返回值是语句块中最后一条语句的返回值。

在解决了光标移动问题后，还要解决函数的登记问题：必须先对函数进行注册，然后才能在LISP交互式模式中使用。
(interactive "prompt-string")
这条语句必须是函数里的第一条语句，也就是跟在defun和文档字符串行后面。interactive函数的作用时把函数注册为Emacs的一个命令，这样在执行他时，Emacs会提示用户输入你在defun语法里声明的参数，这个函数的提示字符串是可选的。interactive是按照提示字符串中子字符串先后顺序为函数参数提供值的。

注意提示字符串有特殊要求，你必须为每一个你想提示用户输入的参数准备一个提示字符串的子串，子字符串用\n字符分割，每个子字符串的第一个字符必须是一个用来表示该参数类型的代码。
参数类型代码：
b	一个现有编辑缓冲区名字
e 	事件：鼠标动作或功能键动作
f	现有文件名
n	数字（整数）
s	字符串
B 	一个可能不存在的缓冲区名字
F	一个可能不存在的文件名字
S	符号
interactive函数还有一个选项r，当以交互式调用函数时，自动把函数的两个参数值设为point和mark函数的返回值。

文档字符串时用户发出describe-function等在线帮助命令时将会看到的帮助信息，他们时可选的，长度时任意多行，传统上其第一行应是对命令功能进行介绍的一个完整而精炼的句子。

===== LISP语言基础函数 =====
基础函数时用来打造自己工作函数的建筑材料，LISP在其它程序设计语言使用操作符(用于算术、比较、逻辑运算）的地方使用的是函数。

==== 算术运算： ====
	+ 、- 、*、/、%、1+、1-、max、min


==== 关系运算： ====
	>、>=、<  、<=、/=
	= 用于数字和字符
	equal 等于，用于字符串和其它复杂的字符串


==== 逻辑运算 ====
	and or not
除 1+ 1- %外其它的算术函数都可以有任意个参数，逻辑运算也是如此。算术运算只有在其参数中至少有一个是浮点数时才返回浮点值。

==== 语句块 ====
LISP语言中可以定义语句块的两个函数是:progn和let。
progn是最基础的：
(progn
	statemetn-block)
progn是个让一个语句块看起来就像是一条语句的简单方法，与C中的花括号类似，返回值时语句块中最后一条语句的值。progn特别适合向if这样的控制
结构中，因为这些控制结果不像while那样允许使用语句块。
let函数的变体：
(let (var1 var2 ...)
	statement-block)
上面没有使用(var value)这样的列表，它只是一个由变量名组成的列表，所有的变量被初始化为nil。在有些场合如
let在定义变量时需要用某些局部变量的值来计算另一些局部变量的值，这需要用let的另一种形式  let*.

==== 控制结构 ====

LISP提供了三种控制结构：while、if、cond。

if函数的语法为：
(if	condition
	true-case
	false-block)
true-case必须是单独的一条语句，而false-block则是一个语句块可以省略。

cond相当于C中的case或switch语句，语法为：
(cond
	(condition1
		statment-block)
	(condition2 
		statment-block2)
	....)


==== Emacs内部函数 ====
内部函数是指许多现成的Emacs函数和一些自己开发的函数，它们大部分与字符串和编辑缓冲区中的文本处理工作有关。
与缓冲区和文本有关的函数：
函数名		返回值或执行的动作
point		光标的位置
mark		文本块标记的字符位置

point-min	最小字符位置(通常是1)
point-max	最大字符位置，通常为缓冲区的长度

bolp			光标是否位于行首
eolp			光标是否位于行尾
bobp		光标是否位于缓冲区开始
eobp		光标是否位于缓冲区末尾

insert		把任意个数的参数(字符或字符串)插入到光标之后

==== 正则表达式 ====

如果要对正则表达式中的元字符进行转义，就必须在它的前面加上两个连续的反斜线字符如\\*匹配一个星号字符，这里使用两个星号的原因与Emacs LISP
读取和解码字符串的操作方法有关，在读取字符串到一个LISP程序里时Emacs会把两个斜线转换为单个反斜线字符。但是把把正则表达式字符串交互式地
输入到用户级命令时只有一个斜线就够了。

正则表达式操作符汇总：
操作符		作用
.			匹配任意一个字符
* 匹配前面的字符或字符组零次或多次
+			...一次或多次
？			零次或一次
[...]
\\(  \\)
\\| 		匹配前后的子表达式，其作用范围是直到正则表达式开头、结尾、一个\\( 、一个\\)或另一个\\|^
^
$
\n
\t
\\<
\\>
\\N

==== 使用正着表达式的函数 ====
用户级命令，他们都可以用在LISP代码中：
re-search-forward
re-search-backward
replace-regexp
query-replace-regexp
isearch-forward-regexp
isearch-backward-regexp

还有一些不能作为用户级命令使用但可以出现在LISP代码中的函数：
looking-at	输入参数为正则表达式，查看光标后面的文本是否匹配该表达式，若是会截取\\(和\\)之间的片段并保持工艺后使用。
string-match	参数为一个正则表达式和一个字符串，返回匹配正则表达式的首字符在字符串中的索引
match-beginning
match-end	用来检索被保存起来的字符串片段，返回的时字符串片段在文本缓冲区的起始点和结束点。
buffer-string	把整个缓冲区作为一个字符串返回
buffer-substring	两个参数指定子字符串在缓冲区的起始和结束位置，把截取的子字符串返回。

===== 主编辑模式程序设计实例 =====

==== 主编辑模式的组建 ====
符号 	实现这个主编辑模式的函数名称
名字	显示在状态行括号的名称
局部键位图	用来定义这个主编辑模式里各种命令的按键绑定
变量和常数	为实现这个编辑模式，LISP代码使用的一些局部变量和局部常数
专用编辑缓冲区	这个主编辑模式下有特殊用途的编辑缓冲区

=== 一、设置主编辑模式的符号 ===
(setq major-mode	'mode-name)

=== 二、设置主编辑模式的名字 ===
(setq	mode-name	"stings")

=== 三、局部键位映射表 ===

== 1.定义映射表 ==
 (setq tmpkeymap (make-keymap))   ;; set up the keymap var
 也可以使用make-keymap的特殊形式：如果需要绑定的按键数目不大，使用make-sparse-keymap更有效。

== 2.把映射表设为主编辑模式的局部键位映射表 ==
(use-local-map	tmpkeymap)

=== 四：定义和设置局部变量 ===

== 1.定义变量 ==
有几种定义变量的方法，比如setq给参数赋值或用let给语句块定义并初始化参数，更正规的方法是使用defvar函数。它允许程序员将变量的资料集成到
C-h v等在线帮助功能中。defvar函数的语法是：
(defvar	varname	initial-value	"description of the variable")
defvar还有一个变体叫做defconst用来定义常数。

== 2/设置局部变量 ==
把变量设为主编辑模式的局部变量。
(make-local-variable	'variable-name) ;;注意使用的是变量名而非其值

==== 五：专用特殊缓冲区 ====
这些缓冲区与任何文件都没有关联关系，要想在新窗口创建一个新的编辑缓冲区可以使用pop-to-buffer函数：
(pop-to-buffer	"*Calc*")
其它的变体：
switch-to-buffer	与命令C-x b相同
set-buffer	将编辑缓冲区指定为文本编辑缓冲区使用






















	
