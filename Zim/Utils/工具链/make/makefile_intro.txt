Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2012-06-08T14:32:33+08:00

====== makefile intro ======
Created Friday 08 June 2012

Make (software)   From Wikipedia, the free encyclopedia

In software development, Make is a utility that automatically //builds executable programs and libraries// from source code by reading files called **makefiles** which specify how to derive the target program. Though integrated development environments and language-specific compiler features can also be used to manage a build process, Make remains widely used, especially in Unix.

Contents

    1 Origin
    2 Modern versions
    3 Behavior
    4 Makefiles
        4.1 Rules
        4.2 Macros
        4.3 Suffix rules
        4.4 Other elements
    5 Example makefiles
    6 See also
    7 References
    8 External links

===== Origin =====

There are now a number of **dependency-tracking build utilities**, but Make is one of the most widespread, primarily due to its inclusion in Unix, starting with the PWB/UNIX 1.0, which featured a variety of tools targeting software development tasks. It was originally created by Stuart Feldman in 1977 at Bell Labs. In 2003 Dr. Feldman received the ACM Software System Award for the authoring of this widespread tool.[1]

Before Make's introduction, the Unix build system most commonly consisted of operating system dependent "make" and "install" shell scripts accompanying their program's source.[citation needed] Being able to combine the commands for the different targets into a single file and being able to abstract out dependency tracking and archive handling was an important step in the direction of modern build environments.

===== Modern versions =====

Make has gone through a number of rewrites, including a number of from-scratch variants which used the same file format and basic algorithmic principles and also provided a number of their own non-standard enhancements. Some of them are:

* BSD Make (pmake), which is derived from Adam de Boor's work on a version of Make capable of building targets in parallel, and survives with varying degrees of modification in FreeBSD, NetBSD and OpenBSD. Most notably, it has conditionals and iterative loops which are applied at the parsing stage and may be used to conditionally and programmatically construct the makefile, including generation of targets at runtime.
* GNU Make is frequently used in conjunction with the GNU build system. Its departures from traditional Make are most noticeable in **pattern-matching** in dependency graphs and build targets, as well as a number of functions which may be invoked allowing functionality like listing the files in the current directory. It is also included in Apple’s Xcode development suite for the Mac OS.
* Microsoft nmake, commonly available on Windows. It is fairly basic in that it offers only a subset of the features of the two versions of Make mentioned above. Microsoft's nmake is not to be confused with nmake from AT&T and Bell Labs for Unix.

POSIX includes standardization of the basic features and operation of the Make utility, and is implemented with varying degrees of completeness in Unix-based versions of Make. In general, simple makefiles may be used between various versions of Make with reasonable success. GNU Make and BSD Make can be configured to look first for files named "GNUmakefile" and "BSDmakefile" respectively,[2][3] which allows one to put makefiles which use implementation-defined behavior in separate locations.

===== Behavior =====

Make is typically used to **build executable programs and libraries** from source code. Generally though, any process that involves transforming a source file to a target result (by executing arbitrary commands) is applicable to Make. For example, Make could be used to //detect a change// made to an image file (the source) and the transformation actions might be to convert the file to some specific format, copy the result into a content management system, and then send e-mail to a predefined set of users that the above actions were performed.

Make is invoked with a list of target file names to build as command-line arguments:

    //make TARGET [TARGET ...]//

Without arguments, Make builds **the first target** that appears in its makefile, which is traditionally a symbolic "phony" target named all.

Make decides whether a target needs to be regenerated by **comparing file modification times.** This solves the problem of avoiding the building of files which are already up to date, but it fails when a file changes but its modification time stays in the past. Such changes could be caused by restoring an older version of a source file, or when a network filesystem is a source of files and its clock or timezone is not synchronized with the machine running Make. The user must handle this situation by **forcing a complete build**. Conversely, if a source file's modification time is in the future, it triggers unnecessary rebuilding, which may inconvenience users.

===== Makefiles =====

Make searches the current directory for the makefile to use, e.g. GNU make searches files in order for a file named one of //GNUmakefile, makefile, Makefile// and then runs the specified (or default) target(s) from (only) that file.

The makefile language is similar to declarative programming.[4][5][6][7] This class of language, in which necessary end conditions are described but the order in which actions are to be taken is not important, is sometimes confusing to programmers used to imperative programming.

One problem in build automation is the tailoring of a build process to a given platform. For instance, the compiler used on one platform might not accept the same options as the one used on another. This is not well handled by Make. This problem is typically handled by **generating platform specific build instructions**, which in turn are processed by Make. Common tools for this process are __Autoconf__ and __CMake__.

===== Rules =====

A makefile consists of rules. Each rule begins with a textual dependency line which defines a target followed by a colon (:) and optionally an enumeration of components (files or other targets) on which the target depends. **The dependency line** is arranged so that the target (left hand of the colon) depends on components (right hand of the colon). It is common to refer to components as prerequisites of the target.

For example, a C .o object file is created from .c files, so you need to have .c files first (i.e. specific object file target depends on a C source file and header files). Because Make itself does not understand, recognize or distinguish different kinds of files, this opens up a possibility for human error. //A forgotten or an extra dependency// may not be immediately obvious and may result in subtle bugs in the generated software. It is possible to write makefiles which __generate these dependencies by calling third-party tools（如使用gcc -M或 gcc -MM命令生成源文件的头文件依赖关系）__, and some makefile generators, such as the **Automake** toolchain provided by the GNU Project, can do so automatically.

After each dependency line, a series of **command lines** may follow which define how to transform the components (usually source files) into the target (usually the "output"). If any of the components have been modified, the command lines are run.

Make can decide where to start through __topological sorting__.

Each command line must __begin with a tab character to be recognized as a command__. The tab is a whitespace character, but the space character does not have the same special meaning. This is problematic, since there may be no visual difference between a tab and a series of space characters. This aspect of the syntax of makefiles is often subject to criticism.

__Each command is executed by a separate shell__ or command-line interpreter instance. Since operating systems use different command-line interpreters this can lead to unportable makefiles. For instance, GNU Make by default executes commands with **/bin/sh**, where Unix commands like cp are normally used. In contrast to that, Microsoft's nmake executes commands with cmd.exe where batch commands like copy are available but not necessarily cp.

    target [target ...]: [component ...]
    [<TAB>command 1]
           .
           .
           .
    [<TAB>command n]

Usually each rule has a single unique target, rather than multiple targets.

A rule may have no command lines defined. The dependency line can consist solely of components that refer to targets, for example:

    //realclean: clean distclean//

The command lines of a rule are usually arranged so that they generate the target. An example: if "file.html" is newer, it is converted to text. The contents of the makefile:

    //file.txt: file.html//
//            lynx -dump file.html > file.txt//

The above rule would be triggered when Make updates "file.txt". In the following invocation, Make would typically use this rule to update the "file.txt" target if "file.html" were newer.

    make file.txt

Command lines can have one or more of the following three prefixes:

* a hyphen–minus (-), specifying that errors are ignored
* an at sign (@), specifying that the command is not printed to standard output before it is executed
* a plus sign (+), the command is executed even if Make is invoked in a "do not execute" mode

**Ignoring errors** and **silencing echo** can alternatively be obtained via the special targets "__.IGNORE"__ and __".SILENT"__.[8]

Microsoft's NMAKE has predefined rules that can be omitted from these makefiles, e.g. "c.obj $(CC)$(CFLAGS)".

===== Macros =====

A makefile can contain definitions of macros. Macros are usually referred to as variables when they hold simple string definitions, like "CC=gcc". **Macros in makefiles may be overridden in the **__command-line arguments__** passed to the Make utility**. __Environment variables__** are also available as macros.**

Macros allow users to specify the programs invoked and other custom behavior during the build process. For example, the macro "CC" is frequently used in makefiles to refer to the location of a C compiler, and the user may wish to specify a particular compiler to use.

New macros (or simple "variables") are traditionally defined using capital letters:

    MACRO = definition

A macro is used by **expanding** it. Traditionally this is done by enclosing its name inside $(). A rarely used but equivalent form uses curly braces rather than parenthesis, i.e. ${}.

    NEW_MACRO = $(MACRO)-$(MACRO2)

Macros can be __composed of shell commands__ by using the command substitution operator, denoted by backticks (`).

    YYYYMMDD  = **` date `**

The content of the definition is stored "as is". __Lazy evaluation is used__, meaning that macros are normally expanded __only when__ their expansions are actually required, such as when used in the command lines of a rule. An extended example:

    PACKAGE   = package
    VERSION   = ` date +"%Y.%m%d" `
    ARCHIVE   = $(PACKAGE)-$(VERSION)
 
    dist:
            #  Notice that only now macros are expanded for shell to interpret:
            #      tar -cf package-`date +"%Y%m%d"`.tar
 
            tar -zcf $(ARCHIVE).tar .

The generic syntax for **overriding macros** on the command line is:

    make MACRO="value" [MACRO="value" ...] TARGET [TARGET ...]

Makefiles can access any of a number of __predefined internal macros__, with '?' and '@' being the most common.

    target: component1 component2
            echo $? contains those components, which need attention (i.e. they ARE __YOUNGER__ than current TARGET).
            echo $@ evaluates to **current TARGET** name from among those left of the colon.

===== Suffix rules =====

Suffix rules have "targets" with names in the form __.FROM.TO__ and are used to launch actions based on file extension. In the command lines of suffix rules, POSIX specifies[9] that the internal macro __$<__ refers to the prerequisite and __$@__ refers to the target. In this example, which converts any HTML file into text, the shell redirection token > is part of the command line whereas $< is a macro referring to the HTML file:

    .SUFFIXES: .txt .html
 
    # From .html to .txt
    .html.txt:
            lynx -dump $<   >   $@

When called from the command line, the above example expands.

    $ make -n file.txt
    lynx -dump file.html > file.txt

===== Other elements =====

Single-line comments are started with the hash symbol (#).

Some directives in makefiles can include other makefiles.

Line continuation is indicated with a backslash \ character at the end of a line.

    target: component \
            component
    <TAB>command ;          \
    <TAB>command |          \
    <TAB>piped-command

===== Example makefiles =====

Makefiles are traditionally used for compiling code (*.c, *.cc, *.C, etc.), but they can also be used for providing commands to **automate common tasks**. One such makefile is called from the command line:

    make                        # Without argument runs first TARGET
    make help                   # Show available TARGETS
    make dist                   # Make a release archive from current dir

The makefile:

    PACKAGE      = package
    VERSION      = ` date "+%Y.%m%d%" `
    RELEASE_DIR  = ..
    RELEASE_FILE = $(PACKAGE)-$(VERSION)
 
    # Notice that the variable LOGNAME **comes from the environment** in
    # POSIX shells.
    #
    # target: all - Default target. Does nothing.
    all:
            echo "Hello $(LOGNAME), nothing to do by default"
            # very rarely: echo "Hello ${LOGNAME}, nothing to do by default"
            echo "Try 'make help'"
 
    # target: help - Display callable targets.
    **help:**
**            egrep "^# target:" [Mm]akefile**
 
    # target: list - List source files
    list:
            # Won't work. E__ach command is in separate shell__
            cd src
            ls
 
            # Correct, continuation of the same shell
            cd src; \
            ls
 
    # target: dist - Make a release.
    dist:
            tar -cf  $(RELEASE_DIR)/$(RELEASE_FILE) && \
            gzip -9  $(RELEASE_DIR)/$(RELEASE_FILE).tar

Below is a very simple makefile that by default (the "all" rule is listed first) compiles a source file called "helloworld.c" using the gcc C compiler and also provides a "clean" target to remove the generated files if the user desires to start over. The $@ and $< are two of the so-called __internal macros__ (also known as __automatic variables__) and stand for the target name and "implicit" source, respectively. In the example below, $^ expands to a space delimited list of the prerequisites. There are a number of other internal macros.[9][10]

    CC     = gcc
    CFLAGS = -g
 
    all: helloworld
 
    helloworld: helloworld.o
            # Commands start with TAB not spaces
            $(CC) $(LDFLAGS) -o $@ $^
 
    helloworld.o: helloworld.c
            $(CC) $(CFLAGS) -c -o $@ $<
 
    clean: FRC
            rm -f helloworld helloworld.o
 
    # This pseudo target causes all targets that depend on FRC
    # t**o be remade** even in case a file with the name of the target exists.
    # This works with any make implementation under the assumption that
    # there is no file FRC in the current directory.
    FRC:

Many systems come with __predefined Make rules and macros__ to specify common tasks such as compilation b__ased on file suffix__. This allows user to omit the actual (often unportable) instructions of how to generate the target from the source(s). On such a system the above makefile could be modified as follows:

    all: helloworld
 
    helloworld: helloworld.o
        $(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^
 
    clean: FRC
        rm -f helloworld helloworld.o
 
    # This is an explicit suffix rule. It may be omitted on systems
    # that handle simple rules like this automatically.
    .c.o:
        $(CC) $(CFLAGS) -c $<
 
    FRC:
    .SUFFIXES: .c


That "helloworld.o" depends on "helloworld.c" is now automatically handled by Make. In such a simple example as the one illustrated here this hardly matters, but the real power of __suffix rules__ becomes evident when the number of source files in a software project starts to grow. One only has to write a rule for the linking step and declare the object files as prerequisites. Make will then implicitly determine how to make all the object files and look for changes in all the source files.

Simple suffix rules work well __as long as__ **the source files do not depend on each other and on other files such as header files**. Another route to simplify the build process is to use so-called __pattern matching rules__ that can be combined with compiler-assisted dependency generation. As a final example requiring the gcc compiler and GNU Make, here is a generic makefile that compiles all C files in a folder to the corresponding object files and then links them to the final executable. Before compilation takes place, dependencies are gathered in makefile-friendly format into a hidden file __".depend"__ that is then included to the makefile.

    # Generic GNUMakefile
 
    # Just a snippet to stop executing under other make(1) commands
    # that won't understand these lines
    ifneq (,)
    This makefile requires GNU Make.
    endif
 
    PROGRAM = foo
    C_FILES := $(//wildcard// *.c)
    OBJS := $(//patsubst// %.c, %.o, $(C_FILES))
    CC = cc
    CFLAGS = -Wall -pedantic
    LDFLAGS =
 
    all: $(PROGRAM)
 
    $(PROGRAM): **.depend** $(OBJS)
        $(CC) $(CFLAGS) $(OBJS) $(LDFLAGS) -o $(PROGRAM)
 
    **depend: .depend**
 
    .depend: cmd = gcc __-MM__ -MF depend $(var); cat depend >> .depend;
    **.depend:**
        @echo "Generating dependencies..."
        @$(foreach var, $(C_FILES), $(cmd))
        @rm -f depend
 
    **-include .depend**
 
    # These are the pattern matching rules. In addition to the automatic
    # variables used here, the variable $* that matches whatever % stands for
    # can be useful in special cases.
    **%.o: %.c**
        $(CC) $(CFLAGS) -c $< -o $@
 
    **%: %.c**
        $(CC) $(CFLAGS) -o $@ $<
 
    clean:
        rm -f .depend *.o
 
    .PHONY: clean depend
