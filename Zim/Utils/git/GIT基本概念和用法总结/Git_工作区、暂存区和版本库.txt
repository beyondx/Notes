Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2012-02-19T14:11:23+08:00

====== Git 工作区、暂存区和版本库 ======
Created Sunday 19 February 2012
http://www.worldhello.net/2010/11/30/2166.html#comment-426

暂存区（stage, index）是 Git 最重要的概念之一，理解了这个概念很多 Git 命令就不再那么神秘了。 今天在写这部分的内容，画了一个图，看看有没有什么问题。 理解 Git 暂存区（stage） 把上面的“实践二”从头至尾走一遍，不知道您的感想如何？

    —— “被眼花缭乱的 Git 魔法彻底搞糊涂了？”
    —— “Git 为什么这么折磨人，修改的文件直接提交不就完了么？”
    —— “看不出 Git 这么做有什么好处？”

在“实践二”的过程中，我有意无意的透漏了“暂存区”的概念，为了避免用户被新概念吓坏，在暂存区出现的地方用同时使用了“提交任务”这一更易理解 的概念，但是暂存区（stage, 或称为 index）才是其真正的名称。我认为__ Git 暂存区（stage, 或称为 index）的设计是 Git 最成功的设计之一__，也是最难理解的一个设计。 在版本库（.git）目录下，有一个 index 文件，我们针对这个文件做一个有趣的试验。 首先我们执行 "git checkout" 命令撤销工作区中 welcome.txt 文件尚未提交的修改。

$ git checkout -- welcome.txt
$ git status -s

我们通过状态输出，看以看到工作区已经没有改动了。我们查看一下 .git/index 文件，注意该文件的时间戳（19:37:44）：

$ ls --full-time .git/index
-rw-r--r-- 1 jiangxin jiangxin 112 2010-11-29 19:37:44.625246224 +0800 .git/index

我们再次执行 "git status" 命令，然后显示 .git/index 文件的时间戳（19:37:44），和上面的一样。

$ git status -s
$ ls --full-time .git/index
-rw-r--r-- 1 jiangxin jiangxin 112 2010-11-29 19:37:44.625246224 +0800 .git/index

现在我们**更改一下 welcome.txt 的时间戳**，但是不改变它的内容。然后再执行 "git status" 命令，然后查看 .git/index 文件时间戳（19:42:06）。

$ touch welcome.txt
$ git status -s
$ ls --full-time .git/index
-rw-r--r-- 1 jiangxin jiangxin 112 2010-11-29 19:42:06.980243216 +0800 .git/index

看到了么，时间戳改变了！ 这个试验说明__当执行 "git status" 命令扫描工作区改动的时候，先依据 .git/index 文件中记录的（工作区跟踪文件的）时间戳、长度等信息判断工作区文件是否改变__。如果工作区的文件时间戳改变，说明**文件的内容可能被改变了**，需要要打开文件，读取文件内容，和更改前的原始文件相比较，判断文件内容是否被更改。如果文件内容没有改变，则__将该文件新的时间戳记录到 .git/index 文件中__。

因为判断文件是否更改，**使用时间戳、文件长度等信息进行比较要比通过文件内容比较要快的多**，所以 Git 这样的实现方式可以让工作区状态扫描更快速的执行，这也是 Git 高效的因素之一。

__文件 .git/index 实际上就是一个包含文件索引的目录树，像是一个虚拟的工作区。__在这个虚拟工作区的目录树中，记录了**文件名、文件的状态信息（时间戳、文件长度等）**，文件的内容并不存储其中，而是保存在 Git 对象库（.git/objects）中（有**git add**命令添加），__文件索引建立了文件和对象库中对象实体之间的对应__。下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系。
{{./git-stage.png}}
						工作区、版本库、暂存区原理图

在这个图中，我们可以看到部分 Git 命令是如何影响工作区和暂存区（stage, index）的。

* 图中左侧为工作区，右侧为版本库。在版本库中标记为 "index" 的区域是__暂存区__（stage, index），标记为 "master" 的是 master 分支所代表的**目录树（由commit对象代表）**。
* 图中我们可以看出此时 __"HEAD" 实际是指向 master 分支的一个“游标”__。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。
* 图中的 objects 标识的区域为__ Git 的对象库__，实际位于 ".git/objects" 目录下，我们会在后面的章节重点介绍。
* 当对工作区修改（或新增）的文件**执行 "git add" 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID 被记录在暂存区的文件索引中。**
* 当执行提交操作（git commit）时，**暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树**。
* 当执行 "git reset HEAD" 命令时，__暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响__。
* 当执行 "git rm --cached <file>" 命令时，会直接__从暂存区删除文件，工作区则不做出改变__。
* 当执行 "git checkout ." 或者 "git checkout -- <file>" 命令时，会__用暂存区全部或指定的文件替换工作区的文件__。这个操作很危险，会清除工作区中未添加到暂存区的改动。
* 当执行 "git checkout HEAD ." 或者 "git checkout HEAD <file>" 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件__替换暂存区和以及工作区中的文件__。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改 动。
