Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2012-03-18T16:10:36+08:00

====== xmodmap ======
Created Sunday 18 March 2012

http://lins05.mysmth.net/2011/04/24/67/

===== Linux改键利器：Xmodmap 的简单教程 =====
Linux改键利器：Xmodmap 的简单教程 适用对象：
* Emacs用户，需要交换 CapsLock 和 left Ctrl的人
* 其他有改键需要的人
* 喜欢瞎折腾的人

对于一般用户，如果没有特殊的需要，可能从未听说过`Xmodmap`这个程序。即使听说，也跟 xinit/Xsession/X 一样蒙着一层神秘的面纱。今天，我由于迫切地想把左边的windows键给屏蔽掉（原因就说来话长了），Goolge了半天没有找到一个现成的答案，唯一的线索是可以使用xmodmap来实现。 最后不得不一行行地读 xmodmap的man，二十分钟之后，发现原来如此简单。心血来潮之际，写一个简单的教程，以xb心中的得意之情，同时以后也可以作为自己和别人的参考。 

===== 提出问题： =====
如何交换CapsLock和左边的Ctrl键？ 答：

xmodmap -e "remove **lock** = Caps_Lock" ;
xmodmap -e "remove **control** = Control_L"; 
xmodmap -e "add control = Caps_Lock"; 
xmodmap -e "add lock = Control_L" 

后面的内容是具体的教程，前面是提供给只需要一个做法而不需要了解具体的原理的。如果你属于此类，完全可以不看后面的内容了。 不过原理很简单，而且一旦学会，改键就跟grep一个正则表达式差不多简单。

===== 分析问题： =====
看到这里的人，应该是有耐心理解下面三个概念的： keycode/keysym/modifier 这三个概念是键盘相关的、层次从低到高的三个名词。

===== keycode– =====
一般的键盘上有102或者105键，每一个键被按下时会产生一个特有类型、主板能够分辨的电信号，传输给主板，主板给不同的电信号定下不同的编号，这就是所谓的keycode。 这些电信号是__在生产键盘时就定死了的__，比如左边的Ctrl键产生的keycode是37。CapsLock键产生的keycode是66。 要查找某个按键的keycode，可以在term中用__`xev`__程序来查看。xev使用很简单，它运行时，你按下一个键，term中就会显示这个键的许多信息，其中就有keycode。 这些keycode是硬件决定的，你我无法改变。总之记住，__一个按键产生的keycode是不可能在软件中改变的__。

===== keysym– =====
操作系统按照统一的规范，给不同的keycode映射为不同的含义，这个映射后的含义的术语就叫做keysym。比如你在emacs中打字时按下一个s键。屏幕上出现一个`s`，而不是出现一个`b`，是因为：系统接收到s的keycode–我用xev查了下，keycode(s) = 39， 按照默认的标准，39对应于字母`s`，于是就这个`s`显示在屏幕上。 (当然，更严谨地、更准确地说，应该是把`s`这个字母作为输入传递给Emacs，emacs再把这个字母插入到当前的文件中的。) 这里，keycode是39，其对应的符号，术语叫keysym，即`key symbol`，就是字母`s`。 同理,你按下键盘上的’b'(keycode(b) = 56)，它的(默认的)keysym就是字母`b`。 系统给一个keycode分配的keysym不只一个。对于一个字母键，至少两个。第一个是单独按下这个键时对应的一，第二个是shift和这个键同时按下时的keysym。 键盘上，还有另外一类按键，它们单独按下时，一般没有任何意义，只有与其他的按照一直按下时是，才会产生一些特殊的效果，比如Ctrl、Shift、win键；它们实现的效果，称为modifier。
Modifier–修饰符

“修饰符”的修饰二字很好解释，你按下s，是打一个字母s，你按下Ctrl+s，大部分软件里，会保存当前文件；你按下Shift+s，是打另一个字母S。总之是, “改变一个键的本来含义“。因为`modify`本来就是修改的意思。 在term里输入命令`xmodmap`，会出现以下内容

    shift       Shift_L (0×32),  Shift_R (0×3e) lock control     Control_R (0×25),  Caps_Lock (0×42),  Control_R (0×69) mod1        Alt_L (0×40),  Alt_R (0×6c),  Meta_L (0xcd) mod2        Num_Lock (0×4d) mod3 mod4        Super_L (0×85),  Super_R (0×86),  Super_L (0xce),  Hyper_L (0xcf) mod5        ISO_Level3_Shift (0×5c),  Mode_switch (0xcb) 左边那一列，就是系统中所有的`modifier`。 系统会把一些默认的keysym解释为modifier，比如，默认情况下，你按下Shift + s， 屏幕上出现大写的S,整个过程其实是：

    系统收到Shift键和s键的keycode
    系统处理 keycode–>keysym 的映射: shift的keycode被映射到`SHIFT_L`这个keysym；s的keycode被映射到`s`这个keysym
    系统发现，SHIFT_L这个keysym被定义为shfit这个modifier。
    `s`被shift这个modifier给修饰了，修饰的结果是变成了大写的S。

基本概念讲完了，那么，`xmodmap`是如何帮我们实现`改键`的呢？ 可以看到，从按下一个键到最后，有两个层次的映射过程：

    第一层： keycode–>keysym
    第二层： keysym –> modifier

因此，我们可以通过两种方法来实现改键。以
第一步：
目标：把键盘上的s和b键交换位置

先查询keycode: keycode(s) = 37 keycode(b) = 56

    xmodmap -e "keycode 37 = b" xmodmap -e "keycode 56 = s" 这样，就交换了 s/b 这两个键的位置了！ 注意，在你执行了第一条语句之后，s立刻被重新映射到b了，那么你第二条语句中的`s`怎么打出来呢？ 两个方法： i) 从别处粘贴一个过来 ii)见最后的`xmodmap执行命令的三种方式` 注意：这个方法只能交换一般的keysym，那些定义为Modifier的键，就不能简单地用这个方式交换。因为： 当一个keysym被定义为modifier，那么，本质上是在 keycode–>modifier之间建立起了一个映射。因此，即使你改变了它的keycode–>keysym关系，也不起作用！ 也就是说：当你要把一个键定义一个modifier时，你只能把它的keycode对应的keysym定义为modifier，从而达到目的。但这之后，即使keycode映射到别的keysym了，这个keycode仍然是一个modifier。 因此，如果要交换CapsLock和Ctrl这两个键，只需要做两件事：

    把`Caps_Lock`这个keysym定义为`control`这个modifer
    把`Control_L`这个keysym定义为`Caps_Lock`这个modifier （Control_L是左Ctrl键的默认keysym)

第二步： 交换 Caps_Lock和 左边的Ctrl

先把CapsLock这个keysym映射到control这个modifier：

    xmodmap -e "remove lock = Caps_Lock" xmodmap -e "add control = Caps_Lock" 因为一个keysym不能同时映射到两个modifier，因此，我们需要先用remove，把Caps_Lock这个keysym与lock这个modifier的映射关系删除。然后，再把Caps_Lock这个keysym映射到Control这个modifier。 remove和add的的语法是：

    remove/add modifier_name = keysym_name 此时，你可以试一下，看看是否已经产生效果了？ 同样，再把左边的Ctrl键映射到CapsLock：

    xmodmap -e "remove control = Control_L" xmodmap -e "add Caps_Lock = Control_L" xmodmap执行命令的三种方式： 1) xmodmap -e "do somthing" 是让xmodmap执行后面的一条句子。但这样一次只能执行一条。 2) 你也可以先输入 `xmodmap -`，然后回车，然后输入任意多句子，每输入一条就用回车分隔，最后用Ctrl+D结束输入。 3) 把remove xxx = yyy 这些句子都写到一个文件里。一般是~/.Xmodmap。然后用 `xmodmap ~/.Xmodmap`执行。 这样的好处是，在启动时的某个脚本里加一行命令，就不用每次重启都手动地改键了。 第三层：可逆的改键： 不难看出，运行了上面方法二中的四句命令之后，如果想要改回来的话，还需要另外写四句。以下六句可以实现这 样的效果，第一次运行，是交换CapsLock和Ctrl_L，第二次运行，又会再交换回来。

    remove lock = Caps_Lock remove control = Control_L keysym Caps_Lock = Control_L keysym Control_L = Caps_Lock add lock = Caps_lock add control = Control_L 为什么会有这个效果呢？是因为多了中间两句话。

    keysym Caps_Lock = Control_L –keycode 66 = Control_L keysym Control_L = Caps_Lock –keycode 37 = Caps_Lock “keysym A = B” 这个句子相当于： 把所有原来映射到A的keycode重新映射到 B。比如，有一个键Q，他的keycode原来对应的keysym是A，那么，在执行了上面语句之后，这个键Q的keycode对应的keysym就是B 因此， keysym Caps_Lock = Control_L –把Cap键映射到Control_L这个keysym keysym Control_L = Caps_Lock –把Ctrl键映射到Caps_Locks这个keysym

转载请注明出处。 可能有不正确的 地方，本文不负任何责任。
