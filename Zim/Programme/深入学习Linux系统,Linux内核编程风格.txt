Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2011-04-16T16:18:34+08:00

====== 深入学习Linux系统,Linux内核编程风格 ======
Created Saturday 16 April 2011

这篇短小的文档用于描述Linux内核编程中推荐的编程风格。编程风格是很个人化的东西，我不想把我的观点_强加_给任何人，但这是我必须维护的代码中所遵守的，我也建议其他部分的代码也能遵守它。请至少给这里的观点一些考虑。

首先，我建议你打印一份GNU代码风格，不是去读它，而是把它烧了，这是个很不错的姿态。

下面就是Linux内核编程风格：

第一章：缩进

制表符（tabs）占8个字符，所以缩进也是8个字符。有些异端运动想使用4个字符（甚至是2个字符）的缩进，这和把PI（圆周率）定为3没什么两样。

原因：缩进的根本目的是用来清晰地标识一个控制块的起始。特别是当你连续盯着屏幕看了20 个小时后，你就会体会到更长的缩进的好处了。

现在，有些人提出8字符缩进会使得代码太偏向右边，当使用80字符的终端时很难阅读。答案是如果你需要三层以上的缩进，那么你已经完蛋了，应该改改你的程序了。

简而言之，8字符缩进使得阅读代码更为容易，并且在你的缩进层次过深时提出警告。应该留心这样的警告。关于这一点，我不能苟同，4个字符的缩进确实有它的好处，缩进太多反而看着累。而且有时候仅仅两层嵌套就会使代码很长。

第二章：括号的位置

括号位置的问题在C编程风格中经常被提出。和缩进大小不同，括号位置的选择并没有太多技术上的原因，而更多的是个人的喜好。比如Kernighan和Ritchie的弟子们把左括号放在一行的最后，把右括号放在一行的开始，象这样：

　if (x is true) {

　　we do y

　　}

但是，函数是一种特殊的情况，函数的左括号放在下一行的开始，象这样：

int function(int x)

　　{

　　body of function

　　}

全世界的异端人士指出这种不一致的做法 ...嗯... 不太一致，但是所有思维正确的人知道 (a) K&R是_对_的 (b) K&R是对的。而且，函数确实是特殊的（你在C中无法对函数进行嵌套）。

注意到右括号完全占有单独的一行，_除非_当它后面还有未完成的语句，比如do语句中的“while”或者if语句中的“else”，想这样：

do {

　　body of do-loop

　　} while (condition);

和

if (x == y) {

　　..

　　} else if (x > y) {

　　...

　　} else {

　　....

　　}

还有，注意到这种括号的布局方法还减少了空行（或者说是几乎是空行）的数目，而且没有减小可读性。因为你屏幕上的空行是不可回收资源（这里想一下25行的终端屏幕），这样你会有更多的空行用于加注释。

第三章：命名

C是个斯巴达式（崇尚简洁风格的）语言，所以你的命名方法也应该如此。与Modula-2和Pascal程序员不同，C程序员不使用ThisVariableIsATemporaryCounter这样可爱的名字。一个C程序员会把一个变量

叫做“tmp”，这样的变量名更容易写，而且理解起来也不算太难。但是_，尽管人人都会对大小写混杂的名字皱眉头，全局变量名则必须如此。管一个全局函数叫“foo”是故意找岔。

全局_变量（只有在_真正_需要时才使用）需要有个描述性强的名字，这点和全局函数一样。如果你有个函数用于对活跃用户进行计数，你应该叫它“count_active_users()”，而不是“cntusr()”。

把函数的类型加入到名字中（所谓的匈牙利命名法）是脑损伤的表现 - 编译器知道类型，能够对它进行检查，这种命名法只会把程序员自己搞晕。难怪微软做了那么多充满bug的程序。哈哈^_^，有道理，不要作茧自缚。局部_变量应该短小扼要。如果你有个随机的整数循环变量，可能最好叫它“i”。把它叫做“loop_counter” 是效率低下的，在不会发生混淆的情况下。类型地，“tmp”可以被用于任何类型的存储临时值的变量。如果你担心混淆你的局部变量，那么你就会有另一个问 题，所谓的函数膨胀荷尔蒙失衡综合症，请看下一章。

第四章：函数

函数应该短小而甜美，而且只能做一件事。他们应该只用一两屏幕（我们都知道，ISO／ANSI标准屏幕大小是80x24）就能装下，只做并且做好一件事。

函数的最大长度应该与函数的复杂性和缩进层次成反比。所以，如果你有个只有一个很长（但很简单）的case语句的函数，对许多case做一些很少的操作，那么这个函数长点也没有关系。

但是，如果你有一个复杂的函数，你担心一个中等智力的高一学生可能无法理解，那么你应该更严格地遵守最大长度限制。使用有描述性名字的帮助函数（你可以让编译器in-line这些帮助函数，如果你认为性能很重要的话，而且编译器恐怕会比你做的要好）。

函数的另一个指标是局部变量的数目，局部变量的数目不应超过5-10个，否则一定是哪里有问题了。再设计一下这个函数，把它分解得更小一些。人的大脑一般可以同时跟踪7个不同的东西，超过了7个就会晕菜。虽然你很聪明，不过可能你有时会想理解一下两星期前所写的代码。

第五章：注释

注释是好东西，不过存在过分注释的危险。_永远_不要在注释中解释你的代码是如何工作的：更好的做法是写出工作方式显而易见的代码，解释糟糕的代码是浪费时间。

一般来说，注释应该说明代码在做什么，而不是怎么做。并且，不要把注释加在函数主体 中：如果函数太复杂以至于必须对各个部分进行注释，那么你可能要再去读读第四章。你可以加入一些短小的注释来提醒或警告一些聪明（或难看）的做法，但不要太过度。更好的选择是，把注释放在函数头，说明函数在做什么，可能还包括它为什么做。

第六章：你的代码乱七八糟

没什么，我们都遇到过。你可能从老Unix用户那里听说过“GNU emacs”会自动对齐C源代码，但缺省的设置不是很好（事实上，缺省设置比胡乱敲打还糟糕 -一群使用GNU emacs猴子永远不会做出漂亮的程序）。靠！我就是用emacs的！不过现在自动对齐还算可以了。

所以，你或者彻底仍掉GNU emacs，或者采用更理智的设置。如果选择后者，你可一把下面的代码加到你的.emacs文件中：

(defun Linux-c-mode ()

　　"C mode with adjusted defaults for use with the Linux kernel."

　　(interactive)

　　(c-mode)

　　(c-set-style "K&R")

　　(setq c-basic-offset 8))

　　

这会定义 M-x linux-c-mode 命令。当编写Linux模块时，如果你把字符串“-*-linux-c -*-”放在文件的头两行中，这个模式就会被自动激活。还有，如果你想在编辑/usr/src/linux目录下的源文件时linux-c-mode被自 动激活，你在你的.emacs文件中需要加入:

　

　　(setq auto-mode-alist (cons '

("/usr/src/linux.*/.*\\.[ch]$" . linux-c-mode)

　　auto-mode-alist))

　　

但是即使你用不了emacs，并不是世界末日：你还可以使用“indent”。又一次，GNU indent使用了和GNU emacs一样的脑死亡设置，所以你需要给它一些命令行选项。但是，这不算太坏，因为即使是GNU indent的作者们也意识到了K&R的权威性（GNU的人也不是魔鬼，他们只是在这件事上被误导了），所以你可以使用选项“-kr -i8”（表示“K&R，8字符缩进”）运行indent。“indent”有很多选项，特别是注释布局部分，你可能想看看它的man手册。但是 请记住：“indent”不能修改糟糕的程序。个人觉得现在emacs对缩进对齐的处理已经不错了，问题在于你使用不同的Linux发行版，就会面对不同的.emacs文件，有时候我不得不随身携带我的.emacs文件，或者把它放在我的email的存储箱里面

第七章：配置文件

配置选项 (arch/xxx/config.in，以及所有Config.in文件）使用了有些不同的缩进方式。

代码中使用的是3字符缩进，config-选项中应该使用2字符缩进标识依赖关系。后者只应用于bool/tristat选项。对于其他选项，采用你认为最合适的缩进方式就可以了。例如：

if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then

　　tristate 'Apply nitroglycerine inside the keyboard

(DANGEROUS)' CONFIG_BOOM

　　if [ "$CONFIG_BOOM" != "n" ]; then

　　bool ' Output nice messages when you explode' CONFIG_CHEER

　　fi

　　fi

一般来说，所有不稳定的选项应该标为CONFIG_EXPERIMENTAL。所有可能损坏数据的的选项应该标为(DANGEROUS)，其他的试验选项应该标为(EXPERIMENTAL)。

第八章：数据结构

供多线程使用的数据结构应该采用引用计数（reference counts）。在内核中，垃圾回收（garbage collection）是不存在的（内核之外的垃圾回收效率不高），这意味着你_必须_使用引用计数。

引用计数的使用能避免锁的使用，使不同的用户能够并行使用数据结构 - 不需要担心结构会因为睡眠而突然消失。 
