Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2012-01-06T16:12:44+08:00

====== IPython reference ======
Created Friday 06 January 2012
http://ipython.org/ipython-doc/rel-0.12/interactive/reference.html


===== Command-line usage =====
You start IPython with the command:
**$ ipython [options] files**

Note
For IPython on Python 3, use ipython3 in place of ipython.

If invoked with no options, it executes all the files listed in sequence and __drops you into the interpreter __while still acknowledging any options you may have set in your __ipython_config.py__. This behavior is different from standard Python, which when called as python -i will only execute one file and ignore your configuration setup.

Please note that some of the configuration options are not available at the command line, simply because they are not practical here. Look into your configuration files for details on those. There are **separate** configuration files for each profile, and the files look like __“ipython_config.py” or “ipython_config_<frontendname>.py”__. Profile directories look like “profile_profilename” and are typically installed in the IPYTHON_DIR directory. For Linux users, this will be $HOME/.config/ipython, and for other users it will be $HOME/.ipython. For Windows users, $HOME resolves to C:\Documents and Settings\YourUserName in most instances.

===== Eventloop integration =====
Previously IPython had command line options for controlling GUI event loop integration (-gthread, -qthread, -q4thread, -wthread, -pylab). As of IPython version 0.11, these have been removed. Please see the new %gui magic command or this section for details on the new interface, or specify the gui at the commandline:

$ ipython --gui=qt

===== Command-line Options =====
To see the options IPython accepts, use ipython --help (and you probably should run the output through a pager such as ipython --help | less for more convenient reading). This shows all the options that have a __single-word alias__ to control them, but IPython lets you configure all of its objects from the command-line by passing the __full class name and a corresponding value__; type ipython --help-all to see this full list. For example:

ipython --pylab qt   #single-word形式

is equivalent to:

ipython --TerminalIPythonApp.pylab='qt' #full class name and a corresponding value形式。

Note that in the second form, you must use the __equal sign__, as the expression is evaluated as __an actual Python assignment.__ While in the above example the short form is more convenient, only the most common options have a short form, while any configurable variable in IPython can be set at the command-line by using the long form. This long form is the **same syntax used in the configuration files**, if you want to set these options permanently.

===== Interactive use =====
IPython is meant to work as a __drop-in replacement__ for the standard interactive interpreter. As such, any code which is valid python should execute normally under IPython (cases where this is not true should be reported as bugs). It does, however, offer many features which are not available at a standard python prompt. What follows is a list of these.

* **Magic command system**
IPython will treat any line whose** first character** is a % as a special call to a__ ‘magic’ function__. These allow you to control the behavior of IPython itself, plus a lot of system-type features. They are all prefixed with a % character, but **parameters are given without parentheses or quotes**.

Example: typing %cd mydir            changes your working directory to ‘mydir’, if it exists.

If you have __‘automagic’ __enabled (as it by default), you __don’t need to__ type in the % explicitly. IPython will scan its **internal list of magic functions** and call one if it exists. With automagic on you can then just type **cd mydir** to go to directory ‘mydir’. The automagic system has the __lowest possible precedence__ in name searches, so defining an identifier with the same name as an existing magic function will __shadow__ it for automagic use. You can still access the shadowed magic function by explicitly using the % character at the beginning of the line.

An example (with automagic on) should clarify all this:

In [1]: cd ipython     # %cd is called by automagic
/home/fperez/ipython

In [2]: cd=1           # now cd is just a variable

In [3]: cd ..          # and __doesn't work as a function anymore__
File "<ipython-input-3-9fedb3aff56c>", line 1
  cd ..
      ^
SyntaxError: invalid syntax

In [4]: %cd ..         # __but %cd always works__
/home/fperez

In [5]: **del cd **    # if you remove the cd variable, automagic works again

In [6]: cd ipython

/home/fperez/ipython

You can __define your own magic functions__ to extend the system. The following example defines a new magic command, %impall:

ip = get_ipython()

def doimp(self, arg):
    ip = self.api
    ip.ex("import %s; reload(%s); from %s import *" % (arg,arg,arg) )

ip.define_magic('impall', doimp)

Type __%magic__ for more information, including a list of all available magic functions at any time and their docstrings. You can also type %magic_function_name? (see below for information on the ‘?’ system) to get information about any particular magic function you are interested in.
The API documentation for the** IPython.core.magic** module contains the full docstrings of all currently available magic commands.

**• Access to the standard Python help**
Simply type __help()__ to access Python’s standard help system. You can alclso type __help(object)__ for information about **a given object**, or __help('keyword')__ for information on a keyword. You may need to configure your PYTHONDOCS environment variable for this feature to work correctly.

* **Dynamic object information**
Typing __?word__ or __word?__ prints detailed information about an object. If certain strings in the object are too long (e.g. function signatures) they get snipped in the center for brevity. This system gives access variable** types and values, docstrings, function prototypes** and other useful information.
If the information will not fit in the terminal, it is displayed in a__ pager__ (less if available, otherwise a basic internal pager).
Typing __??word or word??__ gives access to the full information, including the source code where possible. Long strings are not snipped.

The following magic functions are particularly useful for** gathering information** about your working environment. You can get more details by typing **%magic** or querying them individually (__%function_name?__); this is just a summary:

* %pdoc <object>: Print (or run through a pager if too long) the__ docstring__ for an object. If the given object is a class, it will print both the class and the constructor docstrings.
* %pdef <object>: Print the definition header for any** callable object**. If the object is a class, print the constructor information.
* %psource <object>: Print (or run through a pager if too long) the source code for an object.
* %pfile <object>: Show the **entire source file** where an object was defined via a pager, opening it at the line where the object definition begins.
* __%who/%whos:__ These functions give information about** identifiers** you have defined interactively (not things you loaded or defined in your configuration files). %who just prints a list of identifiers and %whos prints a table with some basic details about each identifier.

Note that the dynamic object information functions (__?/??, %pdoc, %pfile, %pdef, %psource__) work on object attributes, as well as directly __on variables__. For example, after doing import os, you can use __os.path.abspath??__.

* **Readline-based features**
These features require the **GNU readline library,** so they won’t work if your Python installation lacks readline support. We will first describe the default behavior IPython uses, and then how to change it to suit your preferences.

**Command line completion**
__At any time__, hitting TAB will complete any available python commands or variable names, and show you a list of the possible completions if there’s no unambiguous one. It will also complete** filenames** in the current directory if no python names match what you’ve typed so far.

**Search command history**
IPython provides two ways for searching through previous input and thus reduce the need for repetitive typing:

* Start typing, and then use **Ctrl-p (previous,up) and Ctrl-n** (next,down) to search through only the history items that match what you’ve typed so far. If you use Ctrl-p/Ctrl-n at a blank prompt, they just behave like normal arrow keys.
* Hit **Ctrl-r**: opens __a search prompt__. Begin typing and the system searches your history for lines that contain what you’ve typed so far, completing as much as it can.

**Persistent command history across sessions**
IPython will save your__ input history__ when it leaves and reload it next time you restart it. By default, the history file is named $IPYTHON_DIR/profile_<name>/**history.sqlite**. This allows you to keep separate histories related to various tasks: commands related to numerical work will not be clobbered by a system shell history, for example.

**Autoindent**
IPython can recognize lines __ending in ‘:’ __and indent the next line, while also un-indenting automatically after ‘raise’ or ‘return’.

This feature uses the readline library, so it will honor your ~/.inputrc configuration (or whatever file your INPUTRC variable points to). Adding the following lines to your .inputrc file can make indenting/unindenting more convenient (M-i indents, M-u unindents):

$if Python
"\M-i": "    "
"\M-u": "\d\d\d\d"
$endif

Note that there are __4 spaces__ between the quote marks after “M-i” above.


Warning
__Autoindent is ON__ by default, but it can cause problems with the pasting of **multi-line indented code** (the pasted code gets re-indented on each line). A magic function %autoindent allows you to toggle it on/off at runtime. You can also disable it permanently on in your ipython_config.py file (set TerminalInteractiveShell.autoindent=False).

If you want to paste multiple lines in the terminal, it is recommended that you use __%paste__.

**Customizing readline behavior**
All these features are based on the GNU readline library, which has an extremely customizable interface. Normally, readline is configured via a file which defines the behavior of the library; the details of the syntax for this can be found in the **readline documentation **available with your system or on the Internet. IPython **doesn’t read this file** (if it exists) directly, but it does support passing to readline valid options via a simple interface. In brief, you can customize readline by setting the following options in your configuration file (note that these options can not be specified at the command line):

* readline_parse_and_bind: this holds a list of strings to be executed via a readline.parse_and_bind() command. The syntax for valid commands of this kind can be found by reading the documentation for the GNU readline library, as these commands are of the kind which readline accepts in its configuration file.
* readline_remove_delims: a string of characters to be removed from the default word-delimiters list used by readline, so that completions may be performed on strings which contain them. Do not change the default value unless you know what you’re doing.

* **Session logging and restoring**
You can__ log all input__ from a session either by starting IPython with the command line switch **--logfile=foo.py** (see here) or by activating the logging at any moment with the magic function __%logstart__.

Log files **can later be reloaded** by __running them as scripts__ and IPython will attempt to ‘replay’ the log by executing all the lines in it, thus restoring the state of a previous session. This feature is not quite perfect, but can still be useful in many cases.

The log files can also be used as a way to have **a permanent record** of any code you wrote while experimenting. Log files are regular text files which you can later open in your favorite text editor to extract code or to ‘clean them up’ before using them to replay a session.

The __%logstart__ function for activating logging in mid-session is used as follows:

//%logstart [log_name [log_mode]]//

If no name is given, it defaults to a file named ‘**ipython_log.py**’ in your current working directory, in** ‘rotate’** mode (see below).
‘%logstart name’ saves to file ‘name’ in__ ‘backup’__ mode. It saves your history up to that point and then continues logging.
%logstart takes a second optional parameter: logging mode. This can be one of (note that the modes are given unquoted):

* [over:] overwrite existing log_name.
* [backup:] rename (if exists) to log_name~ and start log_name.
* [append:] well, that says it.
* [rotate:] create rotating logs log_name.1~, log_name.2~, etc.

The __%logoff and %logon __functions allow you to temporarily stop and resume logging to a file which had previously been started with %logstart. They will fail (with an explanation) if you try to use them before logging has been started.

* **System shell access**
Any input line __beginning with a ! character__ is passed** verbatim **(minus the !, of course) to the underlying operating system. For example, typing !ls will run ‘ls’ in the current directory.

* **Manual capture of command output**
You can __assign the result of a system command to a Python variable __with the syntax **myfiles = !ls**. This gets machine readable output from stdout (e.g. without colours), and **splits on newlines**. 

To explicitly get this sort of output **without assigning to a variable**, use two exclamation marks__ (!!ls) or the %sx __magic command.
系统命令的输出**按行被保存到列表变量中**。

The captured list has some convenience features.__ myfiles.n or myfiles.s __returns a string delimited by **newlines or spaces, respectively**. __myfiles.p__ produces path objects from the list items. See String lists for details.

IPython also allows you to__ expand the value of python variables__ when making system calls. Wrap __variables or expressions in {braces}__:

In [1]: pyvar = 'Hello world'
In [2]: !echo "A python variable: {pyvar}"
A python variable: Hello world
In [3]: import math
In [4]: x = 8
In [5]: !echo {math.factorial(x)}
40320

For simple cases, you can alternatively prepend__ $ to a variable name__:

In [6]: !echo $sys.argv
[/home/fperez/usr/bin/ipython]
In [7]: !echo "A system variable: $$HOME"  # __Use $$ for literal $__
A system variable: /home/fperez

===== System command aliases =====
The__ %alias __magic function allows you to define magic functions which are in fact** system shell commands**. These aliases can have** parameters**.

__%alias alias_name cmd      #defines ‘alias_name’ as an alias for ‘cmd’__

Then, typing **alias_name **params will execute the system command ‘cmd params’ (from your underlying operating system).
直接输入alias_name就会执行system shell命令。

You can also__ define aliases with parameters using %s specifiers__ (one per parameter). The following example defines the parts function as an alias to the command ‘echo first %s second %s’ where each %s will be replaced **by a positional parameter **to the call to %parts:

In [1]: %alias parts echo first %s second %s
In [2]: parts A B
first A second B
In [3]: parts A
ERROR: Alias <parts> requires 2 arguments, 1 given.

If called with no parameters, __%alias __prints the table of currently defined aliases.

The __%rehashx __magic allows you to load your entire $PATH as ipython aliases. See its docstring for further details.
也就是说将$PATH下的所有可执行命令都建立相应的别名，这样在ipython中可以直接调用它们。

===== Recursive reload =====
The** IPython.lib.deepreload** module allows you to__ recursively reload a module__: changes made to any of its dependencies will be reloaded without having to exit. To start using it, do:

**from IPython.lib.deepreload import reload as dreload**
#然后使用 
dreload(module-name)
即可递归地重载module-name及其依赖的模块。

===== Verbose and colored exception traceback printouts =====
IPython provides the option to see** very detailed exception tracebacks**, which can be especially useful when debugging large programs. You can run any Python file with the __%run__ function to benefit from these detailed tracebacks. Furthermore, both normal and verbose tracebacks can be** colored** (if your terminal supports it) which makes them much easier to parse visually.

See the magic __xmode__ and __colors__ functions for details (just type** %magic**).

These features are basically a terminal version of Ka-Ping Yee’s cgitb module, now part of the standard Python library.

===== Input caching system =====
IPython offers __numbered prompts __(In/Out) with input and output caching (also referred to as** ‘input history’**). All input is saved and can be__ retrieved as variables__ (besides the usual arrow key recall), in addition to the __%rep __magic command that brings a history entry up for editing on the next command line.

The following** GLOBAL** variables always exist (so don’t overwrite them!):

* ___i, _ii, _iii__: store previous, next previous and next-next previous inputs.
* __In, _ih__ : a list of all inputs; _ih[n] is the input from line n. If you overwrite In with a variable of your own, you can remake the assignment to the internal list with a simple In=_ih.

Additionally, global variables named ___i<n> __are dynamically created (<n> being the prompt counter), so _i<n> == _ih[<n>] == In[<n>].

For example, what you typed at prompt 14 is available as ___i14, _ih[14] and In[14]__.

This allows you to easily** cut and paste multi line interactive prompts by printing them out**: they print like a **clean string**, without prompt characters. You can also manipulate them like** regular variables** (they are strings), modify or exec them (typing __exec _i9 __will re-execute the contents of input prompt 9.

You can also **re-execute** multiple lines of input easily by using the magic __%rerun or %macro__ functions. The macro system also allows you to re-execute previous lines which include magic function calls (which require special processing). Type %macro? for more details on the macro system.

A history function__ %hist __allows you to see any part of your input history by printing a range of the _i variables.

You can also search (‘grep’) through your history by typing __%hist -g__ somestring. This is handy for searching for URLs, IP addresses, etc. You can bring history entries listed by ‘%hist -g’ up for editing with the__ %recall __command, or run them immediately with __%rerun__.

===== Output caching system =====
For output that is returned from actions, a system similar to the input cache exists but using _____ instead of _i. __Only actions that produce a result (NOT assignments, for example) are cached__. If you are familiar with Mathematica, IPython’s _ variables behave exactly like Mathematica’s % variables.

The following GLOBAL variables always exist (so don’t overwrite them!):

* [_] (a single underscore) : stores previous output, like Python’s default interpreter.
* [__] (two underscores): next previous.
* [___] (three underscores): next-next previous.

Additionally, global variables named ___<n>__ are dynamically created (<n> being the prompt counter), such that the result of **output <n>** is always available as _<n> (don’t use the angle brackets, just the number, e.g.__ _21__).

These variables are also stored in a global dictionary (not a list, since it only has entries for lines which returned a result) available under the names__ _oh__ and __Out__ (similar to _ih and In). So the output from line 12 can be obtained as__ _12, Out[12] or _oh[12]__. If you accidentally overwrite the Out variable you can recover it by typing ‘Out=_oh’ at the prompt.

This system obviously can potentially put **heavy memory demands** on your system, since it prevents Python’s garbage collector from removing any previously computed results. You can control how many results are kept in memory with the option (at the command line or in your configuration file) __cache_size__. If you set it to 0, the whole system is completely disabled and the prompts revert to the classic ‘**>>>**’ of normal Python.

===== Directory history =====
Your history of visited directories is kept in the global list ___dh__, and the magic** %cd** command can be used to go to any entry in that list. The **%dhist** command allows you to view this history. Do cd -<TAB> to conveniently view the directory history.

===== Automatic parentheses and quotes =====
These features were adapted from Nathan Gray’s LazyPython. They are meant to allow less typing for common situations.

=== Automatic parentheses ===
**Callable objects** (i.e. functions, methods, etc) can be invoked like this (notice the **commas** between the arguments):

In [1]: __callable_ob arg1, arg2, arg3__
------> callable_ob(arg1, arg2, arg3)

You can force automatic parentheses by using ‘/’ as the first character of a line. For example:

In [2]: /globals # becomes 'globals()'

Note that the ‘/’ MUST be the first character on the line! This won’t work:

In [3]: print /globals # syntax error

In most cases the automatic algorithm should work, so you should rarely need to explicitly invoke /. One notable exception is if you are trying to call a function **with a list of tuples as arguments** (the parenthesis will confuse IPython):

In [4]: zip (1,2,3),(4,5,6) # won't work

but this will work:

In [5]:__ /zip __(1,2,3),(4,5,6)
------> zip ((1,2,3),(4,5,6))
Out[5]: [(1, 4), (2, 5), (3, 6)]

IPython tells you that it has altered your command line by displaying the new command line preceded by ->. e.g.:

In [6]: callable list
------> callable(list)

===== Automatic quoting =====
You can force automatic quoting of a function’s arguments by using__ ‘,’ or ‘;’ __as the** first character of a line**. For example:

In [1]: ,my_function /home/me  # becomes** my_function("/home/me")**

If you use ‘;’ __the whole argument is quoted as a single string, while ‘,’ splits on whitespace__:

In [2]: ,my_function a b c    # becomes my_function("a","b","c")
In [3]: ;my_function a b c    # becomes my_function("a b c")

Note that the ‘,’ or ‘;’ MUST be the first character on the line! This won’t work:

In [4]: x = ,my_function /home/me # syntax error

===== IPython as your default Python environment =====
Python honors the environment variable **PYTHONSTARTUP** and will execute at startup the file referenced by this variable. If you put the following code at the end of that file, then IPython will be your __working environment__ anytime you start Python:

from IPython.frontend.terminal.ipapp import launch_new_instance
launch_new_instance()
raise SystemExit

The raise SystemExit is needed to exit Python when it finishes, otherwise you’ll be back at the normal Python ‘>>>’ prompt.

This is probably useful to developers who manage multiple Python versions and don’t want to have correspondingly multiple IPython versions. Note that in this mode,** there is no way to pass IPython any command-line options**, as those are trapped first by Python itself.

===== Embedding IPython =====
It is possible to start an IPython instance **inside your own Python programs**. This allows you to evaluate dynamically the state of your code, operate with your variables, analyze them, etc. Note however that __any changes you make to values while in the shell do not propagate back to the running code__, so it is safe to modify your values because you won’t break your code in bizarre ways by doing so.

Note
At present, trying to embed IPython from inside IPython causes problems. Run the code samples below **outside** IPython.

This feature allows you to easily have a fully functional python environment for doing __object introspection__ anywhere in your code with a simple function call. In some cases a simple print statement is enough, but if you need to do more detailed analysis of a code fragment this feature can be very valuable.

It can also be useful in scientific computing situations where it is common to need to do some automatic, computationally intensive part and then stop to look at data, plots, etc. Opening an IPython instance will give you **full access to your data and functions**, and you can resume program execution once you are done with the interactive part (perhaps to stop again later, as many times as needed).

The following code snippet is the bare minimum you need to include in your Python programs for this to work (detailed examples follow later):

**from IPython import embed**
**embed() # this call anywhere in your program will start IPython**

You can run embedded instances even in code which is itself being run at the IPython interactive prompt with ‘__%run <filename>__’. Since it’s easy to get lost as to where you are (in your top-level IPython or in your embedded one), it’s a good idea in such cases to __set the in/out prompts to something different __for the embedded instances. The code examples below illustrate this.

You can also have multiple IPython instances in your program and open them separately, for example with different options for data presentation. If you close and open the same instance multiple times, its prompt counters simply continue from each execution to the next.

Please look at the docstrings in the __embed__ module for more details on the use of this system.

The following sample file illustrating how to use the embedding functionality is provided in the examples directory as** example-embed.py**. It should be fairly self-explanatory:

#!/usr/bin/env python

"""An example of how to embed an IPython shell into a running program.

Please see the documentation in the__ IPython.Shell__ module for more details.

The accompanying file **example-embed-short.py **has quick code fragments for
embedding which you can cut and paste in your code once you understand how
things work.

The code in this file is deliberately extra-verbose, meant for learning."""

# The basics to get you going:

# IPython sets the __IPYTHON__ variable so you can know if you have nested
# copies running.

# Try running this code both at the command line and from inside IPython (with
# %run example-embed.py)
from IPython.config.loader import Config
try:
    **get_ipython**
except NameError:
    nested = 0
    cfg = Config()
    prompt_config = cfg.PromptManager
    prompt_config.in_template = 'In <\\#>: '
    prompt_config.in2_template = '   .\\D.: '
    prompt_config.out_template = 'Out<\\#>: '
else:
    print "Running nested copies of IPython."
    print "The prompts for the nested copy have been modified"
    cfg = Config()
    nested = 1

# First import the embeddable shell class
from IPython.frontend.terminal.embed import InteractiveShellEmbed

# Now create an instance of the embeddable shell. The first argument is a
# string with options exactly as you would type them if you were starting
# IPython at the system command line. Any parameters you want to define for
# configuration can thus be specified here.
ipshell = InteractiveShellEmbed(config=cfg,
                       banner1 = 'Dropping into IPython',
                       exit_msg = 'Leaving Interpreter, back to program.')

# Make a second instance, you can have as many as you want.
cfg2 = cfg.copy()
prompt_config = cfg2.PromptManager
prompt_config.in_template = 'In2<\\#>: '
if not nested:
    prompt_config.in_template = 'In2<\\#>: '
    prompt_config.in2_template = '   .\\D.: '
    prompt_config.out_template = 'Out<\\#>: '
ipshell2 = InteractiveShellEmbed(config=cfg,
                        banner1 = 'Second IPython instance.')

print '\nHello. This is printed from the main controller program.\n'

# You can then call ipshell() anywhere you need it (with an optional
# message):
ipshell('***Called from top level. '
        'Hit Ctrl-D to exit interpreter and continue program.\n'
        'Note that if you use %kill_embedded, you can fully deactivate\n'
        'This embedded instance so it will never turn on again')

print '\nBack in caller program, moving along...\n'

#---------------------------------------------------------------------------
# More details:

# InteractiveShellEmbed instances don't print the standard system banner and
# messages. The IPython banner (which actually may contain initialization
# messages) is available as get_ipython().banner in case you want it.

# InteractiveShellEmbed instances print the following information everytime they
# start:

# - A global startup banner.

# - A call-specific header string, which you can use to indicate where in the
# execution flow the shell is starting.

# They also print an exit message every time they exit.

# Both the startup banner and the exit message default to None, and can be set
# either at the instance constructor or at any other time with the
# by setting the banner and exit_msg attributes.

# The shell instance can be also put in 'dummy' mode globally or on a per-call
# basis. This gives you fine control for debugging without having to change
# code all over the place.

# The code below illustrates all this.


# This is how the global banner and exit_msg can be reset at any point
ipshell.banner = 'Entering interpreter - New Banner'
ipshell.exit_msg = 'Leaving interpreter - New exit_msg'

def foo(m):
    s = 'spam'
    ipshell('***In foo(). Try %whos, or print s or m:')
    print 'foo says m = ',m

def bar(n):
    s = 'eggs'
    ipshell('***In bar(). Try %whos, or print s or n:')
    print 'bar says n = ',n
    
# Some calls to the above functions which will trigger IPython:
print 'Main program calling foo("eggs")\n'
foo('eggs')

# The shell can be put in 'dummy' mode where calls to it silently return. This
# allows you, for example, to globally turn off debugging for a program with a
# single call.
ipshell.dummy_mode = True
print '\nTrying to call IPython which is now "dummy":'
ipshell()
print 'Nothing happened...'
# The global 'dummy' mode can still be overridden for a single call
print '\nOverriding dummy mode manually:'
ipshell(dummy=False)

# Reactivate the IPython shell
ipshell.dummy_mode = False

print 'You can even have multiple embedded instances:'
ipshell2()

print '\nMain program calling bar("spam")\n'
bar('spam')

print 'Main program finished. Bye!'

#********************** End of file <example-embed.py> ***********************

Once you understand how the system functions, you can use the following code fragments in your programs which are ready for cut and paste:

"""Quick code snippets for embedding IPython into other programs.

See example-embed.py for full details, this file has the bare minimum code for
cut and paste use once you understand how to use the system."""

#---------------------------------------------------------------------------
# This code loads IPython but modifies a few things if it detects it's running
# embedded in another IPython session (helps avoid confusion)

try:
    get_ipython
except NameError:
    banner=exit_msg=''
else:
    banner = '*** Nested interpreter ***'
    exit_msg = '*** Back in main IPython ***'

# First import the embed function
from IPython.frontend.terminal.embed import InteractiveShellEmbed
# Now create the IPython shell instance. Put ipshell() anywhere in your code
# where you want it to open.
ipshell = InteractiveShellEmbed(banner1=banner, exit_msg=exit_msg)
                            
#---------------------------------------------------------------------------
# This code will load an embeddable IPython shell always with no changes for
# nested embededings.

from IPython import embed
# Now embed() will open IPython anywhere in the code.

#---------------------------------------------------------------------------
# This code loads an embeddable shell only if NOT running inside
# IPython. Inside IPython, the embeddable shell variable ipshell is just a
# dummy function.

try:
    get_ipython
except NameError:
    from IPython.frontend.terminal.embed import InteractiveShellEmbed
    ipshell = InteractiveShellEmbed()
    # Now ipshell() will open IPython anywhere in the code
else:
    # Define a dummy ipshell() so the same code doesn't crash inside an
    # interactive IPython
    def ipshell(): pass

#******************* End of file <example-embed-short.py> ********************

===== Using the Python debugger (pdb) =====

==== Running entire programs via pdb ====
pdb, the Python debugger, is a powerful __interactive debugger __which allows you to step through code, set breakpoints, watch variables, etc. IPython makes it very easy to start any script under the control of pdb, regardless of whether you have wrapped it into a ‘main()’ function or not. For this, simply type __‘%run -d myscript’__ at an IPython prompt. See the %run command’s documentation (via ‘%run?’ or in Sec. magic for more details, including how to control where pdb will stop execution first.

For more information on the use of the pdb debugger, read the included __pdb.doc__ file (part of the standard Python distribution). On a stock Linux system it is located at /usr/lib/python2.3/pdb.doc, but the easiest way to read it is by using the help() function of the pdb module as follows (in an IPython prompt):

In [1]: import pdb
In [2]: **pdb.help()**

This will load the pdb.doc document in a file viewer for you automatically.

==== Automatic invocation of pdb on exceptions ====
IPython, if __started with the --pdb option__ (or if the option is set in your config file) can** call the Python pdb debugger every time your code triggers an uncaught exception.** This feature can also be toggled at any time with the__ %pdb __magic command. This can be extremely useful in order to find the origin of subtle bugs, because pdb opens up at the point in your code which triggered the exception, and while your program is at this point ‘dead’, all **the data is still available** and you can walk up and down the stack frame and understand the origin of the problem.

Furthermore, you can use these debugging facilities both __with the embedded IPython mode and without IPython at all__. For an embedded shell (see sec. Embedding), simply call the constructor with** --pdb** in the argument string and pdb will automatically be called if an uncaught exception is triggered by your code.

For stand-alone use of the feature in your programs which **do not use IPython at all**, put the following lines toward the top of your ‘main’ routine:

**import sys**
**from IPython.core import ultratb**
**sys.excepthook = ultratb.FormattedTB(mode='Verbose', color_scheme='Linux', call_pdb=1)**

The __mode__ keyword can be either ‘Verbose’ or ‘Plain’, giving either very detailed or normal tracebacks respectively. The color_scheme keyword can be one of ‘NoColor’, ‘Linux’ (default) or ‘LightBG’. These are the same options which can be set in IPython with --colors and --xmode.

This will give any of your programs detailed, colored tracebacks with automatic invocation of pdb.

===== Extensions for syntax processing =====
This isn’t for the faint of heart, because the potential for breaking things is quite high. But it can be a very powerful and useful feature. In a nutshell, you can **redefine the way IPython processes the user input line to accept new, special extensions to the syntax without needing to change any of IPython’s own code.**

In the IPython/extensions directory you will find some examples supplied, which we will briefly describe now. These can be used ‘__as is’ __(and both provide very useful functionality), or you can use them as a starting point for writing your own extensions.

=== Pasting of code starting with Python or IPython prompts ===
IPython is smart enough to** filter out input prompts**, be they plain Python ones (>>> and ...) or IPython ones (In [N]: and `` ...:``). You can therefore copy and **paste from existing interactive sessions without worry**.

The following is a ‘screenshot’ of how things work, copying an example from the standard Python tutorial:

In [1]: >>> # Fibonacci series:
In [2]: ... # the sum of two elements defines the next
In [3]: ... a, b = 0, 1
In [4]: >>> while b < 10:
   ...:     ...     print b
   ...:     ...     a, b = b, a+b
   ...:
1
1
2
3
5
8

And pasting from IPython sessions works equally well:

In [1]: In [5]: def f(x):
   ...:        ...:     "A simple function"
   ...:        ...:     return x**2
   ...:    ...:

In [2]: f(3)
Out[2]: 9

GUI event loop support

New in version 0.11: The %gui magic and IPython.lib.inputhook.

IPython has excellent support for working interactively with Graphical User Interface (GUI) toolkits, such as wxPython, PyQt4/PySide, PyGTK and Tk. This is implemented using Python’s builtin PyOSInputHook hook. This implementation is extremely robust compared to our previous thread-based version. The advantages of this are:

    GUIs can be enabled and disabled dynamically at runtime.
    The active GUI can be switched dynamically at runtime.
    In some cases, multiple GUIs can run simultaneously with no problems.
    There is a developer API in IPython.lib.inputhook for customizing all of these things.

For users, enabling GUI event loop integration is simple. You simple use the %gui magic as follows:

%gui [GUINAME]

With no arguments, %gui removes all GUI support. Valid GUINAME arguments are wx, qt, gtk and tk.

Thus, to use wxPython interactively and create a running wx.App object, do:

%gui wx

For information on IPython’s Matplotlib integration (and the pylab mode) see this section.

For developers that want to use IPython’s GUI event loop integration in the form of a library, these capabilities are exposed in library form in the IPython.lib.inputhook and IPython.lib.guisupport modules. Interested developers should see the module docstrings for more information, but there are a few points that should be mentioned here.

First, the PyOSInputHook approach only works in command line settings where readline is activated. The integration with various eventloops is handled somewhat differently (and more simply) when using the standalone kernel, as in the qtconsole and notebook.

Second, when using the PyOSInputHook approach, a GUI application should not start its event loop. Instead all of this is handled by the PyOSInputHook. This means that applications that are meant to be used both in IPython and as standalone apps need to have special code to detects how the application is being run. We highly recommend using IPython’s support for this. Since the details vary slightly between toolkits, we point you to the various examples in our source directory docs/examples/lib that demonstrate these capabilities.

Warning

The WX version of this is currently broken. While --pylab=wx works fine, standalone WX apps do not. See https://github.com/ipython/ipython/issues/645 for details of our progress on this issue.

Third, unlike previous versions of IPython, we no longer “hijack” (replace them with no-ops) the event loops. This is done to allow applications that actually need to run the real event loops to do so. This is often needed to process pending events at critical points.

Finally, we also have a number of examples in our source directory docs/examples/lib that demonstrate these capabilities.
PyQt and PySide

When you use --gui=qt or --pylab=qt, IPython can work with either PyQt4 or PySide. There are three options for configuration here, because PyQt4 has two APIs for QString and QVariant - v1, which is the default on Python 2, and the more natural v2, which is the only API supported by PySide. v2 is also the default for PyQt4 on Python 3. IPython’s code for the QtConsole uses v2, but you can still use any interface in your code, since the Qt frontend is in a different process.

The default will be to import PyQt4 without configuration of the APIs, thus matching what most applications would expect. It will fall back of PySide if PyQt4 is unavailable.

If specified, IPython will respect the environment variable QT_API used by ETS. ETS 4.0 also works with both PyQt4 and PySide, but it requires PyQt4 to use its v2 API. So if QT_API=pyside PySide will be used, and if QT_API=pyqt then PyQt4 will be used with the v2 API for QString and QVariant, so ETS codes like MayaVi will also work with IPython.

If you launch IPython in pylab mode with ipython --pylab=qt, then IPython will ask matplotlib which Qt library to use (only if QT_API is not set), via the ‘backend.qt4’ rcParam. If matplotlib is version 1.0.1 or older, then IPython will always use PyQt4 without setting the v2 APIs, since neither v2 PyQt nor PySide work.

Warning

Note that this means for ETS 4 to work with PyQt4, QT_API must be set to work with IPython’s qt integration, because otherwise PyQt4 will be loaded in an incompatible mode.

It also means that you must not have QT_API set if you want to use --gui=qt with code that requires PyQt4 API v1.
Plotting with matplotlib

Matplotlib provides high quality 2D and 3D plotting for Python. Matplotlib can produce plots on screen using a variety of GUI toolkits, including Tk, PyGTK, PyQt4 and wxPython. It also provides a number of commands useful for scientific computing, all with a syntax compatible with that of the popular Matlab program.

To start IPython with matplotlib support, use the --pylab switch. If no arguments are given, IPython will automatically detect your choice of matplotlib backend. You can also request a specific backend with --pylab=backend, where backend must be one of: ‘tk’, ‘qt’, ‘wx’, ‘gtk’, ‘osx’.

===== Interactive demos with IPython =====
IPython ships with a basic system for running scripts interactively in sections,__ useful when presenting code to audiences__. A few tags embedded in comments (so that the script remains valid Python code) divide a file into **separate blocks**, and the demo can be run one block at a time, with IPython printing (with syntax highlighting) the block before executing it, and returning to the interactive prompt after each block. The interactive namespace is updated after each block is run with the contents of the demo’s namespace.

This__ allows you to show a piece of code__, run it and then execute interactively commands based on the variables just created. Once you want to continue, you simply execute the next block of the demo. The following listing shows the__ markup__ necessary for dividing a script into sections for execution as a demo:

"""A simple interactive demo to illustrate the use of IPython's Demo class.

Any python script can be run as a demo, but that does little more than showing
it on-screen, syntax-highlighted in one shot.  If you add a little simple
markup, you can stop at specified intervals and return to the ipython prompt,
resuming execution later.
"""

print 'Hello, welcome to an interactive IPython demo.'
print 'Executing this block should require confirmation before proceeding,'
print 'unless auto_all has been set to true in the demo object'

# The mark below defines a block boundary, which is a point where IPython will
# stop execution and return to the interactive prompt.
# Note that in actual interactive execution, 
# <demo> --- stop ---

x = 1
y = 2

# <demo> --- stop ---

# the mark below makes this block as silent
# <demo> silent

print 'This is a silent block, which gets executed but not printed.'

# <demo> --- stop ---
# <demo> auto
print 'This is an automatic block.'
print 'It is executed without asking for confirmation, but printed.'
z = x+y

print 'z=',x

# <demo> --- stop ---
# This is just another normal block.
print 'z is now:', z

print 'bye!'

In order to run a file as a demo, you must first make a Demo object out of it. If the file is named myscript.py, the following code will make a demo:

**from IPython.lib.demo import Demo**
**mydemo = Demo('myscript.py')**

This creates the mydemo object, whose blocks you run one at a time by simply calling the object with no arguments. If you have autocall active in IPython (the default), all you need to do is type:

**mydemo**

and IPython will call it, executing each block. Demo objects can be restarted, you can move forward or back skipping blocks, re-execute the last block, etc. Simply use the Tab key on a demo object to see its methods, and call ‘?’ on them to see their docstrings for more usage details. In addition, the demo module itself contains a comprehensive docstring, which you can access via:

**from IPython.lib import demo**
**demo?**

Limitations: It is important to note that these demos are limited to fairly simple uses. In particular, you cannot break up sections within indented code (loops, if statements, function definitions, etc.) Supporting something like this would basically require tracking the internal execution state of the Python interpreter, so only top-level divisions are allowed. If you want to be able to open an IPython instance at an arbitrary point in a program, you can use IPython’s embedding facilities, see IPython.embed() for details.
