Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2011-05-22T09:23:45+08:00

====== basic knowledge ======
Created Sunday 22 May 2011
http://www.starming.com/index.php?action=plugin&v=wave&tpl=union&ac=viewgrouppost&gid=73&tid=4591

===== 数值： =====
在Python中有4种类型的数——整数、长整数、浮 点数和复数。

    2是一个整数的 例子。
    长整数不过是大一些的整数。
    3.23和52.3E-4是 浮点数的例子。E标记表示10的幂。在这里，52.3E-4表示52.3 * 10-4。
    (-5+4j)和(2.3-4.6j)是 复数的例子。

===== 字符串： =====
* 使用单引号（'）

    你可以用单引号指示字符串，就如同'Quote me on this'这样。所有的空白，即空格和制表符都照原样保留。
* 使用双引号（"）

    在双引号中的字符串与单引号中的字符串的使用 完全相同，例如"What's your name?"。
* 使用三引号（''' 或"""）

    利用三引号，你可以指示一个多行的字符串。你 可以在三引号中自由的使用单引号和双引号。

===== 转义符 =====

输出， '输出' - 和 java 差不多。

“ I am is a \
 student!”

表示字符串在下一行继续，和“I am is a student!”是一样的。

===== 自然字符串 =====

如果你想要指示某些不需要如转义符那样的特别处理的字 符串，那么你需要指定一个自然字符串。自然字符串通过给字符串加上前缀r或R来指定。例如r"Newlines are indicated by n"。

===== Unicode字符串 =====

Unicode是书写国际文本的标准方法。如果你想要 用你的母语如北印度语或阿拉伯语写文本，那么你需要有一个支持Unicode的编辑器。类似地，Python允许你处理Unicode文本——你只需要在 字符串前加上前缀u或U。例如，u"This is a Unicode string."。

记住，在你处理文本文件的时候使用Unicode字符 串，特别是当你知道这个文件含有用非英语的语言写的文本。

===== 字符串是不可变的 =====

这意味着一旦你创造了一个字符串，你就不能再改变它 了。虽然这看起来像是一件坏事，但实际上它不是。我们将会在后面的程序中看到为什么我们说它不是一个缺点。

===== 按字面意义级连字符串 =====
如果你把两个字符串按字面意义相邻放着，他们会被Python自动级连。例如，'What's' 'your name?'会 被自动转为"What's your name?"。

===== 标识符的命名 =====
变量是标识符的例子。 标识符 是用来标识 某样东西 的名字。在命名标识符的时候，你要遵循这些规则：

* 标识符的第一个字符必须是字母表中的字母（大 写或小写）或者一个下划线（‘ _ ’）。
* 标识符名称的其他部分可以由字母（大写或小 写）、下划线（‘ _ ’）或数字（0-9）组成。
* 标识符名称是对大小写敏感的。例如，myname和myName不 是一个标识符。注意前者中的小写n和后者中的大写N。
* 有效 标识符名称的例子有i、__my_name、name_23和a1b2_c3。
* 无效 标识符名称的例子有2things、this is spaced out和my-name。

===== 对象 =====
记住，Python把在程序中用到的**任何东西都称为对象** 。这是从广义上说的。因此我们不会说“某某 东西 ”，我们说“某个 对象 ”。

就每一个东西包括数、字符串甚至函数都是对象这一点来 说，Python是__极其完全地面向对象__的。

例子：

print "Hello World!你好！" "我是张天瑞"
i = 5
print i
i = i + 1
print i

s = '''This is a multi-line string.
This is the second line.'''
print s

使用变量时只需要给它们赋一个值。不需要声明或定义数 据类型。

===== 逻辑行与物理行 =====
物理行是你在编写程序时所 看见 的。逻辑行是Python 看见的单个语句。Python假定每个 物理行 对应一个 逻辑 行 。

逻辑行的例子如print 'Hello World'这样的语句——如果它本身就是一行（就像你在编辑器中看到的那样），那么它也是一个物理行。

默认地，Python希望**每行都只使用一个语句**，这样 使得代码更加易读。

如果你想要__在一个物理行中使用多于一个逻辑行__，那么你 需要使用分号（;）来特别地标明这种用法。分号表示一个逻辑行/语句的结束。

 

===== 缩进 =====
空白在Python中是重要的。事实上行 首的空白是重要的。它称为缩进。在逻辑行首的空白（空格和制表符）用来决定逻辑行的__缩进层次__，从而 用来决定语句的分组。

这意味着同一层次的语句必须有 相同的缩进。每一组这样的语句称为一个块。我们将在后面的章节中看到有关块的用处的例子。

你需要记住的一样东西是错误的缩进会引发错误。

 

===== 运算符 	 =====
名称 	说明 	例子
+ 	加 	两个对象相加 	3 + 5得到8。'a' + 'b'得到'ab'。
- 	减 	得到负数或是一个数减去另 一个数 	-5.2得到一个负数。 50 - 24得到26。
* 乘 	两个数相乘或是返回一个被 重复若干次的字符串 	2 * 3得到6。'la' * 3得到'lalala'。
** 	幂 	返回x的y次幂  3 ** 4得到81（即3 * 3 * 3 * 3）
/ 	除 	x除以y 	4/3得到1（整数的除法 得到整数结果）。4.0/3或4/3.0得到1.3333333333333333
// / /	取整除 	返回商的整数部分 	4 // 3.0得到1.0
% 	取模 	返回除法的余数 	8%3得到2。 -25.5%2.25得到1.5
<< 	左移 	把一个数的比特向左移一定 数目（每个数在内存中都表示为比特或二进制数字，即0和1） 2 << 2得到8。——2按比特表示为10
>> 	右移 	把一个数的比特向右移一定 数目 	11 >> 1得到5。——11按比特表示为1011，向右移动1比特后得到101，即十进制的5。
& 	__按位与__ 	数的按位与 	5 & 3得到1。
| 	按位或 	数的按位或 	5 | 3得到7。
^ 	按位异或 	数的按位异或 	5 ^ 3得到6
~ 	__按位翻转 __	x的按位翻转是 -(x+1) 	~5得到6。
< 	小于 	返回x是否小于y。所有比 较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。 	5 < 3返回0（即False）而3 < 5返回1（即True）。比较可以被任意连接：3 < 5 < 7返回True。
> 	大于 	返回x是否大于y 	5 > 3返回True。如果两个操作数都是数字，它们首先被转换为一个共同的类型。否则，它总是返回False。
<= 	小于等于 	返回x是否小于等于y 	x = 3; y = 6; x <= y返回True。
>= 	大于等于 	返回x是否大于等于y 	x = 4; y = 3; x >= y返回True。
= =   等于 	比较对象是否相等 	x = 2; y = 2; x == y返回True。x = 'str'; y = 'stR'; x == y返回False。x = 'str'; y = 'str'; x == y返回True。
!= 	不等于 	比较两个对象是否不相等 	x = 2; y = 3; x != y返回True。
not 	布尔“非” 	如果x为True，返回 False。如果x为False，它返回True。 	x = True; not y返回False。
and 	布尔“与” 	如果x为False，x and y返回False，否则它返回y的计算值。 	x = False; y = True; x and y，由于x是False，返回False。在这里，Python不会计算y，因为它知道这个表达式的值肯定是False（因为x是False）。这个现象 称为短路计算。
or 	布尔“或” 	如果x是True，它返回 True，否则它返回y的计算值。 	x = True; y = False; x or y返回True。短路计算在这里也适用。

===== if语句 =====

if xxx:
    ... ...;
elif xxx:
    ... ...;
else:
    ... ...;

===== while语句 =====

while True:
    ... ...;
else:
    ... ...;
True和False被称为__布尔类型__。你可以分别把它们等效地理解为值1和0

===== for语句 =====
for i in range(1, 5):
    print i;
else:
    print '循环结束'; #总是会执行的，除非碰到 break __提前跳出循环__
range函数生成这个数的序列,输出：1，2，3，4
默认步长时1，也可以自定义 for i in range(1, 5, 2) - 步长为2来输出

for i in [1, 2, 3, 4]：
    print i;
也可以达到同样的效果。

continue、break 语句和 java 中的差不多

===== 函数 =====
def showList(a, b):
    for i in range(a, b):
        print i;
    else :
        print '循环结束';
showList(1, 5)

===== 使用global语句 =====
如果你想要为一个定义在函数外的变量赋值，那么你就得 告诉Python这个变量名不是局部的，而是 全局 的。我们使用global语句完成这一功能。没有global语 句，是不可能为定义在函数外的变量赋值的。

你可以使用定义在函数外的变量的值（假设在函数内没有 同名的变量）。然而，我并不鼓励你这样做，并且你应该尽量避免这样做，因为这使得程序的读者会不清楚这个变量是在哪里定义的。使用global语 句可以清楚地表明变量是在外面的块定义的。

def say(message, times = 1): - 可以事先给出默认参数，只限于最后一个形参
    print message * times

say('Hello') - 打印一遍
say('World', 5)  - 打印5遍

一般情况下按参数顺序赋值，函数声明的时候有默认值的就可以不起默认值。
如果指定赋值就这样：def say（c = 2）,就回指定给形参 c 赋值，a、b 取默认值，

===== return使用 =====

可以返回一个值，或者跳出函数

注意，没有返回值的return语 句等价于__return None__。None是Python中表示没有任何东西的特殊类型。例如，如 果一个变量的值为None，可以表示它没有值。

除非你提供你自己的return语 句，每个函数都在结尾暗含有return None语句。通过运行print someFunction()， 你可以明白这一点，函数someFunction没有使用return语句，如同：

def someFunction():
    pass

===== pass语句 =====
在 Python中表示一个空的语句块。

===== DocStrings使用 =====
Python有一个很奇妙的特性，称为 文 档字符串 ，它通常被简称为 docstrings 。DocStrings是一个重要的工具，由于它帮助你的程序文档更加简单易懂，你应该尽量使用它。你甚至可以在程序运行的时候，从函数恢复文档字符串！
def say():
    '这是文档字符串'
    print '说点什么';
print say.__doc__;
以上语句只会输出 ‘这是文档字符串’

===== 模块 =====
你已经学习了如何在你的程序中定义一次函数而重用代 码。如果你想要在其他程序中**重用很多函数**，那么你该如何编写程序呢？你可能已经猜到了，答案是使用模块。__模块基本上就是一个包含了所有你定义的函数和变量 的文件__。为了在其他程序中重用模块，模块的文件名必须以.py为扩展名。

===== 字节编译的.pyc文件 =====
输入一个模块相对来说是一个比较费时的事情，所以 Python做了一些技巧，以便使输入模块更加快一些。一种方法是创建__ 字节编译__的文件 ，这些文件以.pyc作 为扩展名。字节编译的文件与Python变换程序的中间状态有关（是否还记得Python如何工作的介绍？）。当你在下次从别的程序输入这个模块的时候，.pyc文件是十分有用的——它会快 得多，因为一部分输入模块所需的处理已经完成了。另外，这些字节编译的文件也是与平__台无关__的。所以，现在你知道了那些.pyc文 件事实上是什么了。

===== from..import语句 =====
如果你想要直接输入argv变 量到你的程序中（避免在每次使用它时打sys.），那么你可以使用from sys import argv语 句。如果你想要输入所有sys模块使用的名字，那么你可以使用from sys import *语 句。这对于所有模块都适用。一般说来，__应该避免使用from..import而使用import语 句__，因为这样可以使你的程序更加易读，也可以避免名称的冲突。

可以直接运行 helloModule.py 里的语句

    import helloModule;   

    helloModule.sayHello();  
    print helloModule.version;  
    #或者是  
    from helloModule import sayHello, version;  
    sayHello();  
    print version; 

dir()函数

你可以使用内建的dir函数来列出模块定义的标识符。标识符有函数、类和变量。

当你为dir()提供一个模块名的时候，它返回模块定义的名称列表。如果不提供参数，它返回当前模块中定义的名称列表。

dir(sys)
数据结构
列表

list是处理一组有序项目的数据结构，即你可以在一个列表中存储一个 序列 的项目。假想你有一个购物列表，上面记载着你要买的东西，你就容易理解列表了。只不过在你的购物表上，可能每样东西都独自占有一行，而在Python中，你在每个项目之间用逗号分割。

列表中的项目应该包括在方括号中，这样Python就知道你是在指明一个列表。一旦你创建了一个列表，你可以添加、删除或是搜索列表中的项目。由于你可以增加或删除项目，我们说列表是 可变的 数据类型，即这种类型是可以被改变的。

 

    shoplist = ['东瓜', '南瓜', '西瓜', '瓜瓜', '阿瓜'];  

        len(shoplist)  
        shoplist[2];  
        shoplist.append('张天瑞');  
        del shoplist[4];  
        shoplist.sort(); - sort(reverse=True)  

元组

元组和列表十分类似，只不过元组和字符串一样是 不可变的 即你不能修改元组。元组通过圆括号中用逗号分割的项目定义。元组通常用在使语句或用户定义的函数能够安全地采用一组值的时候，即被使用的元组的值不会改变。

    zoo = ('wolf', 'elephant', 'penguin')  

    new_zoo = ('monkey', 'dolphin', zoo)  
        len(new_zoo)  
        new_zoo[2]  
        new_zoo[2][2] - penguin 

含有0个或1个项目的元组。一个空的元组由一对空的圆括号组成，如myempty = () 注意：print '%s is %d years old' % (name, age)
字典

字典类似于你通过联系人名字查找地址和联系人详细情况的地址簿，即，我们把键（名字）和值（详细情况）联系在一起。注意，键必须是唯一的，就像如果有两个人恰巧同名的话，你无法找到正确的信息。

注意，你只能使用不可变的对象（比如字符串）来作为字典的键，但是你可以不可变或可变的对象作为字典的值。基本说来就是，你应该只使用简单的对象作为键。

键值对在字典中以这样的方式标记：d = {key1 : value1, key2 : value2 }。注意它们的键/值对用冒号分割，而各个对用逗号分割，所有这些都包括在花括号中。

记住字典中的键/值对是没有顺序的。如果你想要一个特定的顺序，那么你应该在使用前自己对它们排序。

字典是dict类的实例/ 对象。

    ab = {       'Swaroop'   : 'swaroopch@byteofpython.info',  

                 'Larry'     : 'larry@wall.org',  
                 'Matsumoto' : 'matz@ruby-lang.org',  
                 'Spammer'   : 'spammer@hotmail.com' 
         }  
    ab['Guido'] = 'guido@python.org' 
    del ab['Spammer']  
    for name, address in ab.items():  
        print 'Contact %s at %s' % (name, address)  
    if 'Guido' in ab: # OR ab.has_key('Guido')  
        print "nGuido's address is %s" % ab['Guido']
