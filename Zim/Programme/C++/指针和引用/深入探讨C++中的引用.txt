Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2011-08-06T15:34:28+08:00

====== 深入探讨C++中的引用 ======
Created Saturday 06 August 2011
http://bbs.xiakexing.com/cgi-bin/topic.cgi?forum=22&topic=268

引用是C++引入的新语言特性，是C++常用的一个重要内容之一，正确、灵活地使用引用，可以使程序简洁、高效。我在工作中发现，许多人使用它仅仅是想当然，在某些微妙的场合，很容易出错，究其原由，大多因为没有搞清本源。故在本篇中我将对引用进行详细讨论，希望对大家更好地理解和使用引用起到抛砖引玉的作用。

==== 　　引用简介 ====

　　引用就是某一变量（目标）的一个别名，对引用的操作与对变量直接操作完全一样。

　　引用的声明方法：类型标识符  **&引用名**=目标变量名；

　　【例1】：int a; int &ra=a; //定义引用ra,它是变量a的引用，即别名

　　说明：

　　（1）&在此不是求地址运算，而是起标识作用。
　　（2）类型标识符是指目标变量的类型。
　　（3）声明引用时，必须同时对其进行初始化。
　　（4）引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，且不能再把该引用名作为其他变量名的别名。

　　 ra=1; 等价于 a=1;

　　（5）声明一个引用，__不是新定义了一个变量__，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。故：对引用求地址，就是对目标变量求地址。&ra与&a相等。
　　（6）__不能建立数组的引用__。因为数组是一个由若干个元素所组成的集合，所以无法建立一个数组的别名。

==== 　　引用应用 ====

==== 　　1、引用作为参数 ====

　　引用的一个重要作用就是作为函数的参数。以前的C语言中函数参数传递是值传递，如果有大块数据作为参数传递的时候，采用的方案往往是指针，因为这样可以避免将整块数据全部压栈，可以提高程序的效率。但是现在（C++中）又增加了一种同样有效率的选择（在某些特殊情况下又是必须的选择），就是引用。

　　【例2】：

void swap(int &p1, int &p2) //此处函数的形参p1, p2都是引用
{ int p; p=p1; p1=p2; p2=p; }

　　为在程序中调用该函数，则相应的主调函数的调用点处，直接以变量作为实参进行调用即可，而不需要实参变量有任何的特殊要求。如：对应上面定义的swap函数，相应的主调函数可写为：

main( )
{
　int a,b;
　cin>>a>>b; //输入a,b两变量的值
　swap(a,b); //直接以变量a和b作为实参调用swap函数
　cout<<a<< ' ' <<b; //输出结果
}

　　上述程序运行时，如果输入数据10 20并回车后，则输出结果为20 10。

　　由【例2】可看出：

　　（1）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。
　　（2）使用引用传递函数的参数，在内存中并__没有产生实参的副本__，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；__如果传递的是对象，还将调用拷贝构造函数__。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。
　　（3）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用"*指针变量名"的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。

　　如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用__常引用__。

==== 　　2、常引用 ====

　　常引用声明方式：const 类型标识符 &引用名=目标变量名；

　　用这种方式声明的引用，__不能通过引用对目标变量的值进行修改,从而使引用的目标成为const，达到了引用的安全性。__

　　【例3】：

int a ;
const int &ra=a;
ra=1; //错误
a=1; //正确

　　这不光是让代码更健壮，也有些其它方面的需要。

　　【例4】：假设有如下函数声明：

      string foo( );  __ //注意：这并不是利用string类的缺省构造函数创建一个string类型的对像foot，而是声明了一个返回值为string类型的对像函数名为foot的函数原型。__
__如果要创建一个string类型的对像foo则必须去掉后面的双括号。__

void bar(string & s);

　　那么下面的表达式将是非法的：

bar(foo( ));
bar("hello world");

　　原因在于foo( )和"hello world"串都会产生一个临时对象，__而在C++中，这些临时对象都是const类型的__。因此上面的表达式就是__试图将一个const类型的对象转换为非const类型，这是非法的。也就是说，对临时对像的引用是非法的。__

　　引用型参数应该在能被定义为const的情况下，尽量定义为const 。

　
