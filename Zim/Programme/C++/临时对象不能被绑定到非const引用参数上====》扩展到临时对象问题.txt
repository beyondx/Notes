Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2011-08-06T16:28:54+08:00

====== 临时对象不能被绑定到非const引用参数上====》扩展到临时对象问题 ======
Created Saturday 06 August 2011
http://blog.csdn.net/liuxialong/article/details/6539717

概括一下：

__不能把临时对象作为实参传给非const引用。__

例如：
void conv(string &str){}
int main()
{
    conv("dasd");//这里错了，编译器自动生成一个string(“dasd”)__临时对象__，不能将该临时对象传给非const引用
}

因此，需要将其改为

void conv(string str){} //__值传递__

或者

void conv(const string &str){}   //const引用，因为__标准规定临时对象是不能更改的__，所以要加上const修饰

那么这里涉及到一个问题，什么时候会出现临时对象呢？？？？

==== 临时对象的定义： ====

来看一个例子，在c++里，这个tmp是局部对象（变量），而不是临时对象

template <T>
void swap(T &obj1, T&obj2)
{
obj tmp=obj1;//__这里的tmp不能被称为临时对象，它只是局部对象__
obj1=obj2;
obj2=tmp;
}

在C++中__真正的临时对象是看不见的__，它们不出现在你的源代码中。
__PS：__这倒不一定，例如：
     ration t = a + ration(3);
上面的a是一个ration实例，ration(3)就产生一个没有名字的临时对像，同时 a + ration(3)的结果也是一个临时对像（这个对像是编译器自动生成，不可见）。

==== 建立一个没有命名的非堆（non-heap）对象会产生临时对象。 ====

这种未命名的对象通常在两种条件下产生：__为了使函数成功调用而进行隐式类型转换和函数返回对象时__。

理解如何和为什么建立这些临时对象是很重要的，因为构造和释放它们的开销对于程序的性能来说有不可忽视的影响。

=== 1、首先考虑为使函数成功调用而建立临时对象这种情况。 ===

当__传送给函数的对象类型与参数类型不匹配时会产生这种情况__。

例如文章开头的那个例子，conv函数的参数是string型对像的引用，可是传入的实参却是“dasd”，因此，编译器会自动进行隐式转换，生成一个string（“dasd”）的临时对象，再把这个对象传入，这个没有命名的临时对象当然不能修改了，因此必须加上const修饰。

这就是文章一开头的那个问题产生的原因。

=== 2、建立临时对象的第二种环境是函数返回对象时。 ===

例如operator+必须返回一个对象，以表示它的两个操作数的和（参见Effective C++ 条款23）。

给定一个类型Number，这种类型的operator+被这样声明：

__const__ Number operator+(const Number& lhs,

                       const Number& rhs);

这个函数的返回值是临时的，因为它没有被命名；它只是函数的返回值。

你必须为每次调用operator+构造和释放这个对象而付出代价。
PS：这个开头的const可加也可以不加。

==== 关于临时对象的总结： ====

临时对象是有开销的，所以你应该尽可能地去除它们，然而更重要的是训练自己寻找可能建立临时对象的地方。

1、在任何时候只要见到常量引用（reference-to-const）参数，就存在建立临时对象而绑定在参数上的可能性。====》就是文章一开头的那个问题
2、在任何时候只要见到函数返回对象(而非对像的引用)，就会有一个临时对象被建立（以后被释放）。
3.   非const 引用只能绑定到同一个、同类型的对像，即绑定到传入或赋值号右边的同一个对像。
4 .  const引用可以绑定到不是同一个但相关的类型变量或右值，这种情况下__其实const引用绑定到一个临时对象__，若让非const对象绑定到临时对象，则对其的改变只是改变了临时对象，而欲绑定的对象并没有改变，所以临时对象只能绑定到只读的const引用

如int i=12;

  const double &j=i;

其实编译器做会把上述代码转换为如下形式

  double temp=jl

  const double &j=temp;

因为const 引用是只读类型，所以可以绑定到temp引用

ration a1(2, 3);
ration &a2 = a1 + ration(2, 3);   //这是错误的，因为加号生成的是一个临时对像，a2为非const引用，故不能绑定到临时对像。
const ration &a2 = a1 + ration(2, 3) ;// 这是正确的。

__函数参数或返回值类型为类对象时，在传参和返回时就有可能生成临时对象。这时就会调用复制构造函数，由于临时对象的引用只能是常引用。__
__因此复制构造函数的参数类型固定为常引用类型。__
