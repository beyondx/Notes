Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2012-02-16T21:27:00+08:00

====== 回复几个问题 ======
Created Thursday 16 February 2012

http://blog.csdn.net/myan/article/details/5884695


有人问，你要讲的那三个C++特性，网上资料一大堆，你就免了吧。我说，如果我有时间，我会写的跟网上所有人的写法都不一样。比如说，讲 function/bind/lambda/closure，我会从 callback 讲起，回顾一下 C++中的 virtual function和成员函数指针，MFC中的message mapping，Borland C++Builder中的event handling，WTL的 CRTP 模拟虚函数，然后谈谈为什么 Java 需要加入 inner class，为什么C#把 delegate 作为first class citizen，以及 Qt 是如何用 meta-object 系统打造出迄今为止C++最漂亮的GUI框架，以及所有以上一切，在简单的 C 前是多么的多余和废柴。比如说，如果讲 rvalue reference，我会从孤魂野鬼似的匿名临时对象讲起，从 const T&，讲到 RVO/NRVO，说不定还会触及 expression template。
 

但是，我知道我没那么多时间来把这些东西都写下来，写下来也用处不大。这些东西已经不是今天技术的主流。“why”现在越来越不重要，“how”压倒一切。
“既然如此，你怎么还在鼓吹C++的那些奇技淫巧？你没看到C++已经越来越边缘了吗？”

 这个，得容我自辨几句。


首先，我现在只有在业余时间看看技术，所以当然选自己最熟悉的领域。


其次，我不认为C++就没有用武之地了。C++会长期存在下去，而且在一些特殊的领域里仍然充当主角。比如，我们不应该小看 Qt 在移动开发中的发展空间，而在一系列我称之为“对抗性应用”的领域，C++还将占据优势，直到出现真正的替代者——肯定不是D，比较有希望的是Go。只是希望Rob Pike老人家坚持到底，不要跟当年plan 9一样，easy come easy go.

 第三，最重要的，我鼓吹的不是奇技淫巧。相反，我可能比那些没学过C++或者被C++难倒的人都更讨厌C++中那些奇技淫巧，因为它曾浪费了我大量的时间、精力和热情。

为了讲清楚这个问题，我得谈谈C++的风格，这个老掉牙的话题。

 上周末跟老朋友聚会，谈到技术的时候，有一个共识，软件开发方面真正有价值的进步，应当是有利于用户、有利于项目管理、有利于解决领域问题，而不是有利于程序员。多年以来，主流语言和系统的很多改进，其目的都是为了让写程序的人感觉更爽，而与用户、管理和解决问题毫无关系。C++在这方面是带了一个很坏的头，又要追求强大的表达能力，又要追求不打折扣的效率，结果搞出一大堆诸如操作符重载，template meta-programming之类的东西。老实讲，我也觉得：
 
Matrix4f a, b, c; c = a * (b – a);
要比：
Matrix4f a, b, c; c = a.mul(b.sub(a));

更清爽，但是就算是第二种形式，又能怎么样呢？无非多敲几个字而已，能有多大不了的事？哪个合格的程序员敢说无法理解？可为了让程序员的视觉更清爽一点，C++花了n年时间，弄出来一大堆奇技淫巧，再与之前之后诸多特性相互干扰，复杂度成倍增加，有人可能会跳出来反驳说，如果表达能力不重要，那么你干脆回去写汇编好了。

 所以我得把话说全了。__程序的表达能力，只有在反映了其抽象能力的提高时，才是重要的，否则就是自娱自乐__。

__ 抽象是程序开发的全部意义所在__。之所以C比汇编是一个伟大的进步，是因为C建立了一个机器抽象，把诸如寄存器、cache、寻址方式、位对齐之类的细节都透明掉了，由此而带来的表达能力提升，当然是伟大的。但是你看看上面我举的那个例子，有抽象层次的提升吗？没有！有的只是YY暗爽值的提升。这种表达能力提升，如果得来全不费工夫，当然也无伤大雅，如果是呕心沥血，伤人一万，自损三千，窃以为大可不必也。

 软件搞了60年，我认为真正被实践证明了的抽象，一共有四个半，分别是：
 
__1. 机器抽象__，或者称语言抽象，构造一台新的计算机或程序语言，使其能理解领域特定的语言，从而最妥帖地解决问题。这是最有力的抽象，是软件开发中的“火箭科技”。
__2. 过程抽象__，把一件事情看成是__一系列嵌套和串接执行的标准化过程的总和__，就像流水线一样。这是极为有力的抽象，因此C语言无所不能。但是层次偏低，规模增大以后带来一些挑战。
__3. 函数抽象__，最玄妙的一种，这个我不多说，有兴趣的去看 Structure and Interpretation of Computer Programs.
__4. 面向对象抽象__，把一件事情看成是__一组各负其责的对象彼此之间相互收发消息，根据消息相互协作完成工作的过程__。这个抽象也极为有力。
4.5 僵化的面向对象抽象，把世界看成是由**层次分明**、庞杂万端的__类型体系“实例化”__而出的对象组成的，把事情看成是这些对象之间互相收发消息、协作而成的过程。

 问题出在这最后一个抽象上。由于面向对象早期的主要应用场合是__ GUI 和仿真__，是特别适合于**建立类型体系**的应用领域，结果人们误以为这种抽象模型可以应用于所有领域。成长于这个时期的C++受了这种思想的毒害，建立了一个极其严苛、吹毛求疵的类型系统。

事实上，后来的实践表明，拿__静态的类型系统去套多姿多彩、变化万千的现实世界__，纯粹是人类的狂妄自大。除了在少数几个完全是人造出来的领域（典型的就是GUI，什么窗口、控件、菜单…，完全是人自造的）还是可以的，在很多其他领域则是无力的。所以只能算半个抽象。
 
C++就是被这个半吊子抽象所害，以至今天，积重难返。至于用template泛型去放松类型的约束，实属亡羊补牢。template可谓毁誉参半，其中的精妙之处固然令人激赏，其中诡异无聊之处也令人愤懑。现在boost和其他一些C++库之中，把template舞得虎虎生风，我也不知道抽象到几天云外去了，但是仔细看来，往往是自取其乐，跟实际效果并无干系，反而有碍管理与交流。

无论如何，C++已经走到了今天。作为一个提供了较强抽象能力，同时性能又不打折扣的语言，还是不失其地位。

-----------------------
    貌似很有道理.
    现实世界,实际业务千变万化,将如此繁杂的问题域试图以class完全映射到计算机域,实在力不从心.

------------------------
    回复 heguo：不是 class 的问题，是 class hierachy 的问题。僵化的面向对象要求我们在动手构造系统之前先把系统背后的静态结构给总结出来，这个实在是强人所难。
-----------------------
回复 myan：我觉得你可能对封装理解的不够深刻，面向对象并不是一次性的就把所有的静态结构都总结出来的，事物都是在不断变化发展的，在没有了解清楚之前，我们不需要定义class，只需要定义我们搞清楚的，不清楚的可以封装在class内部
-----------------------
回复 book_uynixoac：
这一点我同意myan的说法。
用类来封装数据和行为并且在一组类之间通过信息交互以完成某一个事情，这是一个进步。类做为状态及其行为的复合体，其实提高了抽象的粒度，减少了对软件理解的复杂度。
但是形形色色的类之间的交互，将在系统中造成的强耦合。由于各个类的类型迥异，将不可能构造一个可用的函数（必须对每个具体的类实现一个——看看C里面各种函数后缀）。为了解决这些问题，类的继承体系被提了出来，虚函数、抽象方法、抽象类、接口等面向对象的概念逐渐被翻出来。他们被提出，只是为了解决对象之间的耦合性以及给对象一个统一的身份，以让函数可以一个同一个的基础类来处理，并且通过虚函数来实现不同的行为。在当时看来，这些选择是却当的，它们也构成了面向对象理论的基石。
时过境迁，当我们再来看这些选择，发现它们确实是很僵硬。是面向对象强加给现实世界的一个荒谬的逻辑。一个不太却当的比方：人可以喝水，马也可以喝水，马喝水的时候可曾想到过自己是一个可以喝水的动物群中的一个个体？人讲话的时候是否会在意自己是长有嘴的动物群中的一个个体？他们只是渴了，张开嘴喝水而已。经典的面向对象理论如果不搞出一个人和马一个统一的身份标示，将无法统一处理他们喝水这一个动作。
僵硬的面向对象的理论映射到软件开发的过程中，就是你建模一个系统的时候，必须对每个对象的接口及其背后的继承树有着深入的把握且有明确的了解。如果在开发过程中发现两个继承体系中的类有相似的行为需要统一处理，那么就必须搞出一个很诡异很抽象很荒谬的接口，然后两个继承体系所有相关的接口都要做相应的调整。一个新的接口出来了，依赖于该接口抽象的函数或者方法总得引用一个或多个接口的方法。然而，在一个继承体系中很明显的抽象可能再另一个抽象体系中没有相应的概念。怎么办？把它们的行为提取出一个虚幻的接口，并且把相应的属性全部提到抽象类的层次来处理。各种始料不及的变动纷至沓来，原来精心设计的类体系结构在瞬间被破坏的面目全非。

为什么很多人会喜欢C？C虽然有缺点，但是遇到上述问题的修改时，涉及到的修改面却要小得多。由于没有了多个类在虚函数之间的互相调用，整个逻辑相对也会清晰很多。对代码维护而言，更是不知道要轻松多少。

面向对象中的封装是必要的，但是抽象和继承以及由此引起的又长又臭的继承树却是毒瘤。

个人认为，泛型是解决这一问题的良药，C++中的模板，以及各种动态语言都是为了避免上述单一面向对象的机制带来的问题。python作为一种强类型的面向对象的语言用起来非常舒服的原因，就是因为它没有C++/Java/C#过分强调类继承的问题，而是采用了泛型的手法优雅的解决了上述问题。

C++的问题是，它一开始是依照经典的面向对象理论来设计的，不仅引入了继承还引入了多继承。在实践中弊端越来越多时，硬生生的加上了模板这一块，从而使得经典风格和现代风格格格不入，就像华山的剑宗和气宗一样，很别扭。

就算如此，以模板和泛型为理论基础的STL中的容器和算法也要比java/C#最初版本中纯面向对象接口的容器好用不知道多少倍。
