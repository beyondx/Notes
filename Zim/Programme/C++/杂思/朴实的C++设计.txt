Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2012-02-15T21:46:26+08:00

====== 朴实的C++设计 ======
Created Wednesday 15 February 2012

http://www.iteye.com/topic/736269

（这篇文章写于 2008 年底，“去年”指的是 2007 年。）

去年8月入职，培训了4个月，12月进入现在这个部门，到现在工作正好一年了。工作内容是软件开发，具体地说，用C++开发一个网络应用(TCP not Web)，这是我们的外汇交易系统的一个部件。这半年来，和一两位同事合作把原有的一个C++程序重写了一遍，并增加了很多新功能，重写后的代码不长，不到15000行，代码质量与性能大大提高。实际上，重写只花了三个月，9月我们交付了第一个版本，实现了原来的主要功能，吞吐量提高4倍。后面这三个月我们在增加新功能，并准备交付第二个版本。这个项目让我对C++的使用有了新的体会，那就是“实用当头，朴实为贵，好用才是王道”。

C++是一门（最）复杂的编程语言，语言虽复杂，不代表一定要用复杂的方式来使用它。对于一个金融交易系统，正确性是首要的，价格/数量/交割日期弄错了就会赔钱。在编写代码时，我们特别注意把代码写得尽量简单直白，让人一看就懂。为了控制代码的复杂度，我们采用了基于对象的风格，也就是具体类加全局函数，把C++程序写得如C语言一般清晰，同时使用一些C++特性和库来减少代码。

项目中基本没有用到面向对象，或者说没有用到继承和多态的那种面向对象，不一定非得有基类和派生类的设计才是好设计。引入基类和派生类，或许能带来灵活性，但是代码就不如原来透彻了。在不需要这种灵活性的场合，干嘛要付出这样的代价呢？我宁愿花一天时间把几千行 C 代码弄懂，也不愿在几十个类组成的继承体系里绕来绕去浪费脑力。定义并使用清晰一致的接口很重要，但“接口”不一定非得是抽象基类，一个类的成员函数就是它的接口。如果看头文件就能明白这个类在干什么、该怎么用固然很好，如果不明白，打开实现文件，东西都在那儿摆着呢，一望而知。没必要非得用个抽象的接口类把使用者和实现隔开，再把实现隐藏起来，这除了让查找并理解代码变麻烦之外没有任何好处。一个进程内部的解耦意义不大，相反，函数调用是最直接有效的通信方式。或许采用接口类/实现类的一个可能的好处是依赖注入，便于单元测试。经过权衡比较，我们发现针对各个类写测试的意义不大。另外，如果用白盒测试，那么功能代码和测试代码就得同步更新，会增加不少工作量，碍手碍脚。

程序里边有一处用到了继承，因为它能简化设计。这是一个strategy，涉及一个基类和3、4个派生类，所有的类都没有数据成员，只有虚函数。这几个类的代码加起来不到200行。这个设计不是一开始就有的，而是在项目进行了一大半的时候，我们发现代码里有若干处针对请求类型的switch/case，于是我们提炼出了一个strategy，把好几处switch/case替换为了strategy对象的虚函数调用，从而简化了代码。这里我们纯粹把OO当做函数指针表来用的。

程序里还有几处用了模板，甚至是type traits，这都是为了简化代码，少敲键盘。这些代码都藏在一个角落里，对外只暴露出一个全局函数的接口，使用者不会被其困扰。

项目里，我们惟一仰赖的C++特性是确定性析构，即一个对象在离开其作用域之后会保证调用析构函数。我们利用这点大大简化了代码，并确保资源和内存的回收。在我看来，确定性析构是C++区别其他主流开发语言(Java/C#/C/动态脚本语言)的最主要特性。

为了确保正确性，我们另外用Java写了一个测试夹具(test harness)来测试我们这个C++程序。这个测试夹具模拟了所有与我们这个C++程序打交道的其他程序，能够测试各种正常或异常的情况。基本上任何代码改动和bug修复都在这个夹具中有体现。如果要新加一个功能，会有对应的测试用例来验证其行为。如果发现了一个bug，先往夹具里加一个或几个能复现bug的测试用例，然后修复代码，让测试通过。我们积累了几百个测试用例，这些用例表示了我们对程序行为的预期，是一份可以运行的文档。每次代码改动提交之前，我们都会执行一遍测试，以防低级错误发生。

我们让每个类有明确的职责范围，一个类代表一个概念，不能像个杂货铺一样什么都装。在增加或修改功能的时候，仔细考虑在哪儿下手才最合理。必要时可以动大手脚，而不是每次都选择最简单的修补方式，那样只会使代码越来越臭，积重难返，重蹈上一个版本的覆辙。有时我们会提炼出一个新的类，把原来分散在多个类里的代码集中到一起，从而优化结构。我们有测试夹具保障，并不担心修改会破坏什么。

设计不是一开始就形成的，而是随着项目进展逐步演化出来。我们的设计是基于类的，而不是基于类的继承体系。我们是在写应用，不是在写框架，在C++里用那么多继承对我们没好处。一开始我们只有三四个类，实现了基本的报价功能，然后增加了一个类，实现了下单功能。这时我们把报价和下单的共同数据结构提炼成一个新的类，作为原来两个类的成员（而不是基类！），并把解析客户输入的代码移到这个类里。我们的原则是，可以有特别简单的类，但不宜有特别复杂的类，更不能有大怪兽。一个类太大，我们就看看能不能把它拆成两个，把责任分开。两个类有共同的代码逻辑，我们会考虑提炼出一个工具类来用，输入数据的验证就是这么提炼出来的一个类。勿以善小而不为，所以始终能让代码保持清晰易懂。

让代码保持清晰，给我们带来了显而易见的好处。错误更容易暴露，在发布前每多修复一个错误，发布后就少一次半夜被从被窝里叫醒查错的机会:)

不要因为某个技术流行而去用它，除非它确实能降低程序的复杂性。毕竟，软件开发的首要技术使命是控制复杂度，防止脑袋爆掉。对于继承要特别小心，这条贼船上去就下不来，除非你是继承boost::noncopyable 讲解面向对象的书里，总会举一些用继承的精巧的例子，比如矩形、正方形、圆形继承自形状，飞机和麻雀继承自“能飞的”，这不意味着继承处处适用。我认为在C++这样需要自己管理内存和对象生命期的语言里，大规模使用面向对象、继承、多态多是自讨苦吃。还不如用C语言的思路来设计，在局部用一用继承来代替函数指针表。而GoF的《设计模式》与其说是常见问题的解决方案，不如说是绕过（work around）C++语言限制的技巧。当然，也是一些人挂在嘴边用来忽悠别人或麻痹自己的灵丹妙药。

hyf------------------------------------------
我也赞同实用主义，喜欢扁平化的类体系。我觉得使用面向对象其实是把平面复杂度转换成立体复杂度，从流程理解变成交互模型理解。复杂性并被没有消除，只是转化成另一种形式。

面向对象具有模拟现实的优势，所以人普遍觉得它更容易理解和把握。优势不多说，我只弹一些缺点。

1、它对系统的诠释远没有结构化分析来得严格和精确。不视角得到不同的结果，这种视角差异可能会导致别人看你的设计别扭，缺乏认同感，甚至很难接受。或者，有时过一段时间，自己也会看自己的设计不顺眼。做出一个好的面向对象设计不容易。

2、它设计的失误很难纠正。面向对象的抽象粒度比过程式大，就注定它牺牲了灵活性。到后来发现抽象有点问题的时候，整个系统都依赖于这种设计了，这个时候已经很难纠正了。要么弄些邋遢的补丁，要么用一些复杂设计来补救，这里可能费心思用某某设计模式，但原本其实是不必要存在的。

3、可能会设计过度。成熟的设计师或者没这方面的担忧，但还是有不少人对设计追求过度了。这不是面向对象特有的现象，却在它这表现最为突出。因为它很鼓励抽象，“完美设计”太吸引人。
做出些比如：超出了问题域的设计，只增加复杂度不带来价值的设计，过分“远见”代价大的设计，不能抽象的也抽象，交互模型过度复杂的抽象等等。

所以我认为面向对象对于哪些模拟为主的任务，或者已经有明确实体概念的领域较为擅长，发挥效用最大。

而当没有现实概念对应，依靠作者本人理解，又或者对系统演化不太明确的情形下，就要十分小心了。推翻设计代价是很大的。 

pangyi----------------------------------------------------
实用为王。不要本本主义！

根据开发的需要和软件的需求，采用恰当的设计思路，不管是OO还是其他，都是为开发所需要。

非常欣赏hyf 对OO和结构化这这两种开发理念的理解。

尤其是“我觉得使用面向对象其实是把平面复杂度转换成立体复杂度，从流程理解变成交互模型理解。复杂性并被没有消除，只是转化成另一种形式。”，很经典！

但是不太赞同hyf对面向对象所提的三点缺陷。

问题的复杂度，和采用那种设计方式是无关的。问题的复杂度是需求的复杂度，是问题本身的特性。

采用某种设计方式只是为了将问题的复杂度逐步分解，也就是将复杂问题简单化处理。

因此，我在开发中，宏观上采用OO设计，这样使得整体上清晰且明确。在对象的操作上，比如某个方法，采用结构化，即顺序化设计思路。

记得有本UML书中说，面向对象的核心是给对象合理分配职责。我一直很推崇。

在此，抛砖引玉，与大家共勉了。 

Solstice---------------------------------------------------------
非常深刻的见解！

关于第 2 点，我提供两个注脚：
1. Linus 在 2007 年炮轰 C++ 时说“——低效的抽象编程模型，可能在两年之后你会注意到有些抽象效果不怎么样，但是所有代码已经依赖于围绕它设计的‘漂亮’对象模型了，如果不重写应用程序，就无法改正。”
http://thread.gmane.org/gmane.comp.version-control.git/57643/focus=57918

2. Google 的 Go 语言在设计时有意禁止了类型继承：
http://golang.org/doc/go_lang_faq.html#inheritance
这么做的原因是，如果有一棵类型继承树，人们在一开始设计时就得考虑各个 class 在树上的位置。
随着时间的推衍，原来正确的决定有可能变成错误的。但是更正这个错误的代价可能很高。要想把这个
class 在继承树上从一个节点挪到另一个节点，可能要触及所有用到这个 class 的客户代码，所有
用到其各层基类的客户代码，以及从这个 class 派生出来的classes 的代码。
简直牵一发而动全身，在 C++ 缺乏良好重构工具的语言下，有时候只好保留错误，用些 wrapper 或
者 adapter 来掩盖之。久而久之，设计越来越烂，最后只好推倒重来。
解决办法之一就是不采用基于继承的设计，而是写一些容易使用也容易修改的具体类。

总之，继承和虚函数是万恶之源，这条贼船上去就不容易下来。不过还好，在 C++ 里我们有别的办法:
http://blog.csdn.net/Solstice/archive/2008/10/13/3066268.aspx 

jimmy_c-----------------------------------------------------------------
15,000行代码；几百个测试用例；3个月开发时间；全部重写的代码。
确实，楼主的开发模式是可行的。

不过，C++开发在1万行，十万行，百万行的规模上，设计和开发思路是有很大不同的。
每个人都是经验主义者，尤其是软件开发人员，都只会认可自己熟悉的产品的熟悉的开发模式，包括Linus对于C++的批判。 

---------------------------------------------------------------------------
我是一个JAVA程序员，我习惯具体问题具体分析，不喜欢把简单的问题过度的抽象，也不喜欢把复杂的问题过程化。实用为主。需求变化时做必要的重构。最重要是平衡，中国人常说的阴阳平衡嘛。 

jimmy_c-----------------------------------
其实什么代码都有重写的可能。Linus说这话是不大地道的。毕竟，Linux是不提供Windows平台的二进制兼容的，代码改变了就要重编译，原因就是他写的“不漂亮”的代码有更多从头写过的可能。 
其实这段话包含了关于遗留代码(Legacy code)的两方面的内容。第一，重用。第二，重写。“能不改就不改”的原则早就被Refactoring那本书给批判过了，所以“设计越来越烂，最后只好推倒重来”并不是OO的问题，而是开发模式的问题。其次，如果一旦囿于时间的金钱需要重用一段年久失修的代码，依我的经验，OO的风格至少要比c要好处理的多。
“牵一发而动全身”往往是源于设计失误。这样的问题，c程序里简直要多得多的多。
Go语言目前是很风光，但是我们要清楚，它离成功的路还太远。即使是那么不得意C++的Linus在评价Go的时候也说：Go很好。但是想推出一门新语言实在是太难了。 
C++最大的优势是在于提供了多种语言风格的选择。如果你实在讨厌OO，不用就可以了，至少还有C风格；如楼主的纯对象风格；模板/标准库风格；以及Generic Programming风格可以选择。 

jimmy_c------------------------------------
我觉得不应该说“平衡”，而是“权衡”。
敏捷开发那本书里讲的Open-Close原则，我觉得就是“权衡”。什么是不变的，什么是变化的，源于开发者对于需求和技术的理解，权衡之后达到的结果。什么该Open，什么该Close，玄之又玄。其实上面的帖子对于C++和OO风格的批判，都应该归结到这个原则上，是设计的问题，和具体语言无关。 

myan-----------------------------------
为什么这个时候把这篇文章又翻出来？两年过去，你的想法有没有什么发展和变化？这倒是我更感兴趣的。

不过其实我同意你在2008年底写的一系列文章中的观点，C++中OO的大部分内容，现在只有面试的时候可能有点用，其他时候最好绕道而行。

现在 mem_fn, reference_wrapper, function 和 bind 都被直接放到了 std 里面，C++编程的风格可以发生根本变化了。我其实很希望能够看到你有一个更系统的论述，毕竟在这方面，你可能是经验最丰富的人之一。

BTW，给我发个短信，我手机crash，把你的联系方式丢了。 

我记得在 InfoQ 上看到一篇文章，几个OO先驱在反思，说OO当初的本意其实就是对象之间的消息交互——这是一个简单有力的世界观，也是对现实世界的一个有效的刻画。但是不知道为什么，到了80年代中后期，OO的重点变成了“封装、继承、多态性”，其中对于继承的强调完全是基于想象而不是软件开发实践，结果诱导一代人尝试去建立完整复杂的继承树——这需要对于现实世界进行静态的、层级化的概念分类，这样一来，就对OO来了一个釜底抽薪，偷换了其根本的世界观。而这个新的世界观，其实并不太经得起推敲，不但不同的人有不同的看法，而且过于繁复易错，而且会使开发者偏离软件开发的根本目标，转而去构建应用领域中的概念体系。

我想这个是OO实践十多年来未进入人意的根本原因。 

jimmy_c-----------------------------------
		myan 写道
		...而这个新的世界观，其实并不太经得起推敲，不但不同的人有不同的看法，而且过于繁复易错，而且会使开发者偏离软件开发的根本目标，转而去构建应用领域中的概念体系...

这两句话是精髓。不过我有两个问题：
1. 封装/继承/多态只是一种选择而不是全部。我觉得方法本身不存在对错，而错误在于开发者建立这种繁复的类体系的选择。
对于C++，我更倾向于一种混合式、渐进式的编程风格。只有时间检验过，用户检验过的类体系才是某种程度可信任的，纯概念性类体系，除了算法库，是很难有通用性的。
还是XP的概念，代码是变化的。变化是唯一不变的东西。
2. 什么是“好的”世界观呢？语言、编程风格、范式都不是永远正确的。不同开发者总会有不同的选择。一个Web开发人员，和OS开发人员，图形图像开发人员，以及骇客/安全开发人员，他们对于开发模式，和编程技术的体验会有很大的区别，这决定了他们对于开发技术的喜好。我不认为这点上Linus就是对的，或者楼主是对的，又或者我是对的。每个人有不同的开发体验，也决定了他们采取的开发技术。
从楼主的例子说，我的结论是，他成功的地方是在于对于代码和测试用例的仔细推敲，而不是采用了哪一种语言风格。采用纯对象式风格的好处，只不过是对一个初级水平的团队更容易理解和把握而已。
归根到底，是开发者的技术经验，对客户的理解，以及对于产品的付出，决定了他能否开发出“好的”产品。其实语言本身是相对次要得多的东西。 

Solstice----------------------------
	
	myan 写道
	我记得在 InfoQ 上看到一篇文章，几个OO先驱在反思，说OO当初的本意其实就是对象之间的消息交互——这是一个简单有力的世界观，也是对现实世界的一个有效的刻画。但是不知道为什么，到了80年代中后期，OO的重点变成了“封装、继承、多态性”，其中对于继承的强调完全是基于想象而不是软件开发实践，结果诱导一代人尝试去建立完整复杂的继承树——这需要对于现实世界进行静态的、层级化的概念分类，这样一来，就对OO来了一个釜底抽薪，偷换了其根本的世界观。而这个新的世界观，其实并不太经得起推敲，不但不同的人有不同的看法，而且过于繁复易错，而且会使开发者偏离软件开发的根本目标，转而去构建应用领域中的概念体系。
	
	我想这个是OO实践十多年来未进入人意的根本原因。


用“继承树”这种方式来建模，确实是基于概念分类的思想。“分类”似乎是西方哲学一早就有的思想，影响深远，这种思想估计可以上溯到古希腊时期。
比如电影，可以分为科幻片、爱情片、伦理片、战争片、灾难片、恐怖片等等。
比如生物，可以分为动物和植物，动物又可以分为有脊椎和无脊椎，有脊椎动物又分为鱼类、两栖类、爬行类、鸟类和哺乳类。
又比如技术书籍分为电子类、通信类、计算机类等等，计算机书籍又可分为编程语言、操作系统、数据结构、数据库、网络技术等等。
这种分类法或许是早期面向对象发展的一个模仿对象。这种思考方式的本质困难在于，某些物体很难准确分类，似乎有不止一个分类适合它。而且不同的人看法可能不同，比如一部动作科幻片到底科幻的成份重还是动作的成份重，到底该归入哪一类。
在编程方面，情况更糟，因为这个“物体x”是变化的，一开始分入A类可能是合理的（x "is-a" A），随着功能演化，分入B类或许更合适(x is more like a B)，但是这样改动对现有代码代价已经太高了（特别对于 C++）。
这根 web 1.0 和 2.0 有点类似，在 web 1.0 时代，给网站分类造就了了 yahoo 的早期成功；到了 web 2.0 时代，tag 代替了分类，一个网址（或者帖子）可以有多个 tag 以便于查找。
在传统面向对象语言，可以用继承多个 interfaces 来缓解分错类的代价，使得一物多用。
现代编程语言这一步走得更远，ruby 的 duck typing 和 go 的无继承都可以看作以 tag 取代分类（层次化的类型）的代表。一个 object 只要提供了相应的 operations，就能当做某种东西来用，不需要显示地继承或实现某个接口。这确实是一种进步。
对于 C++ 的四种范式，我现在基本只把它当 better C 和 data abstraction 来用。OO 和 GP 可以在非常小的范围内使用，只要暴露的接口是 object based （甚至 global function）就行。 

hatedance------------------------
jimmy：
你观点和楼主显然是不同的。你觉得纯面向对象范式太简单了，只是满足初级水平。所以你选择多范例混合编程。
而lz的帖子显然是要说C++太复杂，他只想朴实一些取其中的一小部分就满足了。

我觉得你们代表2种风格。对于同一个web系统，有的架构师喜欢用一种语言实现（ruby，java，php等都能独当一面），也有的架构师喜欢用php,flex做前台，java做后台，python做etl，...所谓各尽其能。
能集大成者，显然功力要很深厚才行。普通人精力有限，只能专攻一向。 

jimmy_c-----------------------------------
这点我是同意的。我更倾向于OO的类框架应该成为一种Refactor的结果。也就是说，如果我们不断地优化代码，得到了几个有相互联系的类，那么就把这些类作为一个可以局部使用的抽象。类本身没有错，错误的是在使用它的时候不分语境、场合，随意地使用。这样就很容易把一些本该限制在一定范围使用的概念给扩大化。
不过我不认为函数和object based的方法就不存在同样的问题。误用是没有国界的。比如myan以前说过的用C++编程，用C做接口，并不能真正解决问题。其实函数做接口不是本质问题，真正关键地是namespace/package，以及动态库的边界能够真正地组件化。也就是你的接口能够封装内部的实现，不要把局部概念扩大化。 

jimmy_c-----------------------------------------
其实从技术上来说，我认为我的观点和楼主的差别有限。如果做同样一个系统，很可能我的方案选择是和他相同的。
我所不同意的，是楼主表述上会给很多初学者带来的误解，比如最初的几个回帖，让人感到又看到了Linus振臂一呼，无数炮灰小弟蜂拥而上的情景。
“能集大成者，显然功力要很深厚才行。普通人精力有限，只能专攻一向。”的观点我是不同意的。如果学不懂C++，去用C好了，还有Java/C#/...一大堆的东西可以选择。本来C++的学习曲线就是很陡的。既然做出了这样的选择，那又连一些基本的东西都不懂，虚函数的概念都搞不清楚，设计模式是什么都不清楚，还不虚心学习，满足于反过来对一些自己都不理解的概念说三道四，那只能说自甘下乘，很难有进步了。
我并不是C++的粉丝，这种语言的问题很多，但一来目前还没有一种语言真正达到完美，甚至是达不到我理想中方便、强大的需求；二来C++真正的问题也并不是楼主所说的那些，个人以为。 

jimmy_c----------------------------------
我的感觉，所有对于OO的批判，对于继承和多态的批判，去追寻炮轰者理论的根源，其实都在于template模式。
原因很简单，只要你遵循C++的语法，大概知道了多态的概念，想着要把这一伟大理论应用于自己的代码，写上个最简单的一个基类，两三个派生类的简单类结构，就自然而然地形成了template模式。
在这里多一句嘴，此template非彼template，是设计模式的概念，而非C++语法中的那个更伟大的关键词。诸位习惯于搞不清虚函数概念，把C++和script混为一谈，搞不清Functional Programming和Procedure Programming概念区别的同学们就不要发表高论了。
不过template模式其实更应该被称作是“template反模式”。因为它的bad smell不是一般地大。所有派生类依赖于基类，它们能够自主的不过是一些可怜的虚函数重载。基类的内部实现逻辑无条件地扩散和统治了所有的派生类。同时由于基类头文件必包含于派生类头文件中，所以所有引用派生类的代码和相关逻辑无一例外会被基类“污染”。基类内部实现的任意一点疑问和错误，对于运行环境的考量，异常处理，等等所有你能想到的问题都会被无限的放大。
而template模式本身对于这些问题的解决大约只有将基类写得尽善尽美，包罗万象。由此产生了一个又臭又长的代码文件。很多的C++类库中都会有这样让人不知所云的文件。
而正确的方法，应该是非常谨慎地限制使用这种模式，非常局部地使用它。

由对template模式的批判，而上升到对继承/多态的批判，甚至对于所有设计模式的批判，我觉得是非常幼稚的。对于“继承树”的建模形式的批判，本身是没有错的。但我想这应该不是我们使用OO的全部。我们不能把孩子和脏水一起倒出去。
我想至少有以下一些理由值得我们使用OO和设计模式，详细的讨论涉及太多细节和代码，所以只写我的论点，没有论述：
1. 依赖倒置原则。代码不应该依赖于具体的实现，而应该依赖于抽象。
  典型的是Java的interface的编程风格。
2. Open-Close原则。
3. 没有上帝原则。我们不能把设计人员当成上帝，他们不能预知未来，所以设计变更是必然的；我们不能要求programmer是上帝，他们不会知晓所有技术和所有代码细节，所以请让他们专注于实现自己的问题；我们不能允许代码模块是上帝，它们绝不能全知全能，应该只包含最少的外部引用，并尽量少地引入逻辑依赖；
4. 最少修改原则。代码需要修改的时候，应该做尽量少的修改，并且修改的地方应该和修改原因明显相关；
5. 不装蛋原则。内涵简单的东西，用简单的形式表示出来，让人一目了然。更多的时候，写的代码让别人看得懂才是最难的。

软件帖的难度在于，对于一个问题的描述，最好使用代码。然而太多时候短代码是很难描述工程中的实际问题的。只好举一个最简单的我称为污染性的问题，说明继承的作用：

class A {
public:
void func();
private:
T1 myFunc(T2 myParam);
private:
T3 _myVariable;
};

这里就有了一个问题，T1/T2/T3是内部实现细节，我并不想把它们引出到外部模块中去。但是C++的语法导致所有引用类A的代码必然知晓T1/T2/T3。
于是我们的代码成为了上帝。我们创造了上帝。不过这种感觉一点儿也不好。

我的解决方法如下：
class A {
public:
virtual void func() = 0;
};

class AImplement : public A {
public:
virtual void func();
private:
T1 myFunc(T2 myParam);
private:
T3 _myVariable;
};

然后可以通过一个Factory或者是Singleton，或是其它创建型模式，可以创建A对象。具体选择依需求而定。比如最简单的函数：
A* Instance() {
return new AImplement();
}

这样外部可以选择只引用A，而不需要引用其内部细节和让人讨厌的内部逻辑。

当然还有另一种方法，比如说把成员函数T1 myFunc(T2)变成一个真正的函数T1 myFunc(A* pThis, T2)不也可以至少去掉讨厌的类型T1, T2么？
然而绝大多数时候由于myFunc内部引用了成员变量_myVariable，导致这样是不可行的。否则我们就要同时把_myVariable变为public才可以。 

jimmy_c--------------------
原因在哪里？
C#比C++易学易用的原因很简单，它是很大程度上的一种动态语言。而C++几乎可以称作是彻头彻尾的静态语言。C++模板技术的发展把这种倾向性推向极致。而虚函数技术是C++中唯一可以用来做些运行期的技术手段。都这样了还不让人用，脑袋秀逗了啊你们？ 

Solstice----------------------------
为了避免 T1, T2, T3 暴露给客户端，完全不必用继承或Factory，用 pimpl 技法就能很好地解决问题。
C++代码  收藏代码

    // A.h  
      
    class AImpl;  
      
    class A {  
     public:  
      A();  
      ~A();  
      void func();  
      
     private:  
      A(const A&);  
      void operator=(const A&);  
      AImpl* impl_;  
    }；  
      
    // A.cc  
      
    class AImpl {  
    public:  
        void func();  
    private:  
        T1 myFunc(T2 myParam);  
    private:  
        T3 _myVariable;  
    };  
      
    A::A()  
     : impl_(new AImpl)  
    {  
    }  
      
    A::~A()  
    {  
      delete impl_;  
    }  
      
    void A::func()  
    {  
      impl_->func();  
    }  


pimpl 这种做法还保障了二进制兼容性，让动态库的升级变得更容易。 

Solstice----------------------------
以虚函数作为接口，其直接副作用是降低二进制兼容性。比如，在 A 里边增加一个新的虚函数，尽管客户端没有用到这个虚函数，也要求重新编译客户端的代码，因为虚函数表里的表项的数目与顺序可能变了。同样的，调换两个虚函数声明的顺序也会导致客户端二进制代码实效，需要重新编译。

如果你暴露出一个由 public 虚函数构成的接口给别人用，一旦你想改动你的基类（无论是 bug fix 还是增加新功能），代价会非常大。

Solstice----------------------------------
class AImpl; 只暴露了一个 forward declaration，没有暴露任何成员。客户端只能看到 A.h，不可能直接创建 AImpl 的对象（因为是个 in-complete type），也就不可能使用它，AImpl 的变化不会影响客户端。
如果你不喜欢，可以把 AImpl 作为 class A 的内部类，这样一点都不污染 namespace 

Solstice-----------------------------------
AImpl 作为 A 的内部类的正确做法是： 
// A.h

class A {
 public:
  A();
  ~A();
  void func();

 private:
  A(const A&);
  void operator=(const A&);
  class AImpl;  // 声明，不是定义
  AImpl* impl_;
}；

// A.cc

// 在这里定义，完全不暴露

class A::AImpl {
public:
	void func();
private:
	T1 myFunc(T2 myParam);
private:
	T3 _myVariable;
};

A::A()
 : impl_(new AImpl)
{
}

A::~A()
{
  delete impl_;
}

void A::func()
{
  impl_->func();
}

jimmy_c---------------------------------------
这个东东在设计模式里被称作delegate（也不是C#的delegate）。
很欣慰，至少你的观点和你引用的帖子不一样，设计模式也用的。
“对象的生命期容易控制”的观点我不同意，这取决于你的implement类的复杂程度。如果delegate仅仅用于替代复杂的基类/子类构造关系，这种模式我是赞同的；但在这个我举的例子里，虚基类显然不适用，所以它不可能更简单。另外如果delegate对象如果包含一些复杂的从属，引用之类的东西，那它的生命周期很容易变得复杂。这显然是比虚基类更容易误用的地方。
我发的帖子一直都在说明，我关注的是类A本身的简化，值对象比指针或者引用调用虚函数容易使用？何从谈起？性能上不会更快，代码上不会更短，概念上，一个是基本的继承关系，一个是delegate模式，哪个更简单，不用讨论了吧？ 

szwe---------------------------------------
面向对象讲的是组合，面向过程讲究的是独立。
独立显然比组合更灵活，但是如果你的需求本来就是大量的组合的话，面向对象的优势就体现出来了。
比如file1.open, file1.read, file1.close这种模式化的操作，还是比handle1=fopen(), fread(handle1), fclose(handle1),handle1=0这种形式更容易避免出错的。再比如try catch和hResult两种错误处理方式，显然后者需要更多的用到if判断来销毁残余的资源，当然出错的可能性更大。
就编程的本质而言，最终肯定是汇编成顺序执行的东西，所以面向过程是主体，决定了系统能不能提供你需要的东西。而面向对象则是对一些可以提供便利的地方加以改进，让你更快更安全的解决问题。 

wandou-----------------------------------
OO是什么思想，它到底是不是有用，这个问题没必要讨论。因为对OO根本就没有明确的定义。什么样的东西叫OO?怎样就不OO了？用了一次继承，其它都没用，是不是就OO了？
在c语言的编程中，经常也会用到类似封装和多态的处理方法，是不是就一定不算OO了？
是否OO无关紧要，关键是OO所带来的那些好处是否真的被程序员了解了。
OO的好处，不在于效率，它的弱点也不在于效率。OO的好处是它可以降低软件的开发成本。它真正的优势，是有效的管理，易于理解的表达方式,以及易于扩展的框架。
不管OO不OO,能写得又快又稳定，扩展性还好，就是王道。
最后说句让你们会丢我砖头的话，其实c#最高效实用（做app)。虽然我用任何一种主流编程语言都会比90%的程序员开发速度快，但我还是觉得c#最简洁。 


ajoo-----------------------------------
				朴实的C++设计 
				..........
真知灼见啊!

我上一次正经用甚至玩C++都是八年前的事了. 现在一直在用Java. 不过不管是基于我过时的C++经验, 还是现在用Java的感觉, 我的观点都和你是惊人的相似.

我搞C/C++的时候也用宏和模板搞些奇技淫巧, 因为有些特殊时候还就是这些毒草能简化代码. 不过总体设计上说, 真还就最好是基本的类+尽量少的间接层(包括继承, 多态, 甚至模板多态). 不过stl还是要用.

感觉这些原则在java里也一样适用. 是的, 我们避免不了要用些反射啦, aop啦之类的魔法, 但是这些不应该是设计的主体. 很多人上来就先来个interface, 让你觉得好像多灵活似地, 但其实接下来不过就是一个FooImpl. 最后一些不需要的灵活性, 脱裤子放屁般的伪封装到处都是, 除了让程序不容易理解, 没起什么正面作用.

动不动就"松耦合". 问题"耦合"不是越松越好. "松耦合"让单独的小模块更独立, 相对更容易单元测试, 但是过度"松"就会造成程序的关联更加隐蔽晦涩. 很多程序模块之间是有关联甚至因果关系的. 强行割裂了来看可能更费解.

而"紧耦合"的好处是理解两个相关模块之间的联系更容易.

黑盒白盒也相对同意. 不过还是不能走极端吧. 如果完全黑盒的话, 测试代码会比较稳定, 改动相对容易. 但是缺点是一些复杂的逻辑和边界条件不容易测试, 而且测试一旦报错, 查错也相对比较难. 

kraft----------------------------
这篇帖子很精彩，后续的回复也很不错，心有戚戚焉，CPP中我最爱的就是RAII和STL,其他情况用C和C++没有太大区别，无非是hide this和构建函数虚表。另有感慨虽然是自己这么想，但说服别人很难，现实中如此，网络中也是如此啊，必须真正经历才能懂得，必须是乐于学习和自我否定的人才能懂得。
谢谢。 
