Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2011-08-07T10:12:30+08:00

====== 析构函数，内联函数 ======
Created Sunday 07 August 2011

   析构函数(destructor) 与构造函数相反，__当对象脱离其作用域时（例如对象所在的函数已调用完毕），系统自动执行析构函数__。析构函数往往用来做“清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间，应在退出前在析构函数中用delete释放）。
       以C++语言为例，析构函数名也应与类名相同，只是在函数名前面加一个波浪符~，例如~stud( )，以区别于构造函数。__它不能带任何参数，也没有返回值（包括void类型）__。只能有一个析构函数，不能重载。如果用户没有编写析构函数，编译系统会自动生成一个__缺省的析构函数，它也不进行任何操作__。所以许多简单的类中没有用显式的析构函数。

       内联函数从源代码层看，__有函数的结构，而在编译后，却不具备函数的性质__。编译时，类似宏替换地，使用函数体替换调用处的函数名。一般在代码中用inline修饰，但是否能形成内联函数，需要看编译器对该函数定义的具体处理。

===== 有两种实现方式： =====

==== 　　1.在类声明的内部声明，而在类声明外部定义叫做显式内联函数，如： ====
　　class display
　　{
　　int t;
　　public:
　　void output(void)
　　}
　　display object;
　　__inline __void display::output(void)
　　{
　　cout << "i is " << i <<"\n";
　　}
　　2.在类声明的内部定义，叫做隐式内联函数，如：
　　class display
　　{
　　int t;
　　public:
　　__inline __void output(void)
　　{cout<<"i is "<< i << "\n";}
　　}
       引入内联函数的目的是为了解决程序中函数调用的效率问题。
　　函数是一种更高级的抽象。它的引入使得编程者只关心函数的功能和使用方法，而不必关心函数功能的具体实现；函数的引入可以减少程序的目标代码，实现程序代码和数据的共享。但是，函数调用也会带来降低效率的问题，因为调用函数实际上将程序执行顺序转移到函数所存放在内存中某个地址，将函数的程序内容执行完后，再返回到转去执行该函数前的地方。这种转移操作要求在转去前要保护现场并记忆执行的地址，转回后先要恢复现场，并按原来保存地址继续执行。因此，函数调用要有一定的时间和空间方面的开销，于是将影响其效率。特别是对于一些函数体代码不是很大，但又频繁地被调用的函数来讲，解决其效率问题更为重要。引入内联函数实际上就是为了解决这一问题。
　　在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来进行替换。显然，这种做法不会产生转去转回的问题，但是由于在编译时函数体中的代码被替代到程序中，因此会增加目标程序代码量，进而增加空间开销，而在时间开销上不象函数调用时那么大，可见它是以目标代码的增加为代价来换取时间的节省。
　　在程序中，调用其函数时，该函数在编译时被替代，而不是像一般函数那样是在运行时被调用。

       构造函数可以是内联函数。
