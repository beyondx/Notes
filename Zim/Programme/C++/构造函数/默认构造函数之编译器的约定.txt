Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2011-08-06T21:39:07+08:00

====== 默认构造函数之编译器的约定 ======
Created Saturday 06 August 2011

      每个对象在创建的时候都会调用构造函数来为自己进行初始化。如果我们在类中并没有提供现成的构造函数，那么编译器就会**自动创建**一个默认地构造函数(注意：__不是拷贝构造函数__)，__它什么都不会做__，只会对我们所定义的对象进行初始化操作。比如说有一个类A，如果在这个类里面我们并没有提供一个构造函数，那么编译器就会自动为我们创建一个不带参数，函数体为空的默认构造函数：
A::A() {}

      但是值得注意的一点是，__如果我们自己在类中已经创建了一个构造函数，那么不管你创建的是像上面这样的默认构造函数，还是一个带有参数的构造函数，编译器都不会再为你提供任何默认构造函数__。如下面这个程序：
01	class demo{
02	public:
03	    demo(int i){x=i;}
04	    int print(){return x;}
05	private:
06	    int x;
07	};
08	 
09	#include <iostream>
10	using namespace std;
11	 
12	int main()
13	{
14	    demo *a=new __demo__;   __//错误__。
15	    demo *b=new demo(1);
16	    cout<<b->print()<<endl;
17	}

在程序的第14行我们声明了一个对象a，但是与15行不同的是，我们想在这里对a调用默认构造函数，希望它能够被编译器自己提供的默认构造函数所初始化。但是当我们一运行的时候，程序就报错了：“error C2512: “demo”: **没有合适的默认构造函数可用**”。

* 上面这个例子说明了，如果我们创建了一个构造函数之后，那么如果想要调用编译器自己的默认构造函数，我们就必须在类中自己声明一个默认构造函数：demo() {};
* 同时，上例也说明，编译器在创建一个对像时，__一定要调用它的相应构造函数__，不管它提供与否。

 那么，程序变成如下所示（在这个程序第3行中，我们自己声明了一个默认构造函数：
01	class demo{
02	public:
03	    demo(){};
04	    demo(int i){x=i;}
05	    int print(){return x;}
06	private:
07	    int x;
08	};
09	 
10	#include <iostream>
11	using namespace std;
12	 
13	int main()
14	{
15	    demo *a=new demo;
16	    demo *b=new demo(1);
17	    cout<<b->print()<<endl;
18	}

只有这样，程序才能够顺利运行。
