Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2011-08-06T14:52:53+08:00

====== 关于基类、派生类、对象、指针和虚函数、多态、 静态绑定、 动态绑定 纯虚函数、抽象类 ======
Created Saturday 06 August 2011

以下观点来源于《深入浅出MFC》

到底调用到哪个函数，必须视指针的原始类型而定，于指针实际所指对象无关。

1.如果你以一个“基类之指针”指向“派生类”，那么经由该指针你只能够调用基类所定义的函数。

2.如果你以一个“派生类之指针”指向一个“基类之对象”，你必须先做明显的转型操作（explicit cast）/（显示强制类型转换）。这种做法很危险，不符合真实生活经验，在程序设计上也会带给程序员困惑。

3.如果基类和派生类都定义了“相同名称之成员函数”，那么通过对象指针调用成员函数时，到底调用到哪一个函数，必须视该指针的原始类型而定，而不是视指针实际所指的对象的类型而定。这与第1点其实意义想通。

虚函数正是为了对“如果你以一个基类之指针指向一个派生类之对象，那么通过该指针你就只能调用基类所定义之成员函数”这条规则反其道而行的设计。也有点反继承的味道呵呵 。多态。

  从操作类型定义来看，什么是虚函数呢？__如果你预期派生类有可能重新定义某一个成员函数，那么你就在基类中把此函数设为virtual。__MFC有两个十分十分重要的虚函数：与document有关的serialize函数和view有关的ondraw函数。你应该在自己的CMyDoc和CMyView中改写这两个虚函数。

多态（Polymorphism）

以相同的指令指针调用了不同的函数，这种性质称为Polymorphism，意思是“the ability to  assume many forms”(多态)。__编译器无法再编译时期判断基类指针到底调用哪一个派生类函数__，必须在执行期才能判断之，这称为__后期绑定late binding或动态绑定dynamic binding__。至于C函数或C++的non-virtual函数，在编译时期就转换为一个固定地址的调用了，这称为前期绑定early binding或静态绑定static binding。

纯虚函数

纯虚函数其函数值“=0 ”。__纯虚函数不需要定义其实际操作__，它的的存在__只是为了在派生类中被重新定义__，只是为了提供一个多态接口。只要是拥有纯虚函数的类，就是一个__抽象类__，它是不能够被实例化（instantiate）的，也就是说，你不能根据它产生一个对象。

关于抽象类。

如果抽象类被继承了，在派生类中没有改写基类中的纯虚函数，那么派生类依然是个抽象类，直到__纯虚函数被实际操作为止__。

虚函数派生下去仍为虚函数，而且__可以省略virtual关键词__。

