Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2011-08-06T14:22:20+08:00

====== 动态分配内存new关见字的使用方法 ======
Created Saturday 06 August 2011

new是在堆上分配内存,它需要用delete释放,否则会造成内存泄漏(使用的内存没有即时释放,造成内存的浪费)

而A a在右大括号执行后,会自动释放内存
如
int main()
{
A a;//定义了一个a对象
A *p=new A;//在堆上定义了一个对象,它的指针保存在p里,注意,堆上定义的对象没有名字,必须用指针保存
return 0;
}//a到这里的时候,它占用的内存就会被回收 而p,除非调用delete p; 否则内存永远不会被回收,指针p丢弃后,那块内存没被释放,

无法被再次使用,造成内存浪费

下面给你详细介绍一下动态分配内存new关键字的使用方法，希望看了之后你能全现了解什么时候可以使用new以及怎样使用new，

以下内容全面，简单易懂，是完全出自本人的学习总结，绝非复制。

动态分配内存new关键字

1． 全局对象和局部对象的__生命期__都是严格定义的，程序员不能以任何方式改变他们的生命期。但是有时候需要创建一些生命期能被程序员控制的
      对象，他的分配和释放可以根据程序运行中的操作来决定。这时就需要使用new操作符了。
2． 动态分配内存，将从堆中分配内存，动态分配的存储区是在运行时确定的，动态分配的存储区可以随着需求而自动扩大．
3． 局部变量一般存储在__堆栈__中，堆栈是先进后出的存储结构，而堆却不是．
4． 在C++中使用new动态分配内存，delete释放以前new分配的内存．
5． 使用new运算符系统将从空闲存储区中为对象分配内存，并返回一个指向该对象的指针即该对象的地址。new运算符的特点是：

       用new运算符__分配的对象没有名字__，对该对象的操作都要__通过指针间接地完成__操作。例如new int，就是从空闲存储区分配了一个int型对象，
       但没法对这个对象进行操作，只是从存储区分配了这么一个空间。语句int *p=new int表示从空闲存储区分配一个int对象并把这个对象的
       地址赋给p，现在p就是用new分配的int对象的地址，而*p就是那里的值。语句int i;int*p=&i;和int *p=new int都是将int变量的地址赋给
       了指针，但不同的是前句可以用名称i和*p来访问该int型变量，而后句则只能用*p来访问该变量，也就是说p指向的内存没有名称。

6． __动态创建数组__：int *p=new int [11]；创建动态数组时必须有[]方括号，且里面要有创建的维数，但该数组的第一维可以是一个复杂的
       表达式。访问地址中的内容的方法为*p访问数组中的第一个元素,p[1]该问第二个元素，以此类推。创建二组数组的例子：
       int (*p)[102]=new int [4][102]。

7． 动态创建对象的初始化：int *p=new int(102)该语句表明由p指向的新创建你对象被初始化为102。动态创建对象的初始化方式为在__类型名__
__      后面用一对括号来被始化__。

8． 动态创建对象的__默认初始化__：方式为在类型名后面跟一对__空的圆括号__初始化， 

      int *p=new int (); int *ps=new string(); cls *pc=new cls();
      第一条语句把对象的值初始化为0，__第二条语句对于提供了默认构造函数的string类，不论程序是要明确的不初始化，还是要求进行值初始化__
__      都会调用默认构造函数初始化该对象。而对于内置类型或没有默认构造函数的类型，则采用不同的初始化方式就会有显著不同的差别。__
      例如：int *p=new int; int *p=new int();第一条语句没有被初始化，而第二条被初始化为0。

9． 用new动态创建的__数组不能被初始化__，不能创建初始化值集。
10．耗尽内存：如果程序用完了所有可用的内存，new表达式就有可能失败。如果new表达式无法获得要需要的内存空间，
       系统将会抛出名为bad_alloc异常。

11．可以在一个函数内使用new运算符分配内存，而在另一个函数中使用delete释放内存空间．delete只能用于释放前次使用new分配的空间，
       不要使用delete来释放不是new分配的内存，不要使用delete释放相同的内存两次，应使用delete []来释放动态数组，例如：
       int *p=new int [10];delete [] p;删除数组必须要有[]方括号。delete不一定要用于new的指针，
       例如int *p=new int ; int *x=p; delete x;将是合法的．如果指针的值为0，则在其上作delete操作是合法的，但没有任何意义。
12．悬垂指针：执行delete p后只是把p所指向的地址的内容给释放掉了，并没有删掉指针p本身，还可以将p重新指向到另一个新的内存块，
       因此p还指向原来他指向的对象的地址，然而p所指向的内容却已经被释放了，因此p不再有效而变得没有定义了。这样的指针称为悬垂指针。
       悬垂指针往往导致程序错误而且很难检测出来。
13．静态联编：如果通过声明来创建数组，则在程序被__编译__时为他分配内存空间，不管程序是否使用数组，数组都在那里，占用了内存。
       在编译时给数组分配内存被称为静态联编。意味着数组是在编译时加入到程序中的。但__使用new时，如果在运行阶段需要数组__，则创建他，
       如果不需要，则不创建，还可以在程序运行时选择数组的长度，这被称为动态联编。意味着数组是在程序运行时创建的，这种数组叫做
      __ 动态数组__，使用静态联编时必须在编写程序的时候指定数组的长度，使用动态联编时，程序将在运行时确定数组的长度。

14．const常量对象的动态分配和回收：与其他常量一样，__动态创建的const对象必须在创建时初始化，并且一经初始化，其值不能再修改__。

       例如：const int *p= new const int(111)；删除方法为：delete p；尽管程序员不能修改const对象的值，但可以撤消对象本身。

15．注意：__不能在空闲存储区上创建内置类型元素(除类、数组、string外)的const数组__。因为我们不能初始化用new创建的内置类型数组的元素。

      如const int *p=new const int [11]；将是错误的。

16．注意：如果用new分配了资源，而没有用delete释放该资源的话，那么用new分配的资源将一指被占用。
17．常见错误：如果对某个指针动态分配了内存，又把另一个变量的地址付给这个指针，这时这个指针就指向了一个静态地址，
       而不是原先的动态地址。如果再用delete删掉这个指针时就会出错，因为这时这个指针是指向静态地址的，不能用delete删除一个指向
       静态地址的指针。比如int *p =new int(1)，这时指针p指向一个动态内存可以对他进行delete删除，但如果再执行语句int a=2; p=&a;
       这时就改变了指针指向的内容，使原先指向的动态内存地址变成了指向现在的静态内存地址，如果这时对指针p进行delete操作就会出错，

       因为你在对一个静态指针静行删除，而delete只能删除动态指针。
例：动态分配对象new
class hyong
{public:
	   int a,b,c;
	   hyong (){a=b=c=0;}
	   hyong(int i){a=b=c=i;}  
	   ~hyong() {cout<<"xigou"<<"/n";}
};

int main()
{ hyong *p=new hyong;   
hyong *p1=new hyong();
 cout<<p->a<<p1->a<<"/n"; //输出两个0，__都调用默认构造函数初始化指针__。
  int *p2=new int;    
  int *p3=new int(); 
  int *p4=new int(1); __//new分配内存的初始化方式。__
  //对于__类置类型来说p2没有被初始化得到的是一个随机值__，p3被初始化为0，p4被初始化为1。
  cout<<*p2<<"/n"<<*p3<<"/n"<<*p4<<"/n";  //输出一个随机值，一个0，一个1
   int i=10;  
   delete p4;  
   cout<<*p4<<"/n"; //p4现在是悬垂指针，delete只是释放掉了指针p4所指向地址的内容， 但指针p4仍然指向原来的地址，但没有内容，指针p4仍然可以再指向其他地址。
  p4=&i; 
  cout<<*p4<<"/n"; //可以对悬垂指针p4重新赋地址。
  const int *p5=new int; 
  const int *p6=new int(4)  ;
  cout<<*p5<<*p6<<"/n";//输出一个随机值和4，__const常量必须在声明时初始化。__
  int *p7=new int[2];   
  p7[0]=5;
  p7[1]=6;  
  cout<<p7[0]<<p7[1]<<"/n";__//定义动态数组,动态数组不能在声明时初始化。__
  //const int *p8=new int[2];  //错误，__因为动态数组不能在声明时初始化，而const又必须要求在声明时初始化，发生冲突__，出错。
  delete p1;
  delete p;    
  //delete p,p1;   //注意，如果使用该语句将则只调用一次析构函数。
  delete p2,p3,p4,p5,p6;   
  delete [] p7; 
  //int *p8=new int(9); int a=8;  p8=&a; delete p8;  //错误，现在的指针p8重新指向了一个静态的地址，
   用delete删掉一个静态地址将发生错误。
  } 






