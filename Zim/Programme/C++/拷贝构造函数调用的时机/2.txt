Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2012-06-11T15:36:38+08:00

====== 2 ======
Created Monday 11 June 2012

------------------ Original ------------------
From: "张俊师兄";
Date: 2011年11月1日(星期二) 下午4:25
To: "534243850"<534243850@qq.com>;
Subject: 回复：C++问题请教
 
我将你的例子改了一下，这样看的更清楚。
以前我对构造函数的理解也不太深刻，中午讨论时没有说清楚。刚才看了一些资料，总结如下：
1. 如果一个函数返回一个类对象，在返回前(即函数的return语句执行前)编译器会调用复制构造函数生成一个临时对象，然后析构函数中的栈对象。如：
A fool(int x, int y)
{
     //生成对象a，它位于函数fool的栈中。
    A a(x, y); 
   //由于函数fool返回后栈将释放(这意味着外界不能再访问a对象)，所以编译器会调用复制构造函数生成一个临时对象。
    return a; 
}

编译器在编译这个函数时内部使用的形式为：
A fool (A& _retval, int x, int y)  //这里的_retval即为返回的临时对象的引用(编译器自动添加)
{ 
    a.A::A(x, y);   
    _retval.A::A(a); //调用复制构造函数生成临时对象
    a.A::~A();        //析构栈上的对象a
}

2. 编译器为了减少复制构造函数调用的次数，会对相关的代码进行优化(这就是中午我们运行结果中没有看到复制构造函数的原因)。例如，编译器会对上面的函数进行如下的优化：
A fool(A& _retval, int x, int y)
{
    _retval.A::A(x, y);
    return ;
}
可以看出，优化后的函数会删除生成栈对象a的代码并且直接返回一个临时对象，这就是所谓的NRV（Named Return Value (NRV) optimization，具名返回值优化)。

3.附件中有两份运行结果，标有VS2010的是没有编译优化的程序运行的结果(我们可以详细地看到复制构造函数的调用过程)，另一份是用g++编译时默认优化的结果(编译器对源代码进行了如2过程的优化，这时将看不到复制构造函数的调用)。

4.还有一个现象需要注意，源代码中的这一句（44行）：
    A b = f('b');
f('b')返回一个临时对象，按说这一行代码会调用复制构造函数生成对象b, 但是在class-demo-VS2010的结果中，我们并没有看到这一过程。这可能也是一个编译器优化的结果：因为生成的临时对象和将要生成的对象b都位于main()的栈中，所以就没必要在将临时对象析构前调用复制构造函数生成一个完全一样的对象b，编译器会直接将临时对象与b关联。

That' all !
参考：
1.拷贝构造函数调用的时机     http://www.4ucode.com/Study/Topic/1404959
2.拷贝构造函数调用总结        http://www.cnblogs.com/howareyou586/archive/2008/11/21/1338273.html
