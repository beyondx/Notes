Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2011-08-06T22:03:45+08:00

====== 构造函数的赋值特例与类型转换问题（explicit） ======
Created Saturday 06 August 2011

=====================构造函数的赋值特例=====================

      一般地，我们可以利用构造函数对成员变量进行赋值，比如说下例：
1	class Demo{
2	public:
3	      Demo (int a,int b){x=a;y=b;}
4	private:
5	      int x;
6	      int y;
7	}

      那么我们在调用该构造函数的时候，就可以直接把参数传进去：
Demo *demo=new Demo(1,2);

但是，有两个特例，需要我们注意一下：

    构造带有const的成员变量
    构造带有引用的成员变量

__由于const成员或者是引用成员都是不可赋值的，所以我们在利用构造函数操作这些成员的时候，不能进行赋值，只能进行初始化！__如下例：
1	class Demo{
2	public:
3	      Demo (int a,int b):__x(a),y(b)__{}   __//注意，只能使用“初始式”，而不能在构造函数中赋值。因为，构造函数执行其函数体时，成员属性已经建立起来了。__
4	private:
5	      const int x;
6	      int &y;
7	}

 上面这个类的第三行就是用构造函数如何初始化（注意，__是初始化！！不是赋值！！__）这两种特殊的成员函数的例子。

=====================类型转换问题（explicit）=====================

在C++中，我们可以把一个__参数当做对象赋给另外一个对象__。但是这种情况仅限于该对象的__构造函数中仅仅有一个同类项的参数时才有用(不一定，完全要一致，如构造函数需要整型，向其传浮点型也可)__。这种情况出现的时候，编译器要做的工作如下：

    对参数进行类型转换
    判断该类的构造函数的参数是否与该参数匹配，假如匹配：
	    调用构造函数创建一个临时的对象
	    将该临时对象赋值给左边的对象
	    调用析构函数删除这个临时对象

现在，我们来看看编译器从第3步到最后一步到底都干了什么......

首先我们定义一个类demo及其带有一个参数的构造函数demo：
class demo
{
public:
      demo(int x){i=x};
private:
      int i;
};

 如果我们在下面程序第二行中写了这样一句话：
1	demo de(0);//声明一个对象de
2	__de=10;//调用构造函数进行强制类型转换__

那么，编译器会重新编辑上例中的“de=10”这行代码：
1	demo temp(10);//实例化一个__临时对象__
2	de=temp;//用“=”把temp对象赋值到de对象中
3	temp.demo::~demo();//调用temp对象的析构函数，删除这个临时对象

这样一来，我们就可以把10强行赋值给de对象了。下面，我们来看一个实际点的例子：
01	#include <iostream>
02	using namespace std;
03	class A
04	{
05	public:
06	    A(int x){i=x;cout<<"构造函数执行!"<<endl;}
07	    ~A(){cout<<"析构函数执行!"<<endl;}
08	    void get(){cout<<i<<endl;}
09	private:
10	    int i;
11	};
12	int main()
13	{
14	    A a(99);
15	    a.get();
16	 
17	    a=1000;
18	    a.get();           
19	    cout<<endl;
20	    a=A(2);            
21	    a.get();           
22	    return 0;
23	}

该程序的输出为：
{{./2011071919075940.png}}
      我们可以看到输出窗口里面绿色的那一栏，即程序的第14行，声明了一个对象啊，并调用构造函数，所以输出“构造函数执行”。之后在程序的第17行我们**强制把1000赋给对象a**，那么编译器就可以__自动调用临时对象__来把这个值赋给对象a，同时赋值完成之后再删除这个对象，所以可以看到“构造函数执行”+“析构函数执行”（上图红色框），这两句话是因为临时对象的创建和销毁所致地。后面的同样输出了这两句话得原因是因为了程序第20行的作用，强行赋值到a，所以输出了如上图蓝色框中的提示。最后，在程序结束的时候，调用析构函数销毁了对象a。

      像上面这样做的好处就是可以__快速地对一个对象进行赋值__，但是值得注意的是，这样的转换又是可能会导致一些意外。因此我们需要使用关键字explicit来关闭这种特性，explicit可以用在构造函数中：
__explicit__ A(int x){};

如果声明了这个关键字，上面这个程序就无法执行了，程序会在第17行报出输出错误：
“二进制“=”: 没有找到接受“int”类型的右操作数的运算符(或没有可接受的转换)”

好了，收工，哈哈
