Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2011-08-05T16:08:29+08:00

====== 面向对象程序设计 ======
Created Friday 05 August 2011
面向对象程序设计（英语：Object-oriented programming，缩写：OOP），指一种程序设计范型，同时也是一种程序开发的方法。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。[1]

当我们提到面向对象的时候，它不仅指一种程序设计方法。它更多意义上是一种程序开发方式。在这一方面，我们必须了解更多关于面向对象系统分析和面向对象设计（Object Oriented Design，简称OOD）方面的知识。
目录
[隐藏]

    1 概述
    2 基本理论
        2.1 类
        2.2 对象
        2.3 方法（秩序；条例）
        2.4 消息传递机制
        2.5 继承性
        2.6 封装性
        2.7 多态性
        2.8 抽象性
    3 OOP名词释意
    4 物件導向的语言
    5 历史
        5.1 腳本中的OOP
    6 参考文献
    7 相关内容
    8 外部链接

[编辑] 概述

面向对象程序设计的雏形，早在1960年的Simula语言中即可发现，当时的程序设计领域正面临着一种危机：在软硬件环境逐渐复杂的情况下，软件如何得到良好的维护？面向对象程序设计在某种程度上通过强调可重复性解决了这一问题。20世纪70年代的Smalltalk语言在面向对象方面堪称经典——以至于30年后的今天依然将这一语言视为面向对象语言的基础。

面向对象程序设计可以被视作一种在程序中包含各种独立而又互相调用的单位和对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，或者说是负有责任的角色。

目前已经被证实的是，面向对象程序设计推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。 此外，支持者声称面向对象程序设计要比以往的做法更加便于学习，因为它能够让人们更简单地设计并维护程序，使得程序更加便于分析、设计、理解。反对者在某些领域对此予以否认。
[编辑] 基本理论

一项由 Deborah J. Armstrong 进行的长达40年之久的计算机著作调查显示出了一系列面向对象程序设计的基本理论。它们是：
[编辑] 类

类（Class）定义了一件事物的抽象特点。通常来说，类定义了事物的属性和它可以做到的（它的行为）。举例来说，“狗”这个类会包含狗的一切基础特征，例如它的孕育、毛皮颜色和吠叫的能力。类可以为程序提供模版和结构。一个类的方法和属性被称为“成员”。 我们来看一段伪代码：

类 狗
开始
    私有成员:
        孕育:
    毛皮颜色:
    公有成员:
      吠叫():
结束

在这串代码中，我们声明了一个类，这个类具有一些狗的基本特征。关于公有成员和私有成员，请参见下面的继承性一节。
[编辑] 对象

对象（Object）是类的实例。例如，“狗”这个类列举狗的特点，从而使这个类定义了世界上所有的狗。而莱丝这个对象则是一条具体的狗，它的属性也是具体的。狗有皮毛颜色，而莱丝的皮毛颜色是棕白色的。因此，莱丝就是狗这个类的一个实例。一个具体对象属性的值被称作它的“状态”。（系统给对象分配内存空间，而不会给类分配内存空间，这很好理解，类是抽象的系统不可能给抽象的东西分配空间，对象是具体的）

假设我们已经在上面定义了狗这个类，我们就可以用这个类来定义对象：

定义莱丝是狗
莱丝.毛皮颜色:=棕白色
莱丝.吠叫()

我们无法让狗这个类去吠叫，但是我们可以让对象“莱丝”去吠叫，正如狗可以吠叫，但没有具体的狗就无法吠叫。
[编辑] 方法（秩序；条例）

方法（Method）是定义一个类可以做的，但不一定会去做的事。作为一条狗，莱丝是会吠叫的，因此“吠叫()”就是它的一个方法。与此同时，它可能还会有其它方法，例如“坐下()”，或者“吃()”。 对一个具体对象的方法进行调用并不影响其它对象，正如所有的狗都会叫，但是你让一条狗叫不代表所有的狗都叫。 如下例：

定义莱丝是狗
定义泰尔是狗
莱丝.吠叫()

则泰尔是会吠叫但没有吠叫的，因为这里的吠叫只是对对象“莱丝”进行的。
[编辑] 消息传递机制

一个对象通过接受消息、处理消息、传出消息或使用其他类的方法来实现一定功能，这叫做消息传递机制（Message Passing）。
[编辑] 继承性

继承性（Inheritance）是指，在某种情况下，一个类会有“子类”。子类比原本的类（称为父类）要更加具体化，例如，“狗”这个类可能会有它的子类“牧羊犬”和“吉娃娃犬”。在这种情况下，“莱丝”可能就是牧羊犬的一个实例。子类会继承父类的属性和行为，并且也可包含它们自己的。我们假设“狗”这个类有一个方法叫做“吠叫()”和一个属性叫做“毛皮颜色”。它的子类（前例中的牧羊犬和吉娃娃犬）会继承这些成员。这意味着程序员只需要将相同的代码写一次。 在伪代码中我们可以这样写：

类牧羊犬:继承狗

定义莱丝是牧羊犬
莱丝.吠叫()    /* 注意这里调用的是狗这个类的吠叫方法。 */

回到前面的例子，“牧羊犬”这个类可以继承“毛皮颜色”这个属性，并指定其为棕白色。而“吉娃娃犬”则可以继承“吠叫()”这个方法，并指定它的音调高于平常。子类也可以加入新的成员，例如，“吉娃娃犬”这个类可以加入一个方法叫做“颤抖()”。设若用“牧羊犬”这个类定义了一个实例“莱丝”，那么莱丝就不会颤抖，因为这个方法是属于吉娃娃犬的，而非牧羊犬。事实上，我们可以把继承理解为“是”。例如，莱丝“是”牧羊犬，牧羊犬“是”狗。因此，莱丝既继承了牧羊犬的属性，又继承了狗的属性。 我们来看伪代码：

类吉娃娃犬:继承狗
开始
   公有成员:
      颤抖()
结束
类牧羊犬:继承狗

定义莱丝是牧羊犬
莱丝.颤抖()    /* 错误：颤抖是吉娃娃犬的成员方法。 */

当一个类从多个父类继承时，我们称之为“多重继承”。多重继承并不总是被支持的，因为它很难理解，又很难被好好使用。
[编辑] 封装性

具备封装性（Encapsulation）的面向对象程序设计隐藏了某一方法的具体执行步骤，取而代之的是通过消息传递机制传送消息给它。因此，举例来说，“狗”这个类有“吠叫()”的方法，这一方法定义了狗具体该通过什么方法吠叫。但是，莱丝的朋友蒂米并不需要知道它到底如何吠叫。 从实例来看：

/* 一个面向过程的程序会这样写： */
定义莱丝
莱丝.设置音调(5)
莱丝.吸气()
莱丝.吐气()

/* 而当狗的吠叫被封装到类中，任何人都可以简单地使用： */
定义莱丝是狗
莱丝.吠叫()

封装是通过限制只有特定类的实例可以访问这一特定类的成员，而它们通常利用接口实现消息的传入传出。举个例子，接口能确保幼犬这一特征只能被赋予狗这一类。通常来说，成员会依它们的访问权限被分为3种：公有成员、私有成员以及保护成员。有些语言更进一步：Java可以限制同一包内不同类的访问；C#和VB.NET保留了为类的成员聚集准备的关键字：internal（C#）和Friend（VB.NET）；Eiffel语言则可以让用户指定哪个类可以访问所有成员。
[编辑] 多态性

多态性（Polymorphism）是指由继承而产生的相关的不同的类，其对象对同一消息会做出不同的响应。[2]举例来说，狗和鸡都有“叫()”这一方法，但是调用狗的“叫()”，狗会吠叫；调用鸡的“叫()”，鸡则会啼叫。 我们将它体现在伪代码上：

类狗
开始
   公有成员:
       叫()
       开始
          吠叫()
       结束
结束

类鸡
开始
   公有成员:
       叫()
       开始
          啼叫()
       结束
结束

定义莱丝是狗
定义鲁斯特是鸡
莱丝.叫()
鲁斯特.叫()

这样，同样是叫，莱丝和鲁斯特做出的反应将大不相同。多态性的概念可以用在运算符重载上，本文不再赘述。
[编辑] 抽象性

抽象(Abstraction)是简化复杂的现实问题的途径，它可以为具体问题找到最恰当的类定义，并且可以在最恰当的继承级别解释问题。举例说明，莱丝在大多数时候都被当作一条狗，但是如果想要让它做牧羊犬做的事，你完全可以调用牧羊犬的方法。如果狗这个类还有动物的父类，那么你完全可以视莱丝为一个动物。
[编辑] OOP名词释意

编程范型 对于OOP的准确定义及其本意存在着不少争论。

通常，OOP被理解为一种将程序分解为封装数据及相关操作的模块而进行的编程方式。有别于其它编程方式，OOP中的与某数据类型相关的一系列操作都被有机地封装到该数据类型当中，而非散放于其外，因而OOP中的数据类型不仅有着状态，还有着相关的行为。OOP理论，及与之同名的OOP实践相结合创造出了新的一个编程架构；OOP思想被广泛认为是非常有用的，以致一套新的编程范型被创造了出来。（其它的编程范型例如函数式编程或过程式编程专注于程序运行的过程，而逻辑编程专注于引发程序代码执行的断言）

对面向模拟系统的语言（如：SIMULA 67）的研究及对高可靠性系统架构（如：高性能操作系统和CPU的架构）的研究最终导致了OOP的诞生。
[编辑] 物件導向的语言

支持部分或绝大部分面向对象特性的语言即可称为基于对象的或面向对象的语言。

早期，完全面向对象的语言主要包括Smalltalk等语言，目前较为流行的语言中有Java、C#、Eiffel等。随着软件工业的发展，比较早的程序導向的语言在近些年的发展中也纷纷吸收了许多物件導向的概念，比如C->C++，C->Objective-C，BASIC->Visual Basic->Visual Basic .NET，Pascal->Object Pascal，Ada->Ada95。
[编辑] 历史

计算机科学中对象和实例概念的最早萌芽可以追溯到麻省理工学院的PDP-1系统。这一系统大概是最早的基于容量架构（capability based architecture）的实际系统。另外1963年Ivan Sutherland的Sketchpad应用中也蕴含了同样的思想。对象作为编程实体最早是于1960年代由Simula 67语言引入思维。Simula这一语言是奧利-約翰·達爾和克利斯登·奈加特在挪威奥斯陆计算机中心为模拟环境而设计的。（据说，他们是为了模拟船只而设计的这种语言，并且对不同船只间属性的相互影响感兴趣。他们将不同的船只归纳为不同的类，而每一个对象，基于它的类，可以定义它自己的属性和行为。）这种办法是分析式程序的最早概念体现。在分析式程序中，我们将真实世界的对象映射到抽象的对象，这叫做“模拟”。Simula不仅引入了“类”的概念，还应用了实例这一思想——这可能是这些概念的最早应用。

20世纪70年代施乐PARC研究所发明的Smalltalk语言将面向对象程序设计的概念定义为，在基础运算中，对对象和消息的广泛应用。Smalltalk的创建者深受Simula 67的主要思想影响，但Smalltalk中的对象是完全动态的——它们可以被创建、修改并销毁，这与Simula中的静态对象有所区别。此外，Smalltalk还引入了继承性的思想，它因此一举超越了不可创建实例的程序设计模型和不具备继承性的Simula。

此外，Simula 67的思想亦被应用在许多不同的语言，如Lisp、Pascal。

面向对象程序设计在80年代成为了一种主导思想，这主要应归功于C++——C语言的扩充版。在图形用户界面（GUI）日渐崛起的情况下，面向对象程序设计很好地适应了潮流。GUI和面向对象程序设计的紧密关联在Mac OS X中可见一斑。Mac OS X是由Objective-C语言写成的，这一语言是一个仿Smalltalk的C语言扩充版。面向对象程序设计的思想也使事件处理式的程序设计更加广泛被应用（虽然这一概念并非仅存在于面向对象程序设计）。一种说法是，GUI的引入极大地推动了面向对象程序设计的发展。

在ETH Zürich（英文），Niklaus Wirth 和他的同事们对抽象数据和模块化程序设计进行了调查。Modula-2将这些都包括了进去，而Oberon则包括了一种特殊的面向对象方法——不同于Smalltalk与C++。

面向对象的特性也被加入了当时较为流行的语言：Ada、BASIC、Lisp、Fortran、Pascal以及种种。由于这些语言最初并没有面向对象的设计，故而这种糅合常常会导致兼容性和维护性的问题。与之相反的是，“纯正的”面向对象语言却缺乏一些程序员们赖以生存的特性。在这一大环境下，开发新的语言成为了当务之急。作为先行者，Eiffel成功地解决了这些问题，并成为了当时较受欢迎的语言。

在过去的几年中，Java语言成为了广为应用的语言，除了它与C和C++语法上的近似性。Java的可移植性是它的成功中不可磨灭的一步，因为这一特性，已吸引了庞大的程序员群的投入。

近日，一些既支持面向对象程序设计，又支持面向过程程序设计的语言悄然浮出水面。它们中的佼佼者有Python、Ruby等等.

正如面向过程程序设计使得结构化程序设计的技术得以提升，现代的面向对象程序设计方法使得对設計模式的用途、契約式設計和建模語言（如UML）技术也得到了一定提升。
[编辑] 腳本中的OOP

近年來，面向对象的程序设计越来越流行于[脚本语言]中。Python和Ruby是建立在OOP原理的腳本語言，Perl和PHP亦分別在Perl 5和PHP 4時加入物件導向特性。
[编辑] 参考文献

    ^ 《Object Oriented Programming》[1]，中科永联高级技术培训中心。
    ^ 《C++面向对象程序设计》，谭浩强，清华大学出版社，2006年1月第一版。ISBN:978-7-302-12315-6

[编辑] 相关内容
