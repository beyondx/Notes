Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2011-08-04T16:25:30+08:00

====== 数组、向量和表 ======
Created Thursday 04 August 2011
http://www.cnblogs.com/smallfa/archive/2008/04/07/1139853.html

**数组**
    数组不用多解释了，都了解，这里再重复一些重要的。

    随机这个词经常出现，在刚学的时候，都说数组在内存中是随机访问的，然而随机数又是随机（不确定）的，这两个概念总是搞不清楚。这里的随机访问与随机存储器的概念一样，google了也百度了，就是搞不到这个随机是什么意思，就只能按random本意来理解了，只好意会。

    大家都知道数组在内存中存放的方式，是顺序的，也就是在访问某个元素的时候，比如访问第五个元素[5]，只需要在开头地址加上偏移量，即5，就是第五个元素了。因为数组中存储的数据类型都是同一种的类型，它们在内存中的大小都是固定的，所以偏移量很好算。

    多维数组，很多人和我一样，到这里都会迷茫一下，二维数组不难想象，就像一张表，如果三维的话，就想象成一个魔方，是立方体，如果三维以上，就难了，不能根据这种思维定式去想象它的结构，了解它在内存中的方式就行了。

    看几个例子：
    

    链表的每个元素称为节点，每个结点都有两个单元，第一个就是数据项，存放数据，第二个称为链（或next链），它指向第二个元素的地址，以此类推，最后的一个元素指向NULL。
    
    这种单项列表，如果给表头或表尾添加元素的时候会有些不便，最好的办法就是加上表头和表尾了。

    一个带表头和表尾的单向链表：



    表头的数据元素是这个表的名字，例如上面那个表名是head，表头的链指向第一个节点，最后一个节点则指向尾节点。

    给表添加一个元素的时，以上边的head表为例，在A和B中间插入一个节点Y，则首先把A节点的链指向Y，然后将Y的链指向B。如果是删除一个结点的话，假设删除D节点，则只要将C节点链指向D节点的下一个节点，即E节点。是不是很简单，但问题又来了，每次插入或删除一个结点的时候，尤其是删除最后一个结点的时候，都得寻找它前面的节点，这就比较麻烦了，而双向链表则解决了这种问题。

    双向链表：


    可以看出，每个都在数据区前面都多了一个指向它前面节点的指针。我们把一个节点的后一个节点叫做直接后驱，它前面的一个结点叫做直接前驱。第一个节点没有直接前驱，所以为NULL，末尾节点没有直接后驱，也为NULL，这样在插入或删除一个节点的时候的就可以直接找到它的前后两个节点了。

    有时候为了方便查询，会让最后一个节点的后驱的next链指向第一个节点，这样的链表就叫做循环链表。

    当然，表不止有链表，还有别的，以后会学习到的。

    链表的优点就是可以不受内存单元的线性限制（比如数组），可以充分利用空间，缺点就是链表的存储密度不如数组或向量的高，密度当然是质量除以体积了，这里质量就是实际数据的大小，体积就是链表的大小，因为每个节点要额外存储链，所以链表的存储密度就相对小了 ，另外在链表很长时，操作一个节点就比较麻烦了，因为它在内存中不是连续的，所以得从头开始一个个找，效率就低了。


    大致算是解了数组、向量和链表，可以根据它们的特点再不同场合使用。
分类: [Net]:C#
