Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2012-06-15T21:14:56+08:00

====== jmp与call指令详解 ======
Created Friday 15 June 2012
http://blog.csdn.net/smallgeneral/article/details/6314473

最近看链接器源码中，对位置无关代码PIC（共享库）的链接问题，发现对call和jmp很多不常用的用法，这里试验并总结了一下各种用法。

我们最常用的jmp形式，就是 jmp后面跟个标签！这个没什么可说的！

假如标签叫做mylabel，它的地址是0x8048377，而且有个全局变量b，b存储的内容就是mylabel的地址，而b的地址是0x80494A8。
即有这样的赋值（加载）语句：
movl $mylabel,%eax //把__mylabel的地址__加载到eax寄存器中
movl %eax,b //把mylabel的地址加载到b中
movl $b,%ebx //把__b的地址__加载到ebx寄存器中

我们考虑下面的语句：
1. jmp mylable	//相对跳转，指令中保存由PC值与mylabel符号所在内存单元的偏移量。
2. jmp 0x8048377	//相对跳转，注意，0x8048337前没有$，所以表示的是一个内存单元地址，汇编器会把该地址与PC的差值放到指令中。


3. jmp %eax		   //和4一样，但是GAS会警告。
4. jmp *%eax    	   //绝对跳转，跳转到寄存器eax中保存的地址，是一个绝对跳转类型（4-7皆为绝对跳转）
5. jmp *(%ebx)  	   //从%ebx寄存器中指定的内存单元获得将要跳转到的地址，直接赋给EIP寄存器
6. jmp *0x80494A8   //跳转到地址为0x80494A8的指令处，即直接将该地址赋给EIP(即PC)寄存器。
7. jmp *b			  //同上，因为__标号即代表所在内存单元地址__
8. jmp $0x5		//错误

这7句jmp语句！分别都做了什么？

GAS根据指令的操作数前是__否有*号__，来判断该汇编语句应该被翻译为__相对跳转还是绝对跳转__：
1. 如果操作数前无星号，如上面的1-4所示，则被汇编器翻译为以e开头的相对跳转指令，即跳转的指令地址为__当前PC值+jmp指令后的偏移量__。偏移量有两种指定形式：
	* 标号形式。GAS会自动计算标号所在的虚拟地址与当前指令的PC值间的编译量，然后存到指令中。
	* 内存地址形式(注意不是立即数)，GAS会自动计算PC值与该内存地址的偏移量，然后将结果存到指令中。
2. 如果操作数前有星号，如上面的3-8，则被汇编器翻译为以ff开头的绝对跳转指令，即操作数所代表的地址直接赋给PC。

注意：linux很有限地使用了IA32的段机制：所有段的起始地址为0，大小为4GB，所以各个段的**段寄存器基本没有使用**，IP的值即为PC的值，而且不存在段间跳转的现象。

1. 不用说，跳转到mylabel标签处继续执行代码，但是，是如何跳转的呢？就是__PC加上了mylabel标签处对于jmp处的一个偏移地址__！可执行的二进制代码是这样表示的：eb 03，就是说，pc+0x03就可以了。

2. 这里，0x8048377是mylabel的地址，我以前研究过，标签的作用，于它的地址的作用是等效的。所以，这里的执行效果跟1中的相同。但是，还有些不一样！这里的二进制代码成了：e9 03 00 00 00 这里用了32位表示了这个偏移，而在1中，只用了8位！但是存在指令中的还是偏移量，而且指令以e开头还是相对跳转指令。

3. 在编译链接的时候，这句代码会有警告：warning:indirect jmp without '*'。间接跳转没有‘*’符号，但是执行起来，还是没有错。看一下二进制的可执行文件的代码，发现，给补上了个‘*’号！而且二进制是：__ff e0.__

4. 其实，4是3的补充版，__正常的形式就是4__，而三是有警告的被补充的版本。

5. %ebx是b的地址，那么(%ebx)表示ebx的值为地址，指向的地方。这里指向了b的内容，也就是mylabel的地址！于是，化简后，5也就等效与2，但是，二进制表示是：ff 23。

6. 0x80494A8是b的地址，这里看做内存数，那么实质上，b指向的值是mylabel的地址，于是，化简后同2，二进制代码是：ff 25 a8 94 04 08。

7. b是标签，代表一个地址，所以，这里同6，二进制代码也同6

8. 这句话是错误的，jmp不支持立即数！

所以说，正确的写法有：

1. jmp mylable 	//eb 03
2. jmp 0x8048377 	//e9 03 00 00 00

3. jmp *%eax //ff e0
4. jmp *(%ebx) //ff 23
5. jmp *0x80494A8 //ff 25 a8 94 04 08
6. jmp *b //ff 25 a8 94 04 08

1和2叫做__间接（相对）寻址__，就是算偏移量的。前面没有‘*’号，而是直接一个标签或者地址（__标签就可以看做是地址__），所以说，就是一个直接的地址值。间接跳转的二进制代码是eb或者e9，是**e开头**的。

3，4，5，6叫做__直接寻址__，__直接寻址的标识就是这个‘*’号__！直接寻址，就是PC（其实PC寄存器并不存在，在IA32中是EIP寄存器）__直接被赋值__某个地址，而不是加偏移量。所以，‘*’号后面的部分，其实是一个要赋给PC的值，那么取值的方式就好想象了！3是寄存器直接取值；4是寄存器间接取值；5是内存数取值；6是标签取值（实质上同5）。直接跳转的二进制代码是**ff开头**的。

call同jmp指令！
