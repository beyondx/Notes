Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2012-06-14T16:34:36+08:00

====== 第一讲 简述x86寻址演变 ======
Created Thursday 14 June 2012
http://www.kerneltravel.net/chenlj/

我们知道，操作系统是一组软件的集合。但它和一般软件不同，因为它是充分挖掘硬件潜能的软件，
也可以说，操作系统是横跨软件和硬件的桥梁。 因此，要想深入解析操作系统内在的运作机制，
就必须搞清楚相关的硬件机制——尤其是__内存寻址的硬件机制__。

操作系统的设计者必须在硬件相关的代码与硬件无关的代码之间划出清楚的界限，以便于一个操
作系统很容易地移植到不同的平台。Linux的设计就做到了这点，它把与硬件相关的代码全部放在
arch(architecture一词的缩写，即体系结构相关)的目录下，在这个目录下，可以找到 Linux 目前
版本支持的所有平台，例如，支持的平台有arm、 alpha,、 i386、 m68k、 mips等十多种。 
在这众多的平台中，大家最熟悉的就是i386，即Intel80386体系结构。因此，我们所介绍的内存寻
址也是以此为背景。

===== 1、 鼻祖图灵 =====

曾经有一个叫“阿兰.图灵”的天才（据说他16岁开始研究相对论，虽然英年早逝，但才
气纵横逻辑学、物理学、数学等多个领域，尤其是数学逻辑上的所作所为奠定了现代计算技术
的理论基础 。后来以他名字命名的“图灵奖”被看作计算机学界的最高荣誉）。他设想出了
一种简单但__运算能力几乎无限发达__的理想机器，这不是一个具体的机械设备，而是一个
__思想模型，__可以用来计算能想象得到的所有可计算函数。 这个有趣的机器由一个控制器，
一个读写头和一条假设两端无限长的带子组成。 工作带相当于存储器，被划分成**大小相同**
的格子，每格上可写一个字母，读写头可以在工作带上随意移动，而控制器可以要求读
写头读取其下方工作带上的字母。

这听起来仅仅是纸上谈兵，但它却是当代__冯.诺依曼计算机体系__的理论鼻祖。它带来的“__数据连续存__
__储和选择读取思想”__是目前我们使用的几乎所有机器运行背后的灵魂。 计算机体系结构中的核心问
题之一就是如何有效地进行内存寻址，因为所有运算的前提都是先要从内存中取得数据，所以内存
寻址技术从某种程度上代表了计算机技术的发展水平。

===== 2、 4位和8位处理器及寻址 =====
在微处理器的历史上，第一款微处理器芯片__4004__是由Intel推出的，那是一个4位的微处理器。
在4004之后，Intel推出了一款8位处理器__8080__，它有1个主累加器（寄存器A）和6个次累加器
（寄存器B,C,D,E,H和L），几个次累加器可以配对（如组成BC, DE或HL）用来访问16位的内存地址，
也就是说8080可访问到64K内的地址空间。


===== 3、 实模式－16位处理器及寻址 =====

几年后，Intel开发出了16位的处理器8086，这个处理器标志着Intel x86王朝的开始，这也是内存寻
址的第一次飞跃。之所以说这是一次飞跃，是因为8086处理器引入了一个__重要概念—段__。

8086处理器的寻址目标是__1M__大的内存空间，于是它的__地址总线扩展到了20位__。但是，一个问题摆在
了Intel设计人员面前，虽然地址总线宽度是20位的，但是CPU中“算术逻辑运算单元（ALU）”的宽度，
即__数据总线却只有16位__，也就是__可直接加以运算的指针长度是16位的。__

注意：之所以考虑ALU运算的宽度是因为__有效地址其实是通过运算获得的，然后放到程序计数器(PC)中,__
PC并没有一个实际的寄存器与之对应，它的值一般是：段地址+偏移量计算后获得的。

如何填补这个空隙呢？可能的解决方案有多种，例如，可以像一些8位CPU中那样，增设一些20位的指令
专用于__地址运算和操作__，但是那样又会造成CPU内存结构的不均匀。又例如，当时的PDP－11小型机也是
16位的，但是其内存管理单元（MMU）可以将16位的地址映射到24位的地址空间。受此启发，Intel设计
了一种在当时看来不失为巧妙的方法，即__分段的方法__。 

在微处理器的历史上，第一款微处理器芯片4004是由Intel推出的，那是一个4位的微处理器。在4004之后，
Intel推出了一款8位处理器8080，它有1个主累加器（寄存器A）和6个次累加器（寄存器B,C,D,E,H和L）,几
个次累加器可以配对（如组成BC, De或HL）用来访问16位的内存地址，也就是说8080可访问到64K内的地
址空间。 另外，那时还__没有段的概念__，访问内存都要通过__绝对地址__，因此程序中的地址必须进行硬编码（给
出具体地址），而且也难以重定位，这就不难理解为什么当时的软件大都是些可控性弱，结构简陋，数据处
理量小的工控程序了。引入分段机制后，指令可以使用__相对寻址方式。__例如jmp指令支持__段内的短跳转、段间__
__的长跳转__。当使用短跳转时，指令中只需指定目的地相对于当前PC值的偏移量即可；
具体可以参考：[[../../IA32汇编/jmp指令用ia法总结.txt]]

Intel开发出了16位的处理器8086，这个处理器标志着Intel x86王朝的开始。为了支持分段，Intel在8086 CPU
中设置了四个段寄存器：CS、 DS、 SS和ES，分别用于可执行__代码段、数据段、堆栈段及扩展段__。每个段寄存器
都是16位的，对应于__地址总线中的高16位__。

每条“访内”__指令中的内部地址__也都是16位的，但是在送上地址总线之前，CPU内部自动地把它与某个段寄存器中
的__内容相加__。 因为段寄存器中的内容对应于20位地址总线中的高16位(也就是把段寄存器左移4位)，所以相加时实
际上是内存总线中的高12位与段寄存器中的16位相加，而低4位保留不变，这样就形成一个20位的__线性地址__，也就
实现了从16位内存地址到20位实际地址的转换，或者叫“映射”。

* CS和IP寄存器是由转移指令（如jmp和call指令）设置和使用的。
* DS是由数据传送指令(如move指令)使用的。
* SS和SP是由PUSH和POP指令设置和使用的。

线性地址 = 段寄存器值<<4 + 偏移量

实模式下，当程序寻址超过0xFFFFF时，CPU将__“回滚”__至内__存地址起始处寻址__（注意：在只有20位地址线的条件下，
0xFFFFF + 1 = 0x00000，最高位溢出）。例如，系统的段寄存器（如CS）的最大允许地址为0xFFFF，指令指针（IP）
的最大允许段内偏移也为0xFFFF，两者确定的最大绝对地址为0x10FFEF，这将意味着程序中可产生的实模式下的寻址范
围比1MB多出将近64KB（一些有特殊寻址要求的程序就利用了这个特点）。

段式内存管理带来了显而易见的优势，程序的地址不再需要硬编码了，调试错误也更容易定位了，更可贵的是支持
更大的内存地址。程序员开始获得了自由。

不用硬编码的原因是：
* 对例程(子函数)而言，可以使用相对于PC的__段间偏移量__跳转。
* 对于数据而言，可以使用相对于DS的__偏移量__获取。

关于CS，DS，SS，IP和SP的使用，可以参考[[../../菜鸟学汇编.txt|《菜鸟学汇编》]]


===== 4、 保护模式－24位及32位寻址 =====

技术的发展不会就此止步。Intel的80286处理器于1982年问世了，它的地址总线位数增加到了24位，因此可以访问到
16M的内存空间。更重要的是从此开始引进了一个全新理念—__保护模式__。这种模式下内存段的访问受到了限制。访问
内存时__不能直接从段寄存器中获得段的起始地址了__，而需要经过额外转换和检查（从此你不能再随意存取数据段,具体保
护和实现我们后面讲述）。

为了和过去兼容，80286内存寻址可以有两种方式，一种是先进的__保护模式__，另一种是老式的8086方式，被成为__实模式__。
系统启动时处理器处于实模式，只能访问1M空间，经过处理可进入保护模式，访问空间扩大到16M，但是要想从保护模
式返回到实模式，你只有重新启动机器。还有一个致命的缺陷是80286虽然扩大了访问空间，但是__每个段的大小还是64k__，
程序规模仍受到限制。因此这个先天低能儿注定命不会很久。很快它就被天资卓越的兄弟——80386代替了。

80386是一个32位的CPU，也就是它的ALU数据总线是32位的，同时__它的地址总线与数据总线宽度一致__，也是32位，因此，
其寻址能力达到4GB。 对于内存来说，似乎是足够了。从理论上说，当数据总线与地址总线宽度一致时，其CPU结构应该
简洁明了。但是，80386无法做到这一点。作为x86产品系列的一员，80386必须维持那些段寄存器的存在，还必须支持实
模式，同时又要能支持保护模式，这给Intel的设计人员带来很大的挑战。

Intel选择了在段寄存器的基础上构筑保护模式，并且__保留段寄存器16位__。在保护模式下,它的__段范围不再受限于64K__，可以达
到4G（参见段机制一讲）。这一下真正解放了软件工程师，他们不必再费尽心思去压缩程序规模，软件功能也因此迅速提升。

从8086的16位到80386的32位处理器，这看起来是处理器位数的变化，但实质上是处理器体系结构的变化，从寻址方式上说，
就是从“实模式”到“保护模式”的变化。从80386以后，Intel的CPU经历了80486、Pentium、PentiumII、PentiumIII等型
号，虽然它们在速度上提高了好几个数量级，功能上也有不少改进，但基本上属于同一种系统结构的改进与加强，而无本质的变
化，所以我们把 80386以后的处理器统称为 __IA32__（32 Bit Intel Architecture）。
