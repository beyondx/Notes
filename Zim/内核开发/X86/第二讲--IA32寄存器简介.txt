Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2012-06-14T17:26:46+08:00

====== 第二讲--IA32寄存器简介 ======
Created Thursday 14 June 2012

IA32作为80x86系列中的一员，必须保证向后兼容，也就是说，既要支持 16位的处理器，也要支持32位的处理器。 在8086中，所有的寄存器都是16位的，下面我们来看一
下IA32中寄存器有何变化：

* 把16位的通用寄存器、标志寄存器以及指令指针寄存器扩充为32位的寄存器
* **段寄存器仍然为16位**。
* 增加4个32位的控制寄存器
* 增加4个系统地址寄存器
* 增加8个调式寄存器
* 增加2个测试寄存器


===== 一、通用寄存器 =====

 8个通用寄存器是8086寄存器的超集，它们的名称和用途分别为：
 EAX  一般用作累加器
 EBX  一般用作基址寄存器（Base）
 ECX  一般用来计数（Count）
 EDX  一般用来存放数据（Data）
 ESP  一般用作栈顶指针（Stack Pointer）
 EBP  一般用作基址指针（Base Pointer）
 ESI   一般用作源变址（Source Index）
 EDI   一般用作目标变址（Destinatin Index）

8个通用寄存器中通常各保存32位数据，但为了进行16位的操作并与16为机保持兼容，它们的低位部分被当成8个16位的寄存器，即**AX、 BX…DI**。 为了支持8位的操作，还进一步把EAX、 EBX、 ECX、 EDX这四个寄存器低位部分的16位，再分为8位一组的高位字节和低位字节两部分，作为 8个8位寄存器。这8个寄存器分别被命名为 **AH、BH、CH、DH**和**AL、 BL、 CL、 DL**。 

对8位或16位寄存器的操作只影响相应的寄存器。 例如，在做8位加法运算时，位7的进位并不传给目的寄存器的位9，而是把**标志寄存器**中的进位标志（CF）置位。 因此，这8个通用寄存器既可以支持1位、 8位、 16位和32位数据运算，也支持16位和32位存储器寻址。


===== 二、段寄存器 =====

8086中有4个16位的段寄存器：**CS、 DS、 SS、 ES**，分别用于存放可执行代码的代码段、数据段、 堆栈段和其他段的基地址。 在IA32中，有6个16位的段寄存器，但是，这些段寄存器中存放的不再是某个段的基地址，而是__某个段的选择符（Selector）__。 因为16位的寄存器无法存放32位的段基地址，段基地址只好存放在一个叫做__描述符表（Descriptor）__的表中。因此，在IA32中，我们__把段寄存器叫做选择符__。 下面给出6个段寄存器的名称和用途：

* CS  代码段寄存器
* DS  数据段寄存器
* SS  堆栈段寄存器
* ES、FS及GS  附加数据段寄存器

有关段选择符、描述符表及系统表地址寄存器将在段机制一节进行详细描述。
x86寻址机制的发展历史，可以参考：[[../I386的体系结构.txt]]

==== 三、状态和控制寄存器 ====
状态和控制寄存器是由标志寄存器 EFLAGS、指令指针EIP和4个控制寄存器组成，如图2.1所示：
 
			* EFLAGS		标志寄存器
			* __EIP		指令指针__
			* CR0		机器状态字
			* CR1		Intel保留
			* CR2		页故障线性地址
			* CR3		页目录地址

	  图2.1状态和控制寄存器

1.指令指针寄存器和标志寄存器

指令指针寄存器__EIP中存放下一条将要执行指令的偏移量（offset ），这个偏移量是相对于目前正在运行的代码段寄存器CS而言的__。偏移量加上当前代码段的基地址，就
形成了下一条指令的地址。 EIP中的低16位可以分开来进行访问，给它起名叫指令指针IP寄存器，用于16位寻址。CPU每取得下一条指令便将IP值加一，程序中可以使用跳转指令(jmp，call)等改变EIP中的值。

标志寄存器EFLAGS存放有关处理器的控制标志，如图2.2所示。标志寄存器中的第1、3、5、15位及18～31位都没有定义。
			{{./Selection_015.png}}                
			图2.2 i386标志寄存器EFLAGS
在这些标志位中，我们只介绍在Linux内核代码中常用且重要的几个标志位：
* 第8位TF（Trap Flag）是__自陷标志__，当将其置1时则可以进行__单步执行__。当指令执行完后，CPU就可能产生异常1的自陷（参看第四章）。也就是说，在程序的执行过程中，每执行完一条指令，都要由异常1处理程序 （在Linux内核中叫做debug()）进行检验。当将第8位清0后，且将__断点地址__装入__调试寄存器__DR0～DR3时，才会产生异常1的自陷。 

* 第12、 13位IOPL是__输入输出特权级位__，这是保护模式下要使用的两个标志位。 由于输入输出特权级标志共两位，它的取值范围只可能是0、 1、 2和3共4个值，恰好与输入输出特权级0～3级相对应。但__Linux内核只使用了两个级别即0和3级__，0表示内核级，3表示用户级。在__当前任务的特权级CPL__（Current Privilege Level）高于或等于输入输出特权级时，就可以执行像IN、OUT、INS、OUTS、STI、CLI和LOCK等__I/O指令__而不会产生异常13（即保护异常）。 在当前任务特权级CPL为0时，POPF（从栈中弹出至标志位）指令和中断返回指令IRET可以改变IOPL字段的值。

* 第 9 位 IF（Interrupt Flag）是__中断标志位__，是用来表示允许或者禁止外部中断（所有的中断，参看第四章）。 若第9位IF被置为1，则允许CPU接收外部中断请求信号；若将IF位清0，则表示禁止外部中断。 在保护模式下，只有当第12、 13位指出当前CPL为最高特权级时，才允许将新值置入标志寄存器EFLAGS以改变IF位的值。

* 第10位DF（Direction Flag）是定向标志。DF位规定了在执行串操作的过程中，对**源变址寄存器ESI或目标变址寄存器EDI**是增值还是减值。如果DF为1，则寄存器减值；若DF为0，则寄存器值增加。

* 第14位NT是__任务嵌套标志位__。在保护模式下常使用这个标志。当IA32在发生中断和执行CALL指令时就有可能引起**任务切换**。 若是由于中断或由于执行CALL指令而出现了任务切换，则将NT置为1。若没有任务切换，则将NT位清0。

* 第17位VM （Virtual 8086 Mode Flag）是__虚拟8086方式__标志，是IA32新设置的一个标志位。表示IA32CPU是在虚拟8086环境中运行。如果IA32CPU是在保护模式下运行，而 VM为又被置成 1，这时 IA32 就转换成虚拟 8086 操作方式，使全部段操作就像是在8086CPU上运行一样。 VM位只能由两种方式中的一种方式给予设置，即或者是在保护模式下，由最高特权级（0）级代码段的__中断返回指令 IRET__设置，或者是由任务转换进行设置。Linux内核实现了虚拟8086方式，但在本书中我们不准备对此进行详细讨论。

   从上面的介绍可以看出，要正确理解标志寄存器 EFLAGS的各个标志需要很多相关的知识，有些内容在本章的后续部分还会涉及到。 在后面的章节中，你会体会如何灵活应用这些标志。

2．控制寄存器
状态和控制寄存器组除了EFLAGS、EIP ，还有四个32位的控制寄存器，它们是CR0，CR1，CR2和CR3。现在我们详细看看它们的结构，如图 2－3所示。
{{./Selection_016.png}}
                    图 2－3 386中的控制寄存器组

这几个寄存器中__保存全局性和任务无关的机器状态__。

CR0中包含了6个预定义标志：
* 第0位是__保护允许位PE__(Protedted Enable)，用于启动保护模式，如果PE位置1，则保护模式启动，如果PE=0，则在实模式下运行。
* 第1位是__监控协处理位MP__(Moniter coprocessor)，它与第3位一起决定：当TS=1时操作码WAIT是否产生一个“协处理器不能使用”的出错信号。
* 第2位是__模拟协处理器位 EM__ (Emulate coprocessor)，如果EM=1，则不能使用协处理器，如果EM=0，则允许使用协处理器。 
* 第3位是任务转换位(Task Switch)，当一个任务转换完成之后，自动将它置1。 随着TS=1，就不能使用协处理器。
* 第4位是微处理器的__扩展类型位ET__(Processor Extension Type)，其内保存着处理器扩展类型的信息，如果ET=0，则标识系统使用的是287协处理器，如果 ET=1，则表示系统使用的是387浮点协处理器。
* 第31位是__分页允许位PE__(Paging Enable)，它表示芯片上的分页部件是否允许工作，下一节就会讲到。由PG位和PE位定义的操作方式如图2.4 所示。
{{./Selection_017.png}}
图 2－4   PG位和PE位定义的操作方式

CR1是未定义的控制寄存器，供将来的处理器使用。

CR2是页故障线性地址寄存器，保存__最后一次出现页故障的全32位线性地址__。

CR3是页目录基址寄存器，保存__页目录表的物理地址__，页目录表总是放在以4K字节为单位的存储器边界上，因此，它的地址的低12位总为0，不起作用，即使写上内容，也不会被理会。

这几个寄存器是与分页机制密切相关的，因此，在进程管理及虚拟内存管理中会涉及到这几个寄存器，读者要记住CR0、CR2及CR3这三个寄存器的内容。

四、系统地址寄存器
IA32有4个__系统地址寄存器__，如图2.5所示，它保存操作系统要保护的信息和地址转换表信息：
{{./Selection_018.png}}
     图2.5   IA32系统地址寄存器

* 全局描述符表寄存器GDTR（Global Descriptor Table Register ），是48位寄存器，用来保存全局描述符表（GDT）的32位基地址和16为GDT的界限。
* 中断描述符表寄存器IDTR（Interrupt Descriptor Table Register），是48位寄存器，用来保存中断描述符表（IDT）的32位基地址和16为IDT的界限。
* 局部描述符表寄存器LDTR（Global Descriptor Table Register ），是16位寄存器，保存局部描述符表LDT段的选择符。
* 任务状态寄存器TR（Task State Register）是16位寄存器，用于保存任务状态段TSS段的16位选择符。

用以上4个寄存器给目前正在执行的任务（或进程）定义__任务环境、 地址空间和中断向量空间__。 有关全局描述符表GST、 中断描述符表IDT、 局部描述符表LDT及任务状态段TSS的具体内容将在稍后进行详细描述。可以参考：[[../I386的体系结构.txt]]

五、 调试寄存器和测试寄存器
 1．调试寄存器
IA32__为调试提供了硬件支撑__。在IA32芯片内有8个32位的调试寄存器DR0~DR7：

  DR0		线性断点地址0
  DR1		线性断点地址1
  DR2		线性断点地址2  
  DR3		线性断点地址3
  DR4		Intel保留
  DR5 		Intel保留
  DR6 		断点状态
  DR7		断点控制

这些寄存器可以使系统程序设计人员__定义4个断点__，用它们可以规定指令执行和数据读写的任何组合。 
DR0~DR3是线性__断点地址__寄存器，其中保存着4个断点地址。 
DR4、 DR5是两个备用的调试寄存器，目前尚未定义。
DR6是__断点状态__寄存器，其低序位是指示符位，当允许故障调试并检查出故障而进入__异常调试处理程序__（debug()）时，由硬件把指示符位置1，调试异常处理程序在退出之前必须把这几位清0。 
DR7是__断点控制__寄存器，它的高序半个字又被分为4个字段，用来规定__断点字段的长度__是1个字节、2个字节、4个字节及规定将引起断点的访问类型。 低序半个字的位字段用于__“允许”断点__和“允许”所选择的调试条件。

2. 测试寄存器

IA32 有两个 32 位的__测试寄存器 TR6 和TR7__。这两个寄存器用于在转换旁视缓冲器（ Translation  Lookaside  Buffer ） 中测试随机存储器 （ RAM ） 和相联存储器（CAM）。 TR6是测试命令寄存器，其内存放测试控制命令。 TR7是数据寄存器，其内保存转换旁路缓冲器测试的数据。
