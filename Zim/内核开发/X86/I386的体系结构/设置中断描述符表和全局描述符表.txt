Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2012-06-14T15:00:40+08:00

====== 设置中断描述符表和全局描述符表 ======
Created Thursday 14 June 2012

==== 1.3.2　设置中断描述符表和全局描述符表 ====

__setup程序__继续为保护模式做准备，此时要通过setup程序自身提供的数据信息__对中断描述符表寄存器IDTR和全局描述符表寄存器GDTR__进行初始化设置。

小贴士

* GDT（Global Descriptor Table，全局描述符表）：它是系统中唯一存放段寄存器内容（**段描述符**）的数组，__配合程序进行保护模式下的段寻址__。它在操作系统的进程切换中具有重要意义，可理解为__所有进程的总目录表__，其中存放着__每一个任务（task）局部描述符表__（LDT，Local Descriptor Table）地址和__任务状态段__（TSS，Task Structure Segment）地址，用于完成进程中各段的寻址、现场保护与现场恢复。

* GDTR（Global Descriptor Table Register，GDT基地址寄存器）：GDT可以存放在内存的任何位置，当程序通过段寄存器引用一个段描述符时，需要取得GDT的入口， GDTR所标识的即为此入口。在操作系统对GDT的初始化完成后，可以用LGDT（Load GDT）指令将GDT基地址加载至GDTR。

* IDT（Interrupt Descriptor Table，中断描述符表）：保存__保护模式下所有中断服务程序的入口地址__，类似于__实模式下的中断向量表__。

* IDTR（Interrupt Descriptor Table Register，IDT基地址寄存器）：IDT基地址寄存器，保存IDT的起始地址。

内核实现代码如下：

    //代码路径：boot/setup.s  
     
    lidt    idt_48  
    lgdt    gdt_48  
     
    gdt:  
        .word   0,0,0,0     ! dummy  
     
        .word   0x07FF      ! 8Mb-limit=2047 (2048*4096=8Mb)  
        .word   0x0000      ! base address=0 
        .word   0x9A00      ! code read/exec  
        .word   0x00C0      ! granularity=4096, 386  
     
        .word   0x07FF      ! 8Mb-limit=2047 (2048*4096=8Mb)  
        .word   0x0000      ! base address=0 
        .word   0x9200      ! data read/write  
        .word   0x00C0      ! granularity=4096, 386  
     
    idt_48:  
        .word   0       ! idt limit=0 
        .word   0,0     ! idt base=0L 
     
    gdt_48:  
        .word   0x800       ! gdt limit=2048, 256 GDT entries  
        .word   512+gdt,0x9 ! gdt base = 0X9xxxx 

这些代码设置所需要的数据分别在idt_48和gdt_48所对应的标号处，它们与寄存器的对应方式如图1-18所示。
 {{./164632331.jpg}}
			图1-18　设置GDTR和IDTR


==== 点评 ====

32位的中断机制和16位的中断机制在原理上有比较大的差别，最明显的是16位的中断机制用的是__中断向量表__，中断向量表的起始位置在0x00000处，这个__位置是固定__的。32位的中断机制用的是__中断描述符表IDT__，__位置是不固定的__，可以由操作系统的设计者根据设计要求灵活安排，由IDTR寄存器来锁定其位置。

GDT表是保护模式下管理__段描述符__的数据结构，对操作系统自身的运行和管理，以及进程调度有重大意义，后面的章节会有详细讲解。

因为，此时此刻内核尚未真正运行起来，__还没有进程__，所以现在创建的GDT表的第一项为空，第二项为__内核代码段描述符__，第三项为__内核数据段描述符__，其余项皆为空。

IDT表虽然已经设置，__实为一张空表__，原因是目前已关中断，无须调用中断服务程序。此处反映的是数据“够用即得”的思想。

创建这两个表的过程可理解为是分两步进行的：

（1）在设计内核代码时，已经将两个表写好，并且把需要的数据也写好。
（2）将专用寄存器（IDTR和GDTR）指向表。

此处的数据区域是在内核源代码中设定和编译并直接加载至内存形成的一块数据区域。专用寄存器的指向由程序中的lidt指令和lgdt指令完成，具体操作见图1-18。

值得一提的是，在内存中做出数据的方法有两种：

（1）划分一块内存区域并初始化数据，“看住”这块内存区域，使之能被找到；
（2）由代码做出数据，如用push代码压栈，“做出”数据，此处采用的是第一种方法。

==== 1.3.3　打开A20，实现32位寻址 ====

下面的动作是标志性的—打开A20！

打开A20，意味着CPU可以进行32位寻址，最大寻址空间为4GB，注意看图1-19中内存条范围的变化。从5个F扩展到8个F，即0xFFFFFFFF—4GB。
 {{./164854860.jpg}}
图1-19　打开A20

现在看来，Linux 0.11还显得有些稚嫩，最大只能支持__16MB__的物理内存，但是其线性寻址空间已经是不折不扣的4GB。

打开A20的代码如下：

    //代码路径：boot/setup.s  
     
    call    empty_8042  
    mov al,#0xD1        ! command write  
    out #0x64,al  
    call    empty_8042  
    mov al,#0xDF        ! A20 on  
    out #0x60,al  
    call    empty_8042 

==== 点评 ====

实模式下CPU的寻址范围为0至0xFFFFF，共1MB寻址空间，需要0～19号共20根地址线。进入保护模式后，将使用32位寻址模式，即采用32根地址线进行寻址，第21根至第32根地址线的选通，将意味着__寻址模式的切换__。

实模式下，当程序寻址超过0xFFFFF时，CPU将“回滚”至内存地址起始处寻址（注意：在只有20位地址线的条件下，0xFFFFF + 1 = 0x00000，最高位溢出）。例如，系统的段寄存器（如CS）的最大允许地址为0xFFFF，__指令指针（IP）的最大允许段内偏移也为0xFFFF__，两者确定的最大绝对地址为0x10FFEF，这将意味着程序中可产生的实模式下的寻址范围比1MB多出将近64KB（一些有特殊寻址要求的程序就利用了这个特点）。这样，此处对A20地址线的启用相当于关闭了CPU在实模式下寻址的“回滚”机制。在后续代码中也将看到利用此特点来验证A20地址线是否确实已经打开。

IP为__指令指针寄存器__，它用来存放代码段中的偏移地址。在程序运行的过程中，它始终指向下一条指令的首地址，它与段寄存器CS联用确定下一条指令的物理地址。当“这一地址”送到存储器后，控制器可以取得下一条要执行的指令，而控制器一旦取得这条指令就马上修改IP的内容，使它指向下一条指令的首地址。

指令的有效地址=CS*10H+IP

------------------------------------------------------
最近看书时看到了“A20地址线”的问题，书上说，“这是一个历史问题”：
     
      在8086年代，只有20根地址线，只能寻址到1MB，而“段值：偏移”这种表示法能够表示的最大内存为10FFEEh(FFFF0   +   FFFF)，所以当寻址到超过1MB的内存时，会发生“回卷”（不会发生异常）。

      但是到了80286，真的可以访问到1MB以上的内存了，此时如果遇到“寻址超过1MB”的情况，系统不会再“回卷”了，这就造成了向上不兼容。

      所以呢，为了保证兼容，IBM想出了一个办法，就是“A20地址线”，如果不被打开，那么第20根地址线永远是0。

      但是看到这里，我心存疑惑，“不打开A20地址线”难道就能保证“寻址超过1MB时进行回卷”么？“不打开A20地址线”仅仅意味着第20根地址线总为0，但是第21根、第22根...第31根地址线并不为0啊，如果想保证“寻址超过1MB时进行回卷”，那必须保证“第20--31根地址线”全部为0才可以。如果按照我这种想法，“A20地址线”这个策略并不能保证“兼容性”啊？
      我想请教各位高手，我想的对不对呢？
