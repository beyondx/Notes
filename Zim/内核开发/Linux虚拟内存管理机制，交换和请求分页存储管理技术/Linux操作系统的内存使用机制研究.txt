Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2011-12-06T20:19:20+08:00

====== Linux操作系统的内存使用机制研究 ======
Created Tuesday 06 December 2011

http://www.bianceng.cn/OS/Linux/201111/31483.htm

linux的产生与发展，更多的应用与服务器，那么对于linux的各个管理机制要非常清楚，一个完整的linux系统主要有存储管理，内存管理，文件系统和进程管理等几方面组成，贴出一些以前学习过的一个很好的文章。与大家共享!

===== swap =====

Linux支持__虚拟内存__(virtual memory)，虚拟内存是指__使用磁盘当作RAM的扩展__，这样可用的内存的大小就相应地增大了。内核会将暂时不用的内存块的内容写到硬盘上，这样一来，这块内存就可用于其它目的。当需要用到原始的内容时，它们被重新读入内存。这些操作对用户来说是完全透明的;Linux下运行的程序只是看到有大量的内存可供使用而并没有注意到时不时它们的一部分是驻留在硬盘上的。当然，读写硬盘要比直接使用真实内存慢得多(要慢数千倍)，所以程序就不会象一直在内存中运行的那样快。用作虚拟内存的硬盘部分被称为__交换空间__(swap space)。

一般，在交换空间中的页面首先被换入内存;如果此时没有足够的物理内存来容纳, 它们又将被交换出来(到其他的交换空间中)。如果没有足够的虚拟内存来容纳所有这些页面，Linux就会波动而不正常;但经过一段较长的时间Linux会恢复，但此时系统已**不可用**了。

有时，尽管有许多的空闲内存，仍然会有许多的交换空间正被使用。这种情况是有可能发生的，例如如果在某一时刻有进行交换的必要，但后来一个占用很多物理内存的大进程结束并释放内存时。被交换出的数据并__不会自动__地交换进内存，除非有这个需要时。此时物理内存会在一段时间内保持空闲状态。对此并没有什么可担心的，但是知道了是怎么一回事，也就无所谓了。

注意，如果会有几个人同时使用这个系统，他们都将消耗内存。然而，如果两个人同时运行一个程序，内存消耗的总量并不是翻倍，因为代码页以及共享的库只存在一份。

Linux系统常常动不动就使用交换空间，以__保持尽可能多的空闲物理内存__。即使并没有什么事情需要内存，Linux也会交换出暂时不用的内存页面。这可以避免等待交换所需的时间：当磁盘闲着，就可以提前做好交换。

可以__将交换空间分散在几个硬盘之上__。针对相关磁盘的速度以及对磁盘的访问模式，这样做可以提高性能。

===== 高速缓冲 buffer cache =====

与访问(真正的)的内存相比，**磁盘的读写是很慢的**。另外，在相应较短的时间内**多次读磁盘同样的部分**也是常有的事。例如，某人也许首先阅读了一段e-mail消息，然后为了答复又将这段消息读入编辑器中，然后又在将这个消息拷贝到文件夹中时，使得邮件程序又一次读入它。或者考虑一下在一个有着许多用户的系统中 ls命令会被使用多少次。通过将信息从磁盘上仅读入一次并将其存于内存中，除了第一次读以外，可以加快所有其它读的速度。这叫作__磁盘缓冲__(disk buffering)，被用作此目的的内存称为__高速缓冲__(buffer cache)。

**磁盘中的文件可以被多个进程独立的打开，它们有不同的打开模式和读写偏移量。但是OS只在内存缓冲中保留一份文件的副本。**

但是，由于内存是一种有限而又不充足的资源，高速缓冲不可能做的很大(它不可能包容要用到的所有数据)。当缓冲充满了数据时，其中最长时间不用的数据将被__舍弃(对读文件而言)__以腾出内存空间用于新的数据。

对写磁盘操作来说磁盘缓冲技术同样有效。一方面，被写入磁盘的数据常常会很快地又被读出(例如，原代码文件被保存到一个文件中，又被编译器读入)，所以将要被写的数据放入缓冲中是个好主意。另一方面，通过将数据放入缓冲中，而不是将其立刻写入磁盘，程序可以加快运行的速度。以后，__写的操作可以在后台完成__，而不会拖延程序的执行。

大多数操作系统都有高速缓冲(尽管可能称呼不同)，但是并不是都遵守上面的原理。有些是__直接写__(write-through)：数据将被立刻写入磁盘(当然，数据也被放入缓存中)。如果写操作是在以后做的，那么该缓存被称为__后台写__(write-back)。后台写比直接写更有效，但也容易出错：如果机器崩溃，或者突然掉电，缓冲中改变过的数据就被丢失了。如果仍未被写入的数据含有重要的薄记信息，这甚至可能意味着文件系统(如果有的话)已不完整。

针对以上的原因，出现了很多的__日志文件系统__，数据在缓冲区修改后，同时会被文件系统记录修改信息，这样即使此时系统掉电，系统重启后会首先从日志记录中恢复数据，保证数据不丢失。当然这些问题不再本文的叙述范围。

由于上述原因，在使用适当的关闭过程之前，绝对不要关掉电源，__sync__命令倾空(flushes)缓冲，也即，强迫所有未被写的数据写入磁盘，可用以确定所有的写操作都已完成。在传统的UNIX系统中，有一个叫做update的程序运行于后台，每隔30秒做一次sync操作，因此通常无需手工使用sync命令了。Linux另外有一个后台程序，__bdflush__，这个程序执行更频繁的但不是全面的同步操作，以避免有时sync的大量磁盘I/O操作所带来的磁盘的突然冻结。

在Linux中，bdflush是由update启动的。通常没有理由来担心此事，但如果由于某些原因bdflush进程死掉了，内核会对此作出警告，此时你就要手工地启动它了(/sbin/update)。

缓存(cache)实际并不是缓冲文件的，而是__缓冲块__的，__块是磁盘I/O操作的最小单元 __(在Linux中，它们通常是4KB)。这样，目录、超级块、其它文件系统的薄记数据以及非文件系统的磁盘数据__都可以__被缓冲了。

缓冲的效力主要是由它的大小决定的。缓冲太小的话等于没用：

* 它只能容纳一点数据，因此在被重用时，所有缓冲的数据都将被倾空。实际的大小依赖于数据读写的频次、相同数据被访问的频率。只有用实验的方法才能知道。
* 如果缓存有固定的大小，那么缓存太大了也不好，因为这会使得空闲的内存太小而导致进行交换操作(这同样是慢的)。为了最有效地使用实际内存，Linux自动地使用所有空闲的内存作为高速缓冲，当程序需要更多的内存时，它也会自动地减小缓冲的大小。

这就是一般情况下linux内存的一般机制，当然linux内存的运行机制远远比这个复杂，但是只有了解了这个机制，我们管理服务器才能得心应手!
