Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2012-06-16T10:49:01+08:00

====== 启动过程 ======
Created Saturday 16 June 2012

1. bootsect.S
系统引导程序，一般不超过512字节。

在PC系统结构中，线性地址0xA0000以上，即640K以上用于__图形接口卡和BIOS自身(这部分内存被预留，不能自由使用。现在已经很少使用这些图形卡，但是不管是什么图形卡，开机时总是工作于EGA或VGA模式__。__从0xF0000开始到0xFFFFF，即最高的4KB为BIOS使用)__，640K以下为__系统基本内存，可以自由使用__。如果配置更多的内存，则0x100000，即__1MB处开始称为高内存。(这些名称都是历史遗留的，以前系统的内存非常小，一般小于1MB。)__

系统在启动和引导时只能使用0-0xA0000范围内的640KB系统基本内存。

当BIOS引导一个系统时，总是把**引导扇区(bootsector)**读入到基本内存地址为__0x7c00__的地方，然后跳转到此执行引导扇区的代码。这段代码将自身搬运到__0x90000__处，并跳转到那继续执行，然后通过BIOS提供的读磁盘读写中断服务“int 0x13”从磁盘上__读入setup和内核映像__。其中setup的映像读入到__0x90200__处，内核压缩过的映像存在__0x10000或0x100000__处，然后跳转到setup的代码中。实际上setup和内核映像是**做在一起**的，bootloader负责将它们分开后加载到不同的内存地址处。

从0x90000到0xA0000一共64K，bootsect仅占512字节，所以setup大小理论上可到63.5KB(从0x90__200__-0xA0000)。

在Linux2.4版本以前，在最前面的512字节里保存了一个mini “boot loader”，只要拷贝启动代码运行就可从**软盘**启动；但在2.6版本中__不再保存__这样的”bootloader”，所以必须在第一个磁盘的__MBR__上存储一个合适的boot loader才能从软盘启动，软盘、硬盘和光驱启动都是一样的过程，MBR中的内容由BIOS负责读取。

2. setup
进行映像的解压缩，从BIOS收集一些数据，在控制台显示一些信息。

基本内存中开头一部分空间是保留给BIOS自己用的，另一方面对于Linux内核的引导也需要保留一些运行空间，一共预留了开头的2*64KB=128KB。基本内存中用于内核映像的就是8*64K=512K(基本内存是0-0xA0000,去掉开头保留的128KB，**压缩的内核映像从0x10000开始**)，其中顶端留4K用于引导命令行及从BIOS获取需要传递给内核的数据。内核映像一般都经过压缩，压缩后的映像和引导扇区及辅助引导程序的映像拼接在一起，成为__内核的引导映像__。大小不超过508K的映像称为__小映像zImage__，早期版本放在0x10000位置处，否则称为__大内核bzImage__，放在0x100000位置处。

CPU在bootsect时处于__16位实地址模式__，然后在setup的执行过程中转入__32位保护模式__。注意，这时还没有启用分页机制，__逻辑地址通过段机制直接转换为线性物理地址__。setup从BIOS中读取系统数据（内存大小及映射情况、显卡模式、磁盘等参数），将数据保存在0x90000-0x901FF(正好512字节)，覆盖了bootsect的内容。

设置32位运行方式（没有使用分页机制）：
1) 加载中断描述表寄存器IDTR、全局描述表寄存器GDTR；linux内核很简单地使用了CPU提供的段机制：[[../../X86/第四讲--段机制及linux实现.txt]]
2)临时设置IDT表和GDT表，并在GDT表中**设置内核代码段和数据段的描述符**，在Head.S中会根据内核的需要重新设置这些描述符表；
3)开启A20地址线； 这里A20表示开启__第20根地址线__，这意味着寻址能力在1MB以上。
4)重新设置两个中断控制器8259A，将硬件中断号重新设置为0x20和0x2f；
5)最后设置CPU的控制寄存器CR0（机器状态字）的保护模式比特（PE）位，从而进入32位保护模式运行；
6)然后跳转到head.S中的startup_32执行。

* 对于小内核映像放在0x10000处，Setup会把system从0x10000移到__0x0000__开始处。
* 对于大内核映像，vmlinux中普通内核代码被编译成以__PAGE_OFFSET+1MB__为起始地址（__编译器在编译内核时对符号的引用使用的都是虚拟地址__），在Head.S中初始化代码把虚拟地址减去PAGE_OFFSET就能得到以1MB为起始位置的物理地址，这也正是内核映像在物理内存中的存放位置。

Head.S中的__startup_32__主要用于**开启页面单元**。初始化工作在编译过程中开始进行，它先定义一个称为swapper_pg_dir的数组，使用链接器指示在地址__0x00101000__。然后分别为两个页面pg0和pg1创建页表项。第一组指向pg0和pg1的指针放在能覆盖1～9MB内存的位置，第二组指针放在PAGE_OFFSET+1MB的位置。一旦开始页机制，在上述页表和页表项指针建立后可以保证，在内核映像中不论是采用物理地址还是虚拟地址，都可以进行正确的页面映射。内核其他部分的页表初始化在paging_init()中完成。映射建立后，通过设置cr0寄存器中的某位开启页面映射，然后通过一个跳转指令保证指令指针的正确性。可参考：[[../../X86/第八讲--linux内存初始化之一启用分页机制.txt]]
 
1．Bootsect启动过程：
假设用LILO启动，启动时用户可以选择启动哪个操作系统。LILO将boot loader分为两部分，一部分放到启动分区的第一个扇区；
1)        BIOS将MBR或启动分区的第一个扇区的启动部分加载到地址__0x00007c00__处；
2)        该程序__将自身移到0x00096a00__，建立实模式栈(从0x00098000到0x000969ff)，将LILO的第二部分加载到__0x00096c00__处，然后跳转到此执行；
3)        然后第二部分程序从磁盘读取一个可启动的操作系统列表让用户选择，最后用户选择每个OS后，boot loader可以拷贝不启动分区或者直接拷贝内核映像到RAM中去；
4)        加载Linux内核映像时，LILO boot loader首先调用**BIOS显示中断服务例程**显示”Loading …”信息；
5)        调用BIOS例程加载**内核映像的初始化部分**到RAM上，内核映像的前512字节放在0x00090000位置，__setup()函数代码放在0x00090200位置__；
6)        接着调用BIOS例程__装载内核映像的其余部分__，映像可能放在低地址0x00010000(使用make zImage编译的小内核映像)或者高地址__0x00100000__（使用make bzImage编译的大内核映像）。
7)        然后跳至刚刚setup部分。
 
2．Setup.S分析
setup()汇编函数被__连接器__放在__内核映像文件中的0x200偏移处__。Setup函数必须__初始化计算机中的硬件设备并为内核程序的执行建立环境__。
1)        在ACPI兼容的系统中，调用BIOS例程建立描述**系统物理内存布局的表(BIOS-e820表)**。在早期系统中，它调用BIOS例程返回系统可以用RAM大小；
2)        设置键盘的重复延迟和速率；
3)        **初始化显卡**；
4)        检测IBM MCA总线、PS/2鼠标设备、__APM__ BIOS支持等；
5)        如果BIOS支持Enhanced Disk Drive Services (EDD)，将调用正确的BIOS例程建立描述系统可用硬盘的表；
6)        如果内核加载在低RAM地址0x00010000，则把它移动到0x00001000处；如果映像加载在高内存1M位置，则不动；
7)        启动位于8042键盘控制器的A20 pin。
8)        建立一个中断描述表IDT和全局描述表GDT表；
9)        如果有的话，重启FPU单元；
10)     对可编程中断控制器进行重新编程，**屏蔽所有中断**，级连PIC的IRQ2不需要；
11)    设置CR0状态寄存器的PE位使CPU从实模式切换到保护模式，PG位清0，__禁止分页功能__；
12)    跳转到startup_32()汇编函数, jmpi 0x100000, __BOOT_CS，终于进入内核Head.S；
 
3．Head.S分析
有两个不同的**startup_32()**函数，一个在arch/i386/__boot/compressed/head.S__文件中，setup结束后，该函数被放在0x00001000或者__0x00100000__位置，该函数主要操作：
1)        首先初始化段寄存器和临时堆栈；
2)        清除eflags寄存器的所有位；
3)        将_edata和_end区间的所有内核未初始化区填充0；
4)        调用decompress_kernel( )函数__解压内核映像__。首先显示"Uncompressing Linux..."信息，解压完成后显示 "OK, booting the kernel."。内核解压后，如果是低地址载入，则放在0x00100000位置；否则解压后的映像先放在压缩映像后的临时缓存里，最后解压后的映像被放置到物理位置0x00100000处；
5)        跳转到__0x00100000物理内存__处执行；
   
解压后的映像开始于arch/i386/__kernel/head.S__ 文件中的startup_32()函数，因为__通过物理地址的跳转执行该函数__的，所以相同的函数名并没有什么问题。该函数为Linux第一个进程建立执行环境，操作如下：
1)         初始化ds,es,fs,gs段寄存器的最终值；
2)        用0填充内核bss段；
3)        初始化__swapper_pg_dir__数组和pg0包含的临时内核页表：
l          将swapper_pg_dir（0x1000)和pg0(0x2000)清空，swapper_pg_dir作为整个系统的页目录；
l          将pg0作为第一个页表，将其地址赋到swapper_pg_dir的第一个32位字中。
l          同时将该页表项也赋给swapper_pg_dir的第3072个入口，表示虚拟地址0xc0000000也指向pg0。
l          将pg0这个页表填满指向内存前4M。
l          在cr3寄存器中存放PGD的地址，并设置cr0寄存器中的PG位，启用分页支持。上述过程可参考：[[../../X86/第八讲--linux内存初始化之一启用分页机制.txt]]
4)        建立进程__idle进程__的内核模式的堆栈；
5)        再次清除eflags寄存器的所有位；
6)        调用setup_idt()用非空的__中断处理函数填充IDT表__；
7)        __将从BIOS获取的系统参数传递到操作系统的第一个页面帧；即0页__
8)        识别处理器的模式；
9)        将GDT和IDT表的地址加载到gdtr和idtr寄存器中；
10)      跳转到start_kernel函数，这个函数是第一个C编制的函数，内核又有了一个新的开始。
 
4．start_kernel()分析：
1)        调度器初始化，调用sched_init();
2)        调用build_all_zonelists函数初始化内存区；
3)        调用page_alloc_init()和mem_init()初始化伙伴系统分配器；
4)        调用trap_init()和init_IRQ()对中断控制表IDT进行最后的初始化；
5)        调用softirq_init() 初始化TASKLET_SOFTIRQ和HI_SOFTIRQ；
6)        Time_init()对系统日期和时间进行初始化；
7)        调用kmem_cache_init()初始化slab分配器；
8)        调用calibrate_delay()计算CPU时钟频率；
通过调用__kernel_thread()__启动进程1init进程的内核线程，然后该线程再创建其他的内核线程执行/sbin/init程序。  


  
