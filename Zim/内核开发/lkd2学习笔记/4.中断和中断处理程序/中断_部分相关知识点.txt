Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2011-06-23T23:57:11+08:00

====== 中断 部分相关知识点 ======
Created 星期四 23 六月 2011
http://blogold.chinaunix.net/u2/83905/showart_1723905.html

连着几天零零散散的看了些中断相关的东西,虽然还没有大体上对其把握,但是也算有了一些最基本的了解.整理了一下草纸,写上来,当作自己对中断的入门篇.
 
1,devices和kernel间的交互的两种方法:
1)polling:由内核发起,每隔一段时间内核都会查看devices的状态信息,以识别是否有device有消息要通知内核.
2)interrupt:由device发起,当device有消息要通知内核时,device发送一个硬件信号,通常是一个中断.
 
2
NIC需要被分配一个IRQ,以便在需要时通过IRQ引起内核的注意,虚设备一般则不需要.一个device在申请一个IRQ时,不但要指明所申请的中断号,相应的处理函数,还要说明自己是否支持中断号共享.
当内核接到一个中断通知,内核将根据中断号找出设备注册的中断处理函数,然后执行此函数.内核在一个global table里存储这种映射关系,这种映射关系可以是一对一的,也可以是一对多的,因为内核允许多个device共享一个中断号.
 
3,申请和释放中断号
申请:
int request_irq(unsigned int irq,void(* handler)(int,void *,struct ptreqs *),unsigned long irqflags,const char *devname,void *dev_id)
释放:
void free_irq(unsigned int irq,void *dev_id)
 
4,中断号和中断处理函数在内核里的组织情况

如图所示
{{./1.jpg}}
irq_desc为一全局链表,所存储的内容就是中断号和中断处理函数的对应关系
当多个device共享一个IRQ时,需要有SA_SHIRQ这个标志.
 
5,产生中断后的基本过程
在最简单的情况下,当硬件产生一个中断时,大体执行过程如下:
1)设备产生一个中断,然后通知内核.
2)如果内核没有在处理其他中断,内核将会注意到这个通知.
3)内核禁用所有中断,然后调用这个中断相应的处理函数.
4)执行完后,使能其他中断.
由于cpu在处理一个中断的时候不能处理别的中断,是不可抢占的,所以应该尽可能的缩短中断的处理时间.所以一般情况下,中断处理程序由两部分组成:a top half和a bottom half.
此时,大体执行步骤如下:
1)设备通知内核有中断发生.
2)内核执行相关的顶半部处理函数,并禁止其他中断.
3)顶半部函数的一般处理过程如下:
  3.1:把所有信息存储在某个RAM中.
  3.2:做一个标记,随后内核处理时可根据此标记找到相应的中断类型和一些有用的数据.
  3.3:使能中断.
4)内核根据上步中做的标记调用相应的底半部处理函数,然后清除该标志,以便以后在顶半部处理函数再次设置该标志时可以识别出来.
总的来说,顶半部处理函数要比底半部处理函数的优先级高.
在2.4以后,底半部处理函数即为软中断.
 
6,网络部分中用到的软中断.
open_softirq(NET_TX_SOFTIRQ,net_tx_action,NULL)
open_softirq(NET_RX_SOFTIRQ,net_rx_action,NULL)
NET_TX_SOFTIRQ为发送软中断.net_tx_action为相应的软中断处理函数.
NET_RX_SOFTIRQ为接收软中断.net_rx_action为相应的软中断处理函数.
open_softirq为软中断的注册函数.
这两个注册在net_dev_init中初始化.
 
以上这些东西只是最基本,最简单的东西,关于中断的东西很复杂,对于自己,只要能把跟网卡驱动相关的中断搞明白就ok了,以后研究网卡源代码时在对中断进行更深入研究.
 
以上纯属个人对中断的理解,难免会有理解错的可能,如有看到错误的朋友,希望及时指出,不胜感激.

