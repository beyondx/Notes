Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2012-02-29T15:48:52+08:00

====== linux中的 IO端口映射和IO内存映射 ======
Created Wednesday 29 February 2012
http://blog.csdn.net/zyhorse2010/article/details/6590488

下面是今天看到两篇关于linux中的 IO端口映射和IO内存映射的文章,时间关系,没来得及深入理解,有空好好看看

===== CPU地址空间 =====

==== （一）地址的概念 ====

__1）物理地址__：CPU地址总线传来的地址，__由硬件电路控制其具体含义__。物理地址中很大一部分是留给内存条中的内存的，但也常被映射到其他存储器上 （如显存、BIOS等）。在**程序指令中的虚拟地址**经过段映射和页面映射后，就生成了物理地址，这个物理地址被放到CPU的地址线上。

__物理地址空间，一部分给物理RAM（内存）用，一部分给总线用，这是由硬件设计来决定的__，因此在32 bits地址线的x86处理器中，物理地址空间是2的32次方，即4GB，但物理RAM一般不能上到4GB，因为**还有一部分要给总线用**（总线上还挂着别的许多设备）。在PC机中，一般是把低端物理地址给RAM用，__高端物理地址给总线用__。
 
__2）总线地址__：总线的地址线是在地址周期上产生的信号。__外设使用的是总线地址，CPU使用的是物理地址。__

物理地址与总线地址之间的关系由**系统的设计**决定的。__在x86平台上，物理地址就是总线地址，这是因为它们共享相同的地址空间__——这句话有点难理解，详见下 面的“独立编址”。在其他平台上，可能**需要转换/映射**。比如：CPU需要访问物理地址是0xfa000的单元，那么在x86平台上，会产生一个PCI总线上对0xfa000地址的访问。因为物理地址和总线地址相同，所以**凭眼睛看是不能确定这个地址是用在哪儿的**，它或者在内存中，或者是某个卡上的存储单元， 甚至可能这个地址上没有对应的存储器。

__3）虚拟地址__：现代操作系统普遍采用**虚拟内存管理**（Virtual Memory Management）机制，这需要__MMU__（Memory Management Unit）的支持。MMU通常是CPU的一部分，如果处理器没有MMU，或者有MMU但没有启用，CPU执行单元发出的内存地址将**直接传到芯片引脚上**，被内存芯片（物理内存）接收，这称为物理地址（Physical Address），如果处理器启用了MMU，CPU执行单元发出的内存地址将__被MMU截获__，从CPU到MMU的地址称为**虚拟地址**（Virtual Address），而MMU将这个地址翻译成另一个地址发到CPU芯片的外部地址引脚上，也就是将虚拟地址映射成物理地址。

Linux中，进程的4GB（虚拟）内存分为__用户空间、内核空间__。用户空间分布为0~3GB（即PAGE_OFFSET，在0X86中它等于 0xC0000000），剩下的1G为内核空间。程序员只能使用虚拟地址。系统中每个进程有各自的私有用户空间（0～3G），这个空间对系统中的其**他进程是不可见**的。

CPU发出取指令请求时的地址是__当前上下文的虚拟地址__，MMU再从__页表__中找到这个虚拟地址的物理地址，完成取指。同样读取数据的也是虚拟地址，比如mov ax, var. 编译时var就是一个虚拟地址，也是通过MMU从也表中来找到物理地址，再产生**总线时序**，完成取数据的。


===== （二）编址方式 =====

1）外设都是通过__读写设备上的寄存器__来进行的，__外设寄存器也称为“I/O端口”__，而IO端口有两种编址方式：**独立编址和统一编制**。

* 统一编址：外设接口中的IO寄存器（即IO端口）__与主存单元一样看待__，每个端口__占用一个存储单元的地址，将主存的一部分划出来用作IO地址空间__，如，在 PDP-11中，把最高的4K主存作为IO设备寄存器地址。端口占用了存储器的地址空间，使存储量容量减小。 统一编址也称为__“I/O内存或memory-mapped”__方式，外设寄存器位于“内存空间”（很多外设有自己的内存、缓冲区，**外设的寄存器和内存统称“I/O空间”**）。

如，Samsung的S3C2440，是32位ARM处理器，它的__4GB地址空间被外设、RAM等瓜分__：

0x8000 1000   				LED 8*8点阵的地址
0x4800 0000 ~ 0x6000 0000  	SFR（特殊暂存器）地址空间
0x3800 1002   				键盘地址
0x3000 0000 ~ 0x3400 0000  	SDRAM空间 
0x2000 0020 ~ 0x2000 002e  	IDE
0x1900 0300  				CS8900

* 独立编址（单独编址）：IO地址与RAM存储地址分开独立编址，__I/0端口地址不占用存储空间的地址范围__，这样，在系统中就存在了__另一种与存储地址无关的IO地址__，CPU也必须具有__专用与输入输出操作的IO指令（IN、OUT等）和控制逻辑__。独立编址下，地址总线上过来一个地址，设备不知道是给IO端口的、还是给存储器的，于是处理器通过**MEMR/MEMW和IOR/IOW 两组控制信号**来实现__对I/O端口和存储器的不同寻址__。如，intel 80x86就采用单独编址，CPU内存和I/O是一起编址的，就是说__内存一部分的地址和I/O地址是重叠的,但是通过不同的IO操作指令来区分它们__。独立编址也称为“I/O端口”或I/O mapped方式，外设寄存器位于“I/O（地址）空间”。

对于x86架构来说，通过IN/OUT指令访问。PC架构一共有65536个**8bit**的I/O端口，组成__64K个I/O地址空间__，编号从 0~0xFFFF，有16位，80x86**用低16位地址线A0-A15来寻址**。连续两个8bit的端口可以组成一个**16bit的端口**，连续4个组成一个 **32bit的端口**。I/O地址空间和CPU的物理地址空间是两个不同的概念，例如I/O地址空间为64K，一个32bit的CPU物理地址空间是4G。 如，在Intel 8086+Redhat9.0 下用“more /proc/__ioports__”可看到：

0000-001f : dma1
0020-003f : pic1
0040-005f : timer
0060-006f : keyboard
0070-007f : rtc
0080-008f : dma page reg
00a0-00bf : pic2
00c0-00df : dma2
00f0-00ff : fpu
0170-0177 : ide1
……

不过Intel x86平台普通使用了名为__内存映射（MMIO，memory mapped I/O）的技术__，该技术是**PCI规范**的一部分，__IO设备端口被映射到内存空间__，映射后，**CPU访问IO端口就如同访问内存一样**。看Intel TA 719文档给出的x86/x64系统典型内存地址分配表：

系统资源  			占用
------------------------------------------------------------------------
BIOS  			1M
本地APIC  		4K
芯片组保留 		2M
IO APIC  			4K
PCI设备  			256M
PCI Express设备 	256M
PCI设备（可选） 	256M
显示帧缓存 		16M
TSEG  			1M

**注意，MMIO技术映射到的内存空间只是一个方便编程的“假象”，系统将I/O port映射到“物理”内存(需要使用ioport_map函数，这种映射关系是确定的，**__需要遵守PCI规范__**，与操作系统无关，OS需要之需要知道独立编址的I/O端口地址即可)，然后内核将映射到的内存转换为程序使用的虚拟地址。**

__真正访问底层设备寄存器端口的流程是：虚拟地址（这个是特殊的虚拟地址，用 ioremap函数映射）--->设备I/O端口映射到的物理内存地址（MMU，物理内存地址由ioport_map得到）---->独立编址的I/O 端口地址(0x0 ~ 0xFFFF)---->通过MEMR/MEMW和IOR/IOW 两组控制信号中的后面一组使能设备----->通过特殊指令访问它们。__

对于某一既定的系统，它要么是独立编址、要么是统一编址，具体采用哪一种则__取决于CPU的体系结构__。 如，**PowerPC、m68k, ARM等采用统一编址**，而**X86等则采用独立编址**，存在__IO空间__的概念。目前，大多数嵌入式微控制器如ARM、PowerPC等并不提供I/O空间，__仅有内存空间__，可直接**用地址、指针访问设备的寄存器**。

但对于Linux内核而言，它可能用于不同的CPU，所以它必须都要考虑这两种方式，于是它采用一种新的方法，将基于I/O映射方式的或内存映射方式的__I/O端口通称为“I/O区域”（I/O region）__，不论你采用哪种方式，都要先申请IO区域：request_resource()，结束时释放 它：release_resource()。
 

===== 2）对外设的访问 =====

==== 1、访问I/O内存(统一编址系统) ====
基本流程是：request_mem_region() ->** ioremap() **-> ioread8()/iowrite8() ->** iounmap() **-> release_mem_region() 。

前面说过，__IO内存是统一编址下的概念__，对于统一编址，**IO地址空间是物理主存的一部分**，__对于编程而言，我们只能操作虚拟内存__，所以，访问的第一步就是要把**设备所处的物理地址映射到虚拟地址**，Linux2.6下用ioremap():

        void *ioremap(unsigned long **offset**, unsigned long size);  //offset为**设备寄存器的物理地址**。

然后，我们__可以直接通过指针来访问这些地址__，但是也可以用Linux内核的一组函数来读写：

ioread8(), iowrite16(), ioread8_rep(), iowrite8_rep()......

==== 2、访问I/O端口(独立编址系统) ====
访问IO端口有2种途径：**I/O映射方式（I/O－mapped）、内存映射方式（Memory－mapped）**。__前一种途径不映射到内存空间，直接使用 intb()/outb()之类的函数来读写IO端口； __后一种__MMIO__是**先把IO端口映射到IO内存**，再__使用访问IO内存的函数来访问 IO端口__。

        void ioport_map(unsigned long port, unsigned int count);

通过这个函数，可以把port开始的count个__连续的IO端口映射为一段“内存空间”__，然后就可以在其返回的地址是**像访问IO内存一样访问这些IO端口**。
  
__内存映射方式，将访问I/O端口与访问I/O内存相统一。__

===== Linux下的IO端口和IO内存 =====
 
CPU对**外设端口**__物理地址的编址__方式有两种：一种是IO映射方式，另一种是内存映射方式。

Linux将基于IO映射方式的和内存映射方式的IO端口//统称为//__IO区域（IO region）__。IO region仍然是一种IO资源，因此它仍然可以用resource结构类型来描述。

* ===== 对I/O 映射资源的访问 =====

1) request_region()
　　把一个给定区间的IO端口分配给一个IO设备。
2) check_region()
　　检查一个给定区间的IO端口是否空闲，或者其中一些是否已经分配给某个IO设备。
3) release_region()
	释放以前分配给一个IO设备的给定区间的IO端口。

* Linux中可以通过以下辅助函数来__访问IO端口__：

　　inb(),inw(),inl(),outb(),outw(),outl()

“b”“w”“l”分别代表8位，16位，32位。

===== • 对内存映射资源的访问 =====

1) request_mem_region()
　	请求分配指定的IO内存资源。
2) check_mem_region()
	检查指定的IO内存资源是否已被占用。
3) release_mem_region()
	 释放指定的IO内存资源。

其中传给函数的start address参数是__内存区的物理地址(统一编址后的物理地址)__（以上函数参数表已省略）。驱动开发人员可以将**内存映射方式**的IO端口和外设内存**统一看作是IO内存资源**。

ioremap()用来**将IO资源的物理地址映射到**__内核虚地址空间__（3GB - 4GB）中，参数addr是指向内核虚地址的指针。

Linux中可以通过以下辅助函数来访问IO内存资源：

　　readb(),readw(),readl(),writeb(),writew(),writel()。

Linux在kernel/resource.c文件中定义了全局变量__ioport_resource和iomem_resource__，来分别描述__基于端口映射方式__的整个IO端口空间和__基于内存映射方式__的IO内存资源空间（包括IO端口和外设内存RAM）。

==== 1）关于IO空间与内存空间： ====

在X86处理器中存在着__I/O空间__的概念，I/O空间是相对于内存空间而言的，它通过特定的指令in、out来访问。__端口号标识了外设的寄存器地址__。Intel语法的in、out指令格式为：

    IN 累加器, {端口号│DX}
    OUT {端口号│DX},累加器

目前，大多数嵌入式微控制器如ARM、PowerPC等中并__不提供I/O空间__，而__仅存在内存空间__。内存空间可以直接通过地址、指针来访问，程序和程序运行中使用的变量和其他数据都存在于内存空间中。

即便是在X86处理器中，虽然提供了I/O空间，如果由我们自己设计电路板，外设仍然可以只挂接在内存空间。此时，CPU可以像访问一个内存单元那样访问外设I/O端口，而不需要设立专门的I/O指令。因此，__内存空间是必须的，而I/O空间是可选的__。

__I/O地址空间是不同于内存地址空间的独立地址集合，需要特殊指令访问。对于统一编址的系统，只有一个内存地址空间，只不过其中的一些地址(块)被映射到I/O寄存器端口中，设备与RAM瓜分了整个地址空间，访问它们不需要特殊指令。__

==== （2）inb和outb： ====

在Linux设备驱动中，宜使用Linux内核提供的函数来访问定位于__I/O空间的端口__，这些函数包括：
· 读写字节端口（8位宽）
	unsigned inb(unsigned port);
	void outb(unsigned char byte, unsigned port);
· 读写字端口（16位宽）
	unsigned inw(unsigned port);
	void outw(unsigned short word, unsigned port);
· 读写长字端口（32位宽）
	unsigned inl(unsigned port);
	void outl(unsigned longword, unsigned port);
· 读写**一串字节**
	void __insb__(unsigned port, void *addr, unsigned long count);
	void outsb(unsigned port, void *addr, unsigned long count);
	insb()从端口port开始读count个字节端口，并将读取结果写入**addr指向的内存**；outsb()将addr指向的内存的count个字节连续地写入port开始的端口。
· 读写一串字
void insw(unsigned port, void *addr, unsigned long count);
void outsw(unsigned port, void *addr, unsigned long count);
· 读写一串长字
void insl(unsigned port, void *addr, unsigned long count);
void outsl(unsigned port, void *addr, unsigned long count);
上述各函数中I/O端口号port的类型高度依赖于具体的硬件平台，因此，只是写出了unsigned。
