Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2012-03-11T21:28:07+08:00

====== 内核引导过程-3 ======
Created Sunday 11 March 2012
http://blog.csdn.net/drshenlei/article/details/4253179

原文标题：The Kernel Boot Process
原文地址：http://duartes.org/gustavo/blog/
[注：本人水平有限，只好挑一些国外高手的精彩文章翻译一下。一来自己复习，二来与大家分享。]

上一篇文章解释了计算机的引导过程，正好讲到引导装载程序把系统内核镜像塞进内存，准备跳转到__内核入口点__去执行的时刻。作为引导启动系列文章的最后一篇，就让我们深入内核，去看看操作系统是怎么启动的吧。由于我习惯__以事实为依据讨论问题__，所以文中会出现大量的链接引用Linux 内核2.6.25.6版的源代码（源自Linux Cross Reference）。如果你熟悉C的语法，这些代码就会非常容易读懂；即使你忽略一些细节，仍能大致明白程序都干了些什么。最主要的障碍在于对一些代码的理解需要相关的背景知识，比如机器的底层特性或什么时候、为什么它会运行。我希望能尽量给读者提供一些背景知识。为了保持简洁，许多有趣的东西，比如中断和内存，文中只能点到为止了。在本文的最后列出了Windows的引导过程的要点。

当Intel x86的引导程序运行到此刻时，__处理器处于实模式（可以寻址1MB的内存）__，（针对现代的Linux系统）RAM的内容大致如下：
{{./1.png}}
				引导装载完成后的RAM内容

引导装载程序通过__BIOS的磁盘I/O服务__，已经把内核镜像加载到内存当中。这个镜像只是硬盘中内核文件（比如/boot/vmlinuz-2.6.22-14-server）的一份完全相同的拷贝。镜像分为两个部分：**一个较小的部分**，包含实模式的内核代码，被加载到640KB内存边界以下；另一部分是**一大块内核**，运行在保护模式，被加载到低端1MB内存地址以上。

如上图所示，之后的事情发生在__实模式内核的头部（kernel header）__。这段内存区域用于__实现引导装载程序与内核之间的Linux引导协议__。此处的**一些数据会被引导装载程序读取**。这些数据包括一些令人愉快的信息，比如包含内核版本号的可读字符串，也包括一些关键信息，比如**实模式内核代码的大小**。引导装载程序还会向这个区域写入数据，比如用户选中的引导菜单项对应的__命令行参数所在的内存地址__。之后就到了跳转到内核入口点的时刻。下图显示了**内核初始化代码**的执行顺序，包括源代码的目录、文件和行号：
{{./2.png}}
			与体系结构相关的Linux内核初始化过程

对于Intel体系结构，内核启动前期会执行arch/x86/boot/__header.S__文件中的程序。它是用汇编语言书写的。一般说来汇编代码在内核中很少出现，但常见于引导代码。这个文件的开头实际上包含了**引导扇区代码**。早期的Linux不需要引导装载程序就可以工作，这段代码是从那个时候__留传下来__的。现今，如果这个引导扇区被执行，它仅仅给用户输出一个“bugger_off_msg”之后就会重启系统。**现代的引导装载程序会忽略这段遗留代码**。在引导扇区代码之后，我们会看到__实模式内核头部（kernel header）__最开始的15字节；这两部分合起来是512字节，正好是Intel硬件平台上一个典型的磁盘扇区的大小。

在这512字节之后，偏移量**0x200**处，我们会发现Linux内核的第一条指令，也就是实模式内核的入口点。具体的说，它在header.S:110，是一个2字节的跳转指令，直接写成了机器码的形式0x3AEB。你可以通过对内核镜像运行hexdump，并查看偏移量0x200处的内容来验证这一点——这仅仅是一个对神志清醒程度的检查，以确保这一切并不是在做梦。引导装载程序运行完毕时就会跳转执行这个位置的指令，进而跳转到header.S:229执行一个普通的用汇编写成的子程序，叫做__start_of_setup__。这个短小的子程序**初始化栈空间（stack）**，把实模式内核的bss段清零（这个区域包含静态变量，所以用0来初始化它们），之后跳转执行一段又老又好的C语言程序：arch/x86/boot/main.c:122。

__main()会处理一些登记工作__（比如检测内存布局），设置显示模式等。然后它会调用go_to_protected_mode()。然而，在把CPU置于保护模式之前，还有一些工作必须完成。有两个主要问题：**中断和内存**。__在实模式中，处理器的中断向量表总是从内存的0地址开始的，然而在保护模式中，这个中断向量表的位置是保存在一个叫IDTR的CPU寄存器当中的__。与此同时，从逻辑内存地址（在程序中使用）到线性内存地址（一个从0连续编号到内存顶端的数值）的翻译方法在实模式和保护模式中是不同的。保护模式需要一个叫做__GDTR的寄存器__来存放**内存全局描述符表**的地址。所以go_to_protected_mode()调用了__setup_idt() 和 setup_gdt()__，用于装载临时的中断描述符表和全局描述符表。 

现在我们可以转入保护模式啦，这是由另一段汇编子程序protected_mode_jump来完成的。这个子程序通过**设定CPU的CR0寄存器的**__PE位__**来使能保护模式**。此时，分页功能还处于关闭状态；__分页是处理器的一个可选的功能__，即使运行于保护模式也并非必要。真正重要的是，我们__不再受制于640K的内存边界__，现在可以寻址高达4GB的RAM了。这个子程序进而调用__压缩状态内核的32位内核入口点startup_32__。startup32会做一些**简单的寄存器初始化工作**，并调用一个C语言编写的函数decompress_kernel()，用于实际的解压缩工作。

decompress_kernel()会打印一条大家熟悉的信息__“Decompressing Linux…”__（正在解压缩Linux）。解压缩过程是原地进行的，一旦完成内核镜像的解压缩，第一张图中所示的压缩内核镜像就会被覆盖掉。因此__解压后的内核也是从1MB位置开始的__。之后，decompress_kernel()会显示“done”（完成）和令人振奋的“Booting the kernel”（正在引导内核）。这里“Booting”的意思是跳转到整个故事的最后一个入口点，也是__保护模式内核的入口点，位于RAM的第二个1MB开始处__（偏移量0x100000，此值是由芬兰Halti山巅之上的神灵授意给Linus的）。在这个神圣的位置含有一个子程序调用，名叫…呃…startup_32。但你会发现这一位是在另一个目录中的。

这位startup_32的第二个化身也是一个汇编子程序，但它包含了__32位模式的初始化过程__：
1、  它清理了保护模式内核的bss段。（这回是真正的内核了，它会一直运行，直到机器重启或关机。）
2、  为内存建立最终的__全局描述符表__。
3、  __建立页表__以便可以开启分页功能。
4、  **使能分页**功能。
5、  初始化栈空间。
6、  创建最终的__中断描述符表__。
7、  最后，跳转执行一个体系结构无关的内核启动函数：**start_kernel()**。

下图显示了引导最后一步的代码执行流程：
{{./3.png}}
与体系结构无关的Linux内核初始化过程

start_kernel()看起来更像典型的内核代码，几乎全用C语言编写而且__与特定机器无关__。这个函数调用了一长串的函数，__用来初始化各个内核子系统和数据结构__，包括调度器（scheduler），内存分区（memory zones），计时器（time keeping）等等。之后，start_kernel()调用rest_init()，此时几乎所有的东西都可以工作了。rest_init()会创建一个内核线程，并以另一个函数__kernel_init()作为此线程的入口点__。之后，rest_init()会调用schedule()来**激活任务调度功能**，然后调用cpu_idle()使自己进入睡眠（sleep）状态，成为Linux内核中的一个空闲线程（idle thread）。**cpu_idle()会在0号进程（process zero）中永远的运行下去**。一旦有什么事情可做，比如有了一个活动就绪的进程（runnable process），0号进程就会激活CPU去执行这个任务，直到没有活动就绪的进程后才返回。 

但是，还有一个小麻烦需要处理。我们跟随引导过程一路走下来，这个漫长的线程以一个空闲循环（idle loop）作为结尾。处理器上电执行第一条跳转指令以后，一路运行，最终会到达此处。从复位向量（reset vector）->BIOS->MBR->引导装载程序->__实模式内核->保护模式内核__，跳转跳转再跳转，经过所有这些杂七杂八的步骤，最后来到**引导处理器（boot processor）中的空闲循环cpu_idle()**。看起来真的很酷。然而，这并非故事的全部，否则计算机就不会工作。
 
在这个时候，前面启动的那个内核线程已经准备就绪，可以取代0号进程和它的空闲线程了。事实也是如此，就发生在kernel_init()开始运行的时刻（此函数之前被作为线程的入口点）。__kernel_init()的职责是初始化系统中其余的CPU__，这些CPU从引导过程开始到现在，还一直处于停机状态。之前我们看过的所有代码都是在一个单独的CPU上运行的，它叫做引导处理器（boot processor）。当其他CPU——称作__应用处理器（application processor）__——启动以后，它们是处于实模式的，必须通过一些初始化步骤才能进入保护模式。大部分的代码过程都是相同的，你可以参考startup_32，但对于应用处理器，还是有些细微的不同。最终，kernel_init()会调用init_post()，后者会尝试启动一个__用户模式（user-mode）的进程__，尝试的顺序为：/sbin/init，/etc/init，/bin/init，/bin/sh。如果都不行，内核就会报错。幸运的是init经常就在这些地方的，于是1号进程（PID 1）就开始运行了。它会根据对应的配置文件来决定启动哪些进程，这可能包括X11 Windows，控制台登陆程序，网络后台程序等。从而结束了引导进程，同时另一个Linux程序开始在某处运行。至此，让我祝福您的电脑可以一直正常运行下去，不出毛病。

在同样的体系结构下，Windows的启动过程与Linux有很多相似之处。它也面临同样的问题，也必须完成类似的初始化过程。当引导过程开始后，一个最大的不同是，**Windows把全部的实模式内核代码以及一部分初始的保护模式代码都打包到了引导加载程序（C：/NTLDR）当中**。因此，Windows使用的二进制镜像文件就不一样了，内核镜像中没有包含两个部分的代码。另外，__Linux把引导装载程序与内核完全分离__，在某种程度上自动的形成不同的开源项目。下图显示了Windows内核主要的启动过程：
{{./4.png}}
Windows内核初始化过程

自然而然的，Windows用户模式的启动就非常不同了。没有/sbin/init程序，而是运行Csrss.exe和Winlogon.exe。Winlogon会启动Services.exe（它会启动所有的Windows服务程序）、Lsass.exe和本地安全认证子系统。经典的Windows登陆对话框就是运行在Winlogon的上下文中的。

本文是引导启动系列话题的最后一篇。感谢每一位读者，感谢你们的反馈。我很抱歉，有些内容只能点到为止；我打算把它们留在其他文章中深入讨论，并尽量保持文章的长度适合blog的风格。下次我打算定期的撰写关于“Software Illustrated”的文章，就像本系列一样。最后，给大家一些参考资料：
l         最好也最重要的资料是实际的内核代码，Linux或BSD的都成。
l         Intel出版的杰出的软件开发人员手册，你可以免费下载到。
l         《理解Linux内核》是本好书，其中讨论了大量的Linux内核代码。这书也许有点过时有点枯燥，但我还是将它推荐给那些想要与内核心意相通的人们。《Linux设备驱动程序》读起来会有趣得多，讲的也不错，但是涉及的内容有些局限性。最后，网友Patrick Moroney推荐Robert Love所写的《Linux内核开发》，我曾听过一些对此书的正面评价，所以还是值得列出来的。
l         对于Windows，目前最好的参考书是《Windows Internals》，作者是David Solomon和Mark Russinovich，后者是Sysinternals的知名专家。这是本特棒的书，写的很好而且讲解全面。主要的缺点是缺少源代码的支持。 
