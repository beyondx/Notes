Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2012-03-09T17:09:50+08:00

====== 内核是如何管理内存的-5 ======
Created Friday 09 March 2012

原文标题：How The Kernel Manages Your Memory
原文地址：http://duartes.org/gustavo/blog/
[注：本人水平有限，只好挑一些国外高手的精彩文章翻译一下。一来自己复习，二来与大家分享。]

在仔细审视了进程的__虚拟地址布局__之后，让我们把目光转向内核以及其管理用户内存的机制。再次从gonzo图示开始：
{{./1.png}}
Linux进程在内核中是由task_struct的实例来表示的，即__进程描述符__。task_struct的mm字段指向__内存描述符__（memory descriptor），即mm_struct，一个程序的内存的执行期摘要。它存储了上图所示的**内存段的起止位置**，进程所使用的物理内存页的数量（rss表示Resident Set Size），虚拟内存空间的使用量，以及其他信息。

我们还可以在内存描述符中找到用于管理程序内存的两个重要结构：__虚拟内存区域集合__（the set of virtual memory areas, VMA）及__页表__（page table, PT）。Gonzo的内存区域如下图所示：
{{./2.png}}
每一个虚拟内存区域（简称VMA）是一个__连续的虚拟地址范围__；这些区域不会交叠。一个vm_area_struct的实例**完备的描述了一个内存区域**，包括它的起止地址，决定访问权限和行为的标志位，还有vm_file字段，用于指出被映射的文件（如果有的话）。一个VMA如果没有映射到文件，则是__匿名的（anonymous）__。除memory mapping 段以外，上图中的每一个内存段（如：堆，栈）都对应于一个单独的VMA。这并不是强制要求，但在x86机器上经常如此。**VMA并不关心它在哪一个段**。

一个程序的VMA同时以两种形式存储在它的内存描述符中：一个是按起始虚拟地址排列的__链表__，保存在**mmap字段**；另一个是__红黑树__，根节点保存在**mm_rb字段**。**红黑树使得内核可以快速的查找出给定虚拟地址所属的内存区域。**当你读取文件/proc/pid_of_process/maps时，内核只须简单的遍历指定进程的VMA链表，并打印出每一项来即可。

在Windows中，EPROCESS块可以粗略的看成是task_struct和mm_struct的组合。VMA在Windows中的对应物是虚拟地址描述符（Virtual Address Descriptor），或简称VAD；它们保存在平衡树中（AVL tree）。你知道Windows和Linux最有趣的地方是什么吗？就是这些细小的不同点。

__4GB虚拟地址空间被分割为许多页（page）__。x86处理器在32位模式下所支持的页面大小为4KB，2MB和4MB。Linux和Windows__都使用4KB__大小的页面来映射用户部分的虚拟地址空间。第0-4095字节在第0页，第4096-8191字节在第1页，以此类推。__VMA的大小必须是页面大小的整数倍__。下图是以4KB分页的3GB用户空间：
{{./3.png}}

处理器会依照__页表（page table）__来将虚拟地址转换到物理内存地址。每个进程都有__属于自己的__一套页表；一旦进程发生了切换(即进程的上下文切换)，__用户空间的页表也会随之切换(内核空间的页表是共享的，其实内核的虚拟地址和物理地址间的映射关系是确定的。__[[../Linux驱动的地址空间和硬件地址空间说明.txt]]__)__。Linux在内存描述符的**pgd字段**保存了一个指向进程页表的指针。每一个虚拟内存页在页表中都有一个与之对应的__页表项（page table entry），简称PTE__。它在普通的x86分页机制下，是一个简单的4字节记录，如下图所示：
 {{./4.png}}

Linux有一些函数可以用于读取或设置PTE中的每一个标志。__P位__告诉处理器虚拟页面是否存在于（present）物理内存中。如果是0，访问这个页将触发__页故障（page fault）__。记住，当这个位是0时，内核可以根据喜好，随意的使用其余的字段。__R/W标志__表示读/写；如果是0，页面就是只读的。__U/S标志表示用户/管理员__；如果是0，则这个页面只能被内核访问。这些标志用于实现只读内存和保护内核空间。__D位和A位__表示数据脏（dirty）和访问过（accessed）。脏表示页面被执行过__写操作__，访问过表示页面被读或被写过。这两个标志都是粘滞的：**处理器只会将它们置位，之后必须由内核来清除**。最后，PTE还保存了对应__该页的起始物理内存地址__，对齐于4KB边界。PTE中的其他字段我们改日再谈，比如__物理地址扩展（Physical Address Extension）__。

__虚拟页面是内存保护的最小单元__，因为页内的所有字节都共享U/S和R/W标志。然而，同样的物理内存可以被映射到不同的页面，甚至可以拥有不同的保护标志。值得注意的是，在PTE中没有对执行许可（execute permission）的设定。这就是为什么经典的x86分页可以执行位于stack上的代码，从而为黑客利用__堆栈溢出__提供了便利（使用return-to-libc和其他技术，甚至可以利用不可执行的堆栈）。__PTE缺少不可执行（no-execute）标志__引出了一个影响更广泛的事实：VMA中的各种许可标志可能会也可能不会被明确的转换为硬件保护。对此，内核可以尽力而为，但始终受到架构的限制。

**虚拟内存并不存储任何东西，它只是将程序地址空间映射到底层的物理内存上，后者被处理器视为一整块来访问**，称作__物理地址空间（physical address space）__。对物理内存的操作还与__总线__有点联系，好在我们可以暂且忽略这些并假设物理地址范围以字节为单位递增，从０到最大可用内存数。这个物理地址空间被内核分割为一个个__页帧（page frame）__。处理器并不知道也不关心这些帧，然而它们对内核至关重要，因为__页帧是物理内存管理的最小单元__。Linux和Windows在32位模式下，都使用4KB大小的页帧；以一个拥有2GB RAM的机器为例：
{{./5.png}}

在Linux中，每一个页帧都由一个描述符和一些标志所跟踪。这些描述符合在一起，记录了计算机内的全部物理内存；__可以随时知道每一个页帧的准确状态__。     物理内存是用**buddy memory allocation**技术来管理的，因此如果一个页帧可被buddy 系统分配，则它就是可用的（free）。

一个被分配了的页帧可能是__匿名的（anonymous）__，保存着程序数据；也可能是__页缓冲的（page cache）__，保存着**一个文件或块设备的数据**。还有其他一些古怪的页帧使用形式，但现在先不必考虑它们。Windows使用一个类似的__页帧编号（Page Frame Number简称PFN）__数据库来跟踪物理内存。

让我们把虚拟地址区域，页表项，页帧放到一起，看看它们到底是怎么工作的。下图是一个用户堆的例子：
{{./6.png}} 

蓝色矩形表示VMA范围内的页，箭头表示**页表项将页映射到页帧上**。一些虚拟页并没有箭头；这意味着它们对应的__PTE的存在位（Present flag）为0__。形成这种情况的原因可能是这些页还**没有被访问过（内核对用户的内存分配是在实际使用时进行的，**[[../Linux内存管理FAQ.txt]]**）**，或者它们的内容被系统__换出了（swap out）__。无论那种情况，对这些页的访问都会导致__页故障（page fault）__，即使它们处在VMA之内。VMA和页表的**不一致**看起来令人奇怪，但实际经常如此。

 __一个VMA就像是你的程序和内核之间的契约__。你请求去做一些事情（如：内存分配，文件映射等），__内核说“行”，并创建或更新适当的VMA。但它并非立刻就去完成请求，而是一直等到出现了页故障才会真正去做。__内核就是一个懒惰，骗人的败类；这是虚拟内存管理的基本原则。它对大多数情况都适用，有些比较熟悉，有些令人惊讶，但这个规则就是这样：**VMA记录了双方商定做什么，而PTE反映出懒惰的内核实际做了什么。**这两个数据结构共同管理程序的内存；都扮演着解决页故障，释放内存，换出内存（swapping memory out）等等角色。让我们看一个简单的内存分配的例子：
{{./7.png}}

当程序通过brk()系统调用请求更多的内存时，__内核只是简单的更新堆的VMA__，然后说搞好啦。其实此时__并没有页帧被分配__，新的页也并没有出现于物理内存中。一旦程序试图访问这些页，处理器就会报告页故障，并调用__do_page_fault()__。它会通过调用__find_vma()__去搜索哪一个VMA含盖了产生故障的虚拟地址。如果找到了，还会根据VMA上的访问许可来比__对检查访问请求__（读或写）。如果没有合适的VMA，也就是说内存访问请求没有与之对应的合同，进程就会被处以__段错误（Segmentation Fault）__的罚单。

当一个VMA被找到后，内核必须处理这个故障，方式是查看PTE的内容以及VMA的类型。在我们的例子中，__PTE显示了该页并不存在__。事实上，我们的PTE是完全空白的（全为0），**在Linux中意味着虚拟页还没有被映射**。既然这是一个__匿名的VMA，我们面对的就是一个纯粹的RAM事务__，必须由do_anonymous_page()处理，它会分配一个页帧并生成一个PTE，将出故障的虚拟页映射到那个刚刚分配的页帧上。

事情还可能有些不同。被换出的页所对应的PTE，例如，它的Present标志是0但并不是空白的。相反，__它记录了页面内容在交换系统中的位置__，这些内容必须从磁盘读取出来并通过do_swap_page()加载到一个页帧当中，这就是所谓的major fault。

至此我们走完了“内核的用户内存管理”之旅的前半程。在下一篇文章中，我们将把文件的概念也混进来，从而建立一个内存基础知识的完成画面，并了解其对系统性能的影响。
