Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2012-03-09T16:01:36+08:00

====== 剖析程序的内存布局-4 ======
Created Friday 09 March 2012

http://blog.csdn.net/drshenlei/article/details/4339110

原文标题：Anatomy of a Program in Memory
原文地址：http://duartes.org/gustavo/blog/


[注：本人水平有限，只好挑一些国外高手的精彩文章翻译一下。一来自己复习，二来与大家分享。]

内存管理模块是操作系统的心脏；它对应用程序和系统管理非常重要。今后的几篇文章中，我将着眼于实际的内存问题，但也不避讳其中的技术内幕。由于不少概念是通用的，所以文中大部分例子取自32位x86平台的Linux和Windows系统。本系列第一篇文章讲述应用程序的内存布局。

在多任务操作系统中的每一个进程都运行在一个属于它**自己的内存沙盘中**。这个沙盘就是__虚拟地址空间__（virtual address space），在32位模式下它总是一个4GB的内存地址块。这些虚拟地址通过__页表__（page table）映射到物理内存，页表由**操作系统维护并被处理器引用**。每一个进程拥有一套属于__它自己__的页表，但是还有一个隐情。只要虚拟地址被使能，那么它就会作用于这台机器上运行的__所有软件__，包括内核本身。因此一部分虚拟地址必须保留给内核使用：
{{./1.png}}
 
这并不意味着内核使用了那么多的物理内存，仅表示它__可支配这么大的地址空间__，可根据内核需要，将其__映射到物理内存__。内核空间在页表中拥有较高的**特权级**（ring 2或以下），因此只要用户态的程序试图访问这些页，就会导致一个__页错误__（page fault）。在Linux中，内核空间是持续存在的，并且__在所有进程中都映射到同样的物理内存__。内核代码和数据__总是__可寻址的(n内核访问自身的代码、数据不会出现段错误)，随时准备处理中断和系统调用。与此相反，用户模式地址空间的映射随进程切换的发生而不断变化：
{{./2.png}} 

蓝色区域表示**映射到物理内存的虚拟地址**，而白色区域表示未映射的部分。在上面的例子中，Firefox使用了相当多的虚拟地址空间，因为它是传说中的吃内存大户。地址空间中的各个条带对应于不同的__内存段__（memory segment），如：堆、栈之类的。记住，这些段只是简单的__内存地址范围__，与Intel处理器的段没有关系。不管怎样，下面是一个Linux进程的标准的内存段布局：
{{./3.png}} 
 
当计算机开心、安全、可爱、正常的运转时，几乎每一个进程的各个段的起始虚拟地址都与上图完全一致，这也给远程发掘程序安全漏洞打开了方便之门。一个发掘过程往往需要引用**绝对内存地址**：栈地址，库函数地址等。远程攻击者必须依赖__地址空间布局的一致性__，摸索着选择这些地址。如果让他们猜个正着，有人就会被整了。因此，地址空间的**随机排布方式**逐渐流行起来。Linux通过对栈、内存映射段、堆的起始地址加上__随机的偏移量__来打乱布局。不幸的是，32位地址空间相当紧凑，给随机化所留下的空当不大，削弱了这种技巧的效果。

进程地址空间中最顶部的段是__栈__，大多数编程语言将之用于**存储局部变量和函数参数**。调用一个方法或函数会将一个新的__栈桢__（stack frame）压入栈中。栈桢在函数返回时被清理。也许是因为数据严格的遵从**LIFO**的顺序，这个简单的设计意味着不必使用复杂的数据结构来追踪栈的内容，只需要一个简单的__栈指针__指向栈的顶端即可。因此压栈（pushing）和退栈（popping）过程非常迅速、准确。另外，持续的__重用栈空间__有助于使活跃的栈内存保持在CPU缓存中，从而加速访问。进程中的每一个线程都有属于自己的栈。

通过不断向栈中压入的数据，超出其容量就有会耗尽栈所对应的内存区域。这将触发一个__页故障__（page fault），并被Linux的__expand_stack()__处理，它会调用acct_stack_growth()来检查是否还有合适的地方用于栈的增长。如果栈的大小低于__RLIMIT_STACK__（通常是8MB），那么一般情况下栈会被加长，程序继续愉快的运行，感觉不到发生了什么事情。这是一种将栈扩展至所需大小的常规机制。然而，如果达到了最大的栈空间大小，就会__栈溢出__（stack overflow），程序收到一个__段错误__（Segmentation Fault）。当映射了的栈区域扩展到所需的大小后，它就不__会再收缩回去__，即使栈不那么满了。这就好比联邦预算，它总是在增长的。

__动态栈增长__是唯一一种**访问未映射内存区域（图中白色区域）而被允许的情形**。其它任何对未映射内存区域的访问都会触发页故障，从而导致段错误。一些被映射的区域是只读的，因此企图写这些区域也会导致段错误。

在栈的下方，是我们的**内存映射段**。此处，__内核将文件(该文件可能是用户直接打开的，也可能是系统库函数或动态加载器打开的。)的内容直接映射到内存__。任何应用程序都可以通过Linux的__mmap()系统调用__（实现）或Windows的CreateFileMapping() / MapViewOfFile()请求这种映射。内存映射是**一种方便高效的文件I/O方式**，所以它被__用于加载动态库（因为动态库文件一般是只读的。）__。创建一个不对应于任何文件的__匿名内存映射__也是可能的，此方法用于存放程序的数据。在Linux中，如果你通过malloc()请求一__大__块内存，C运行库将会创建这样一个匿名映射而不是使用堆内存。‘大块’意味着比**MMAP_THRESHOLD**还大，缺省是128KB，可以通过mallopt()调整。

说到堆，它是接下来的一块地址空间。__与栈一样，堆用于运行时内存分配__；但不同点是，堆用于存储那些__生存期与函数调用无关的数据__。大部分语言都提供了堆管理功能。因此，满足内存请求就成了**语言运行时库及内核**共同的任务。在C语言中，堆分配的接口是malloc()系列函数，而在具有垃圾收集功能的语言（如C#）中，此接口是new关键字。

如果堆中有足够的空间来满足内存请求，它就可以**被语言运行时库处理而不需要内核参与（语言运行时库会预先分配一块内存。）**。否则，**堆会被扩大**，通过__brk()系统调用__（实现）来分配请求所需的内存块。堆管理是很复杂的，需要精细的算法，应付我们程序中杂乱的分配模式，优化速度和内存使用效率。处理一个堆请求所需的时间会大幅度的变动。实时系统通过__特殊目的分配器__来解决这个问题。堆也可能会变得零零碎碎，如下图所示：
{{./4.png}}


最后，我们来看看最底部的内存段：BSS，数据段，代码段。在C语言中，BSS和数据段保存的都是__静态（全局）变量__的内容。区别在于BSS保存的是未被初始化的静态变量内容，它们的值不是直接在程序的源代码中设定的。__BSS内存区域是匿名的__：它不映射到任何文件。如果你写static int cntActiveUsers，则cntActiveUsers的内容就会保存在BSS中。

另一方面，数据段保存在源代码中__已经初始化__了的静态变量内容。这个内存区域__不是匿名__的。它映射了一部分的程序二进制镜像，也就是源代码中指定了初始值的静态变量。所以，如果你写static int cntWorkerBees = 10，则cntWorkerBees的内容就保存在数据段中了，而且初始值为10。尽管数据段映射了一个文件，但它是一个**私有**内存映射，这意味着更改此处的内存不会影响到被映射的文件。也必须如此，否则给全局变量赋值将会改动你硬盘上的二进制镜像，这是不可想象的。

下图中数据段的例子更加复杂，因为它用了一个指针。在此情况下，指针gonzo（4字节内存地址）本身的值保存在数据段中。而它所指向的实际字符串则不在这里。这个__字符串保存在代码段中__，代码段是只读的，保存了你全部的代码外加零零碎碎的东西，比如__字符串字面值__。代码段将你的__二进制文件也映射到了内存__中，但对此区域的写操作都会使你的程序收到段错误。这有助于防范指针错误，虽然不像在C语言编程时就注意防范来得那么有效。代码段和数据段的__内存空间都和可执行文件的不同部分相映射__。下图展示了这些段以及我们例子中的变量：
{{./5.png}} 

 
你可以通过阅读文件/proc/pid_of_process/__maps__来检验一个Linux进程中的内存区域。记住**一个段可能包含许多区域**。比如，每个内存映射文件在mmap段中都有属于自己的区域，**动态库拥有类似BSS和数据段的额外区域**。下一篇文章讲说明这些“区域”（area）的真正含义。有时人们提到“数据段”，指的就是全部的__数据段 + BSS + 堆__。

也就是说，mmap映射的动态库文件，在Memory Map Segment中一般有三个区域：库文件的代码段，数据段和BSS段。 


你可以通过__nm和objdump__命令来察看二进制镜像，打印其中的符号，它们的地址，段等信息。最后需要指出的是，前文描述的虚拟地址布局在Linux中是一种“灵活布局”（flexible layout），而且以此作为默认方式已经有些年头了。它假设我们有值RLIMIT_STACK。当情况不是这样时，Linux退回使用**“经典布局”**（classic layout），如下图所示：
{{./6.png}}

对__虚拟地址空间的布局__就讲这些吧。下一篇文章将讨论内核是如何跟踪这些内存区域的。我们会分析内存映射，看看文件的读写操作是如何与之关联的，以及内存使用概况的含义。
