Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2012-03-08T18:03:47+08:00

====== Linux驱动的地址空间和硬件地址空间说明 ======
Created Thursday 08 March 2012
http://blog.csdn.net/jianchi88/article/details/6982557

作者：李强,华清远见嵌入式学院讲师。
有这么几个问题，在上驱动课程的时候，我感觉一直困扰着同学们：

●    用户程序编译连接形成的地址空间在什么范围内？
        ●    内核编译后地址空间在什么范围内？
        ●    要对外设进行访问，I/O的地址空间又是什么样的？

于是就有了这篇文章，从大概上把内存相关知识点介绍一下，减少同学们在驱动课时对内存的困惑

先回答第一个问题。Linux最常见的__可执行文件格式为elf(__Executable and Linkable Format)。在elf格式的可执行代码中，ld总是__从0x800 0000开始安排程序的“代码段”__，对每个程序都是这样。至于程序执行时在物理内存中的实际地址，则由__内核为其建立内存映射时临时分配__，具体地址取决于当时所分配的物理内存页面。

我们可以用Linux的实用程序objdump对你的程序进行反汇编，从而知晓其地址范围。

例如：假定我们有一个简单的C程序Hello.c

# include <stdio.h>
        greeting ( )
        {
                printf(“Hello,world!\n”);
        }
        main()
        {
                greeting();
        }

之所以把这样简单的程序写成两个函数，是为了说明指令的转移过程。我们用gcc和ld对其进行编译和连接，得到可执行代码hello。然后，用Linux的实用程序obj对其进行反汇编：
        $objdump –d hello

得到的主要片段为：

08048568 <greeting>:
                8048568:        pushl     %ebp
                8048569:        movl     %esp, %ebp
                804856b:        pushl    $0x809404
                8048570:        call        8048474 <_init+0x84>
                8048575:        addl        $0x4, %esp
                8048578:        leave
                8048579:        ret
                804857a:        movl       %esi, %esi
0804857c <main>:
                804857c:        pushl    %ebp
                804857d:        movl    %esp, %ebp
                804857f:         call        8048568 <greeting>
                8048584:        leave
                8048585:        ret
                8048586:        nop
                8048587:        nop

其中，像08048568这样的地址，就是我们常说的__虚地址__（这个地址实实在在的存在，只不过因为物理地址的存在，显得它是“虚”的罢了）。

===== 虚拟内存、内核空间和用户空间 =====

Linux虚拟内存的大小为2^32（在32位的x86机器上），__内核将这4G字节的虚拟地址空间分为两部分__。最高的1G字节（从虚地址0xC0000000到0xFFFFFFFF）供内核使用，称为“内核空间”。而较低的3G字节（从虚地址0x00000000到0xBFFFFFFF），供各个进程使用，称为“用户空间”。因为每个进程可以通过系统调用进入内核，因此，__Linux内核空间由系统内的所有进程共享__。于是，从具体进程的角度来看，每个进程可以拥有4G字节的**虚拟地址空间(也叫虚拟内存)**。

每个进程有各自的私有用户空间（0～3G），__这个空间对系统中的其他进程是不可见的__。最高的1GB内核空间则为所有进程以及内核所共享。另外，进程的“用户空间”也叫“地址空间”，在后面的叙述中，我们对这两个术语不再区分。

__用户空间不是进程共享的，而是进程隔离的__。每个进程最大都可以有3GB的用户空间。一个进程对其中一个地址的访问，与其它进程对于同一地址的访问绝不冲突。比如，一个进程从其用户空间的地址0x1234ABCD处可以读出整数8，__而另外一个进程从其用户空间的地址__0x1234ABCD处可以读出整数20，这取决于进程自身的逻辑。
                                           
任意一个时刻，在一个CPU上只有一个进程在运行。所以**对于此CPU来讲，在这一时刻，整个系统只存在一个4GB的虚拟地址空间**，这个虚拟地址空间是面向此进程的。__当进程发生切换的时候，虚拟地址空间也随着切换。__由此可以看出，每个进程都有自己的虚拟地址空间，只有此进程运行的时候，其虚拟地址空间才被运行它的CPU所知。在其它时刻，其虚拟地址空间对于CPU来说，是不可知的。所以尽管每个进程都可以有4 GB的虚拟地址空间，__但在CPU眼中，只有一个虚拟地址空间存在__。虚拟地址空间的变化，随着进程切换而变化。

从上面我们知道，一个程序编译连接后形成的地址空间是一个虚拟地址空间，但是程序最终还是要运行在物理内存中。因此，应用程序所给出的任何虚地址最终必须被转化为物理地址，所以，虚拟地址空间必须被映射到物理内存空间中，这个__映射关系需要通过硬件体系结构所规定的数据结构来建立__。这就是我们所说的**段描述符表和页表**，Linux主要通过__页表__来进行映射。

于是，我们得出一个结论，如果给出的页表不同，那么CPU将某一虚拟地址空间中的地址转化成的物理地址就会不同。所以我们__为每一个进程都建立其页表__，将每个进程的虚拟地址空间根据自己的需要映射到物理地址空间上。既然某一时刻在某一CPU上只能有一个进程在运行，那么当进程发生切换的时候，将页表也更换为相应进程的页表，这就可以实现每个进程都有自己的虚拟地址空间而互不影响。所以，在任意时刻，对于一个CPU来说，只需要有当前进程的页表，就可以实现其虚拟地址到物理地址的转化。

===== 内核空间到物理内存的映射 =====

在驱动中我们提的比较多的就是**内核空间与硬件内存地址**，那么我们下面来详细介绍下内核空间和实际的硬件物理地址。

内核空间对所有的进程都是共享的，其中存放的是**内核代码和数据**，而进程的用户空间中存放的是**用户程序的代码和数据**，不管是内核程序还是用户程序，它们被编译和连接以后，所形成的指令和符号地址__都是虚地址__，而不是物理内存中的物理地址。

虽然内核空间占据了每个虚拟空间中的最高1GB字节，但__映射到物理内存却总是从最低地址（0x00000000）开始的__，之所以这么规定，是为了在内核空间与物理内存之间建立__简单的线性映射关系__。其中，3GB（0xC0000000）就是物理地址与虚拟地址之间的**位移量**，在Linux代码中就叫做PAGE_OFFSET。

我们来看一下在include/asm/i386/page.h头文件中对内核空间中地址映射的说明及定义：

#define __PAGE_OFFSET                (0xC0000000)
        ……
        #define PAGE_OFFSET                ((unsigned long)__PAGE_OFFSET)
        #define __pa(x)                ((unsigned long)(x)-PAGE_OFFSET)
        #define __va(x)                ((void *)((unsigned long)(x)+PAGE_OFFSET))

对于内核空间而言，给定一个虚地址x，其物理地址为“x- PAGE_OFFSET”，给定一个物理地址x，其虚地址为“x+ PAGE_OFFSET”。
这里再次说明，宏__pa()仅仅把一个内核空间的虚地址映射到物理地址，而决不适用于用户空间，用户空间的地址映射要复杂得多，它通过分页机制完成。

待续……
