Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2012-03-11T20:06:44+08:00

====== 主板芯片组与内存映射-1 ======
Created Sunday 11 March 2012
http://blog.csdn.net/drshenlei/article/details/4246441

原文标题：Motherboard Chipsets and the Memory Map
原文地址：http://duartes.org/gustavo/blog/
[注：本人水平有限，只好挑一些国外高手的精彩文章翻译一下。一来自己复习，二来与大家分享。]

我打算写一组讲述计算机内幕的文章，旨在揭示现代操作系统内核的工作原理。我希望这些文章能对电脑爱好者和程序员有所帮助，特别是对这类话题感兴趣但没有相关知识的人们。讨论的焦点是Linux，Windows，和Intel处理器。__钻研系统内幕是我的一个爱好__。我曾经编写过不少内核模式的代码，只是最近一段时间不再写了。这第一篇文章讲述了现代Intel主板的布局，CPU如何访问内存，以及系统的内存映射。
 
作为开始，让我们看看当今的Intel计算机是如何连接各个组件的吧。下图展示了主板上的主要组件：
{{./1.png}}
						现代主板的示意图，**北桥和南桥构成了芯片组**。

当你看图时，请牢记一个至关重要的事实：__CPU一点也不知道它连接了什么东西__。CPU仅仅通过一组针脚与外界交互，它并不关心外界到底有什么。可能是一个电脑主板，但也可能是烤面包机，网络路由器，植入脑内的设备，或CPU测试工作台。__CPU主要通过3种方式与外界交互：内存地址空间，I/O地址空间，还有中断。__
 
眼下，我们只关心主板和内存。安装在主板上的CPU与外界沟通的门户是__前端总线（front-side bus）__，**前端总线把CPU与北桥连接起来**。每当CPU需要读写内存时，都会使用这条总线。CPU通过一部分管脚来传输想要读写的__物理内存地址__，同时另一些管脚用于发送将被写入或接收被读出的__数据__。一个Intel Core 2 QX6600有__33个__针脚用于传输物理内存地址（可以表示2^33个地址位置），__64个__针脚用于接收/发送数据（所以数据在64位通道中传输，也就是__8字节的数据块__）。这使得CPU可以控制__64GB__的物理内存（**233个地址乘以8字节**），尽管大多数的芯片组只能支持8GB的RAM。

现在到了最难理解的部分。我们可能曾经认为内存指的就是RAM，被各式各样的程序读写着。的确，大部分CPU发出的内存请求都被__北桥转送给了RAM控制器__，但并非全部如此。__物理内存地址还可能被用于主板上各种设备间的通信，这种通信方式叫做内存映射I/O__。这类设备包括显卡，大多数的PCI卡（比如扫描仪或SCSI卡），以及BIOS中的flash存储器等。 

当**北桥**接收到一个物理内存访问请求时，它需要决定__把这个请求转发到哪里__：是发给RAM？抑或是显卡？具体发给谁是__由内存地址映射表来决定的__。映射表知道每一个物理内存地址区域所对应的设备。绝大部分的地址被映射到了RAM，其余地址__由映射表来通知芯片组该由哪个设备来响应此地址的访问请求__。这些被映射为设备的内存地址形成了一个经典的__空洞__，位于PC内存的640KB到1MB之间。当内存地址被保留用于显卡和PCI设备时，就会形成更大的空洞。这就是为什么__32位的操作系统无法使用全部的4GB RAM__。Linux中，/proc/iomem这个文件简明的列举了这些空洞的地址范围。下图展示了Intel PC低端4GB物理内存地址形成的一个典型的内存映射：
{{./2.png}}
[[../linux中的_IO端口映射和IO内存映射/Intel_CPU_地址空间总结.txt]]
			 Intel系统中，低端4GB内存地址空间的布局。

实际的地址和范围依赖于特定的主板和电脑中接入的设备，但是对于大多数Core 2系统，情形都跟上图非常接近。所有棕色的区域都被设备地址映射走了。记住，__这些在主板总线上使用的都是物理地址。在CPU内部（比如我们正在编写和运行的程序），使用的是逻辑地址，必须先由CPU翻译成物理地址以后，才能发布到总线上去访问内存__。

这个把逻辑地址翻译成物理地址的规则比较复杂，而且还依赖于当时**CPU的运行模式**（__实模式，32位保护模式__，64位保护模式）。不管采用哪种翻译机制，__CPU的运行模式决定了有多少物理内存可以被访问__。比如，当CPU工作于32位保护模式时，它只可以寻址4GB物理地址空间（当然，也有个例外叫做**物理地址扩展PAE**，但暂且忽略这个技术吧）。由于顶部的大约1GB物理地址被映射到了主板上的设备，__CPU实际能够使用的也就只有大约3GB的RAM__（有时甚至更少，我曾用过一台安装了Vista的电脑，它只有2.4GB可用）。__如果CPU工作于实模式，那么它将只能寻址1MB的物理地址空间__（这是早期的Intel处理器所支持的唯一模式）。如果CPU工作于__64位保护模式__，则可以寻址__64GB__的地址空间（虽然很少有芯片组支持这么大的RAM）。处于64位保护模式时，CPU就有可能访问到RAM空间中被主板上的设备映射走了的区域了（即访问空洞下的RAM）。要达到这种效果，就需要使用比系统中所装载的RAM地址区域更高的地址。这种技术叫做__回收(reclaiming)__，而且还需要芯片组的配合。

这些关于内存的知识将为下一篇文章做好铺垫。下次我们会探讨机器的启动过程：从上电开始，直到boot loader准备跳转执行操作系统内核为止。如果你想更深入的学习这些东西，我强烈推荐Intel手册。虽然我列出的都是第一手资料，但Intel手册写得很好很准确。这是一些资料：

l         《Datasheet for Intel G35 Chipset》描述了一个支持Core 2处理器的有代表性的芯片组。这也是本文的主要信息来源。
l         《Datasheet for Intel Core 2 Quad-Core Q6000 Sequence》是一个处理器数据手册。它记载了处理器上每一个管脚的作用（当你把管脚按功能分组后，其实并不算多）。很棒的资料，虽然对有些位的描述比较含糊。
l         《Intel Software Developer’s Manuals》是杰出的文档。它**优美的解释了体系结构的各个部分**，一点也不会让人感到含糊不清。第一卷和第三卷A部很值得一读（别被“卷”字吓倒，每卷都不长，而且您可以选择性的阅读）。
l         Pádraig Brady建议我链接到Ulrich Drepper的一篇关于内存的优秀文章。确实是个好东西。我本打算把这个链接放到讨论存储器的文章中的，但此处列出的越多越好啦。
