Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2011-11-23T09:38:24+08:00

====== USB 驱动与sysfs ======
Created Wednesday 23 November 2011

http://oss.org.cn/kernel-book/ldd3/ch13.html


目录

13.1. USB 设备基础知识

    13.1.1. 端点
    13.1.2. 接口
    13.1.3. 配置 

13.2. USB 和 sysfs
13.3. USB 的 Urbs

    13.3.1. 结构 struct urb
    13.3.2. 创建和销毁 urb
    13.3.3. 提交 urb
    13.3.4. 完成 urb: 完成回调处理者
    13.3.5. 取消 urb 

13.4. 编写一个 USB 驱动

    13.4.1. 驱动支持什么设备
    13.4.2. 注册一个 USB 驱动
    13.4.3. 提交和控制一个 urb 

13.5. 无 urb 的 USB 传送

    13.5.1. usb_bulk_msg 接口
    13.5.2. usb_control_msg 接口
    13.5.3. 使用 USB 数据函数 

13.6. 快速参考

通用串行总线(USB)是一个在主机和许多外设之间的连接. 最初它被创建来替代许多慢速和不同的总线-并口, 串口, 和键盘连接--有一个单个的所有设备都可以连接的总线类型.[45] USB 已经成长超出了这些慢速连接并且现在支持几乎每种可以连接到 PC 的设备. USB 规范的最新版本增加了高速连接, 理论上到 480 MBps.

拓扑结构上, 一个 USB 子系统没有如同一个总线一样分布; 它更多是__一个树__, 有几个点对点连接. 这些连接是 4-线 电缆(地, 电源, 和 2 个信号线)来连接一个设备和一个集线器, 如同双绞线以太网. USB 主控制器__负责询问__每个 USB 设备是否它有数据发送. 由于这个拓扑关系, 一个 USB 设备在没有首先被主控制器询问时__从不启动__发送数据. 这个配置允许一个非常容易即插即用的系统, 这样各种设备可__自动被主机配置__.

在技术层面这个总线是非常简单的, 因为它是一个__单主实现__, 其中主机查询各种外设. 除了这个固有的限制, 这个总线有一些有趣的特性, 例如一个设备能够请求一个固定的__数据传送带宽__, 为了可靠地支持视频和音频 I/O. 另一个重要的特性是它只作为设备和主机之间的一个通讯通道, 对它传递的数据没有特殊的含义和结构要求.

实际上, 有一些结构, 但是它大部分精简为适应一个预先定义的__类别__: 例如, 一个键盘不会分配带宽, 而一些视频摄像头会.

USB 协议规范定义了一套标准, 任何特定类型的设备都可以遵循. 如果一个设备遵循这个标准, 那么给那个设备的一个**特殊的驱动就不必了.** 这些不同的类型称为__类__, 并且包含如同存储设备, 键盘, 鼠标, 游戏杆, 网络设备, 和猫. 其他不适合这些类的设备需要一个特殊的供应商-特定的驱动给这些特别的设备. 视频设备和 USB-到-串口 设备是一个好的例子, 这里没有定义好的标准, 并且需要一个驱动给每个来自不同制造商的不同的设备.

这些特性, 连同固有的设计上的热插拔能力, 使 USB 称为一个方便的, 低成本的机制来连接(和去连接)多个设备到计算机, 而不必关机, 开盒子, 并且旋开螺钉和电线.

Linux 内核支持 2 类 USB 驱动: 位于__主机系统的驱动__和位于__设备的驱动__. 主机系统的 USB 驱动控制插入其中的 USB 设备, 从主机的观点看(一个通常的 USB 主机是一个桌面计算机). 在设备中的 USB 驱动, 控制单个设备如何作为一个 USB 设备看待主机系统. 由于术语" USB 设备驱动"是非常迷惑, USB 开发者已经创建了术语" USB 器件驱动"来描述控制一个连接到计算机的 USB 设备的驱动(记住 Linux 也运行在这些小的嵌入式的设备中). 本章详述了运行在一台桌面计算机上的 USB 系统如何工作的. USB 器件驱动此时超出了本书的范围.

如同图USB 驱动概览所示, USB 驱动位于不同的内核子系统(块, 网络, 字符, 等等)和硬件控制器之间. USB 核心提供了一个接口给 USB 驱动用来存取和控制 USB 硬件, 而不必担心出现在系统中的不同的 USB 硬件控制器.
{{~/sync/notes/zim/Linux/硬件探秘/Linux下的硬件驱动——USB设备/USB_驱动与sysfs/ldd3-13-1.png}}

图 13.1. USB 驱动概览
USB 驱动概览
{{~/sync/notes/zim/Linux/硬件探秘/Linux下的硬件驱动——USB设备/USB_驱动与sysfs/ldd3-13-2.png}}
图 13.2. USB 设备概览
USB 设备概览

===== 13.1. USB 设备基础知识 =====

一个 USB 设备是一个非常复杂的事物, 如同在官方的 USB 文档(可从 http://www.usb.org 中得到)中描述的. 幸运的是, Linux 提供了一个子系统称为__ USB 核__, 来处理大部分复杂的工作. 这一章描述驱动和 USB 核之间的交互. 图USB 设备概览显示了 USB 设备如何包含配置, 接口, 和端点, 以及 USB 驱动如何**绑定到 USB 接口**, 而不是整个 USB 设备.

=== 13.1.1. 端点 ===

USB 通讯的最基本形式是通过某些称为 端点 的. 一个 USB 端点只能在一个方向承载数据, 或者从主机到设备(称为输出端点)或者从设备到主机(称为输入端点). 端点可看作一个**单向的管道**.

一个 USB 端点可是 4 种不同类型的一种, 它来描述数据如何被传送:

CONTROL

    控制端点被用来允许对 USB **设备的不同部分**存取. 通常用作__配置设备__, 获取关于设备的信息, 发送命令到设备, 或者获取关于设备的状态报告. 这些端点在尺寸上常常较小. 每个 USB 设备有一个控制端点称为__"端点 0"__, 被 USB 核用来在插入时配置设备. 这些传送由 USB 协议保证来总有足够的带宽使它到达设备.
INTERRUPT

    中断端点传送小量的数据, 以固定的速率在每次 USB 主请求设备数据时. 这些端点对 **USB 键盘和鼠标**来说是主要的传送方法. 它们还用来传送数据到 USB 设备来控制设备, 但通常不用来传送大量数据. 这些传送由 USB 协议保证来总有足够的带宽使它到达设备.
BULK

    块端点传送大量的数据. 这些端点常常比中断端点大(它们一次可持有更多的字符). 它们是普遍的, 对于需要传送**不能有任何数据丢失**的数据. 这些传送不被 USB 协议保证来一直使它在特定时间范围内完成. 如果总线上没有足够的空间来发送整个 BULK __报文__, 它被分为多次传送到或者从设备. 这些端点普遍在打印机, 存储器, 和网络设备上.
ISOCHRONOUS

    同步端点也传送大量数据, 但是这个数据常常不被保证它完成. 这些端点用在可以处理数据丢失的设备中, 并且更多依赖于保持持续的数据流. __实时数据收集__, 例如音频和视频设备, 一直都使用这些端点.

控制和块端点用作异步数据传送, 无论何时驱动决定使用它们. 中断和同步端点是周期性的. 这意味着这些端点被设置来连续传送数据在固定的时间, 这使它们的带宽被 USB 核所保留.

USB 端点在内核中使用结构 **struct usb_host_endpoint** 来描述. 这个结构包含真实的端点信息在另一个结构中, 称为 **struct usb_endpoint_descriptor**. 后者包含所有的 USB-特定 数据, 以设备自身特定的准确格式. 驱动关心的这个结构的成员是:

bEndpointAddress

    这是这个特定端点的** USB 地址**. 还包含在这个 8-位 值的是端点的方向. 位掩码 USB_DIR_OUT 和 USB_DIR_IN 可用来和这个成员比对, 来决定给这个端点的数据是到设备还是到主机.
bmAttributes

    这是端点的类型. 位掩码 USB_ENDPOINT_XFERTYPE_MASK 应当用来和这个值比对, 来决定这个端点是否是 USB_ENDPOINT_XFER_ISOC, USB_ENDPOINT_XFER_BULK, 或者是类型 USB_ENDPOINT_XFER_INT. 这些宏定义了同步, 块, 和中断端点, 相应地.
wMaxPacketSize

    这是以字节计的这个端点可一次处理的**最大大小.** 注意驱动可能发送大量的比这个值大的数据到端点, 但是数据会被分为 wMaxPakcetSize 的块, 当真正传送到设备时. 对于高速设备, 这个成员可用来支持端点的一个高带宽模式, 通过使用几个额外位在这个值的高位部分. 关于如何完成的细节见 USB 规范.
bInterval

    如果这个端点是中断类型的, 这个值是为这个端点设置的间隔, 即在请求端点的中断之间的时间. 这个值以毫秒表示.

这个结构的成员没有一个"传统" Linux 内核的命名机制. 这是因为这些成员直接对应于 USB 规范中的名子. USB 内核程序员认为使用规定的名子更重要, 以便在阅读规范时减少混乱, 不必使这些名子对 Linux 程序员看起来熟悉.

=== 13.1.2. 接口 ===

USB __端点被绑在接口__中. USB 接口只处理一类 USB 逻辑连接, 例如一个鼠标, 一个键盘, 或者一个音频流. **一些 USB 设备有多个接口**, 例如一个 USB 扬声器可能有 2 个接口: 一个 USB 键盘给按钮和一个 USB 音频流. 因为一个 USB **接口表示基本的功能**, __每个 USB 驱动控制一个接口__; 因此, 对扬声器的例子, Linux 需要 2 个不同的驱动给一个硬件设备.

USB 接口可能有预备的设置, 是对接口参数的不同选择. 接口的初始化的状态是第一个设置, __0 号__. 预备的设置可用来以不同方式控制单独的端点, 例如来保留不同量的 USB 带宽给设备. 每个有同步端点的设备使用预备设备给同一个接口.

USB 接口在内核中使用 struct usb_interface 结构来描述. 这个结构是 **USB 核传递给 USB 驱动**的并且是 USB 驱动接下来负责控制的. 这个结构中的重要成员是:

struct usb_host_interface *altsetting

    一个包含所有预备设置的接口结构的数组, 可被挑选给这个接口. 每个 struct usb_host_interface 包含一套端点配置, 如同由 struct usb_host_endpoint 结构所定义的. 注意这些接口结构没有特别的顺序.
unsigned num_altsetting

    由 altsetting 指针指向的预备设置的数目.
struct usb_host_interface *cur_altsetting

    指向数组 altsetting 的一个指针, 表示这个接口当前的激活的设置.
int minor

    如果绑定到这个接口的 USB 驱动使用 USB 主编号, 这个变量包含由 USB 核心安排给接口的次编号. 这只在一次成功地调用 usb_register_dev (本章稍后描述)之后才有效.

在 struct usb_interface 结构中有其他成员, 但是 USB 驱动不需要知道它们.

=== 13.1.3. 配置 ===

USB __接口是自己被捆绑到配置__的. 一个 USB 设备可有多个配置并且可能在它们之间转换以便改变设备的状态. 例如, 一些允许固件被下载到它们的设备包含多个配置来实现这个. 一个配置只能在一个时间点上被使能. Linux 处理多配置 USB 设备不是太好, 但是, 幸运的是, 它们很少.

linux 描述 USB 配置使用结构 struct usb_host_config 和整个 USB 设备使用结构 struct usb_device. USB 设备驱动通常不会需要读写这些结构的任何值, 因此它们在这里没有详细定义. 好奇的读者可在内核源码树的文件 include/linux/usb.h 中找到对它们的描述.

一个 USB 设备驱动通常不得不转换数据从给定的 struct usb_interface 结构到 struct usb_device 结构, USB 核心需要给很多的函数调用. 为此, 提供有函数 interface_to_usbdev. 在以后, 希望所有的当前需要一个 struct usb_device 的 USB 调用, 将被转换为采用一个 struct usb_interface 参数, 并且不会要求驱动做这个转换.

所以总结, USB 设备是非常复杂的, 并且由许多**不同逻辑单元**组成. 这些单元之间的关系可简单地描述如下:
 
* 设备通常有一个或多个配置.
* 配置常常有一个或多个接口
* 接口常常有一个或多个设置.
* 接口有零或多个端点.

===== 13.2. USB 和 sysfs =====

   由于单个USB物理设备的复杂性，设备在sysfs中的表示也非常复杂。无论是**物理USB设备**(用struct usb_device表示)还是单独的**USB接口**(用struct usb_interface表示)，在sysfs中均表示为单独的设备(这是因为这2个结构都包含一个struct device结构)。 例如, 对于一个简单的只包含一个USB接口的USB鼠标, 下面的内容给这个设备的sysfs目录树:
                       HostController usb_device   
/sys/devices/pci0000:00/0000:00:1d.1/usb2/2-1
|-- 2-1:1.0 **usb_interface  **        
| |-- bAlternateSetting    接口描述符信息
| |-- bInterfaceClass
| |-- bInterfaceNumber
| |-- bInterfaceProtocol
| |-- bInterfaceSubClass
| |-- bNumEndpoints
|
|-- bConfigurationValue    设备配置信息
|-- bNumInterfaces
|-- bMaxPower
|-- bmAttributes
|-- bDeviceClass           设备描述信息
|-- bDeviceSubClass
|-- bDeviceProtocol
|-- bMaxPacketSize0
|-- idVendor
|-- idProduct
|-- bcdDevice
|-- bNumConfigurations
|-- devnum                设备信息
|-- maxchild
|-- product
|-- serial
|-- speed
|-- manufacturer

    结构usb_device在树中被表示在:
    /sys/devices/pci0000:00/0000:00:09.0/usb2/2-1

    而鼠标的USB接口(USB鼠标驱动程序所绑定的接口)位于如下目录:
    /sys/devices/pci0000:00/0000:00:09.0/usb2/2-1/2-1:1.0

    我们将描述内核如何分类USB设备，以帮助理解上面这些长长的设备路径名的含义。

    第一个USB设备是一个__根集线器__(root hub)。 这是一个USB控制器(控制器器和根Hub集成在一起)，通常包含在一个PCI设备中。之所以这样命名该控制器，是因为它控制着连接到其上的整个USB总线。该控制器是连接PCI总线和USB总线的桥，也是该总线上的第一个USB设备。

    所有的根集线器都由USB核心分配了__唯一的编号__。在我们的例子中，根集线器称为__usb2__，因为它是注册到USB核心的第2个根集线器。单个系统中可以包含的根集线器的编号在任何时候都是没有限制的。

  __  USB设备__usb_device的名字: 根Hub的编号 + - + 设备所在的端口号 。 例如: 2-1
    USB总线上的每个设备都以根集线器的编号作为其名字中的第一个号码。该号码随后是一个横扛字符(-)和**设备所插入的端口号**。因为我们例子中设备插入到第一个端口，1被添加到了名字中。因此，USB鼠标的名字是2-1。因为该USB设备包含一个接口，导致了树中的另一个设备被添加到sysfs路径中。

    __USB接口__usb_interface的命名: USB设备的名字 + : + USB配置编号 + . + 接口编号。 例如: 2-1:1.0
    USB接口的命名方案是设备名直到接口为止:在我们的例子中，是2-1后面加一个冒号和**USB配置的编号**，然后是一个句点和**接口的编号**。因此对于本例而言，设备名是2-1:1.0，因为它是第一个配置，具有接口编号0。

    概言之，USB sysfs设备命名方案为:
  __  root_hub-hub_port:config.interface__

    随着设备更深地进入USB树，和越来越多的USB集线器的使用，集线器的端口号被添加到跟随着链中前一个集线器端口号的字符串中。对于一个两层的树，其设备名类似于:
  __  root_hub-hub_port-hub_port:config.interface__

    从前面的USB设备和接口的目录列表可以看到，所有的USB特定信息都可以从sysfs直接获得(例如，idVendor、 idProduct和bMaxPower信息)。这些文件中的一个，即bConfigurationValue，可以被写入以改变当前使用的活动USB配置。当内核不能够确定选择哪一个配置以恰当地操作设备时，这对于具有多个配置的设备很有用。许多USB调制解调器需要向该文件中写入适当的配置值，以便把适当的USB驱动程序绑定到该设备。
    sysfs并没有展示USB设备所有的不同部分，它只限于接口级别。设备可能包含的任何可选配置都没有显示，还有和接口相关的端点的细节。这些信息可以从usbfs文件系统找到，该文件系统被挂载到系统的__/proc/bus/usb/__目录。/proc/bus/usb/devices文件确实显示了和sysfs所展示的所有信息相同的信息，还有系统中存在的所有USB设备的可选配置和端点信息。usbfs还允许用户空间的程序直接访问USB设备，这使得许多内核驱动程序可以迁移到用户空间，从而更容易维护和调试。USB扫描仪是一个很好的例子，它不再存在于内核中，因为它的功能现在包含在了用户空间的SANE库程序中。

