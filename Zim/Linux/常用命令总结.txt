Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2011-08-03T14:02:15+08:00

====== 常用命令总结 ======
Created Wednesday 03 August 2011

http://blog.csdn.net/wei2856059/article/details/6642647
[RedHat学习笔记]总结现学的所有命令（RH033）,以及相关概念。
分类： Redhat笔记 2011-07-29 07:47 73人阅读 评论(0) 收藏 举报
注：所有的命令都用"【COMMAND】"的形式捕捉，查找相关命令的时候请用【?】的形式查找。方便准确。
=============================================================
【Linux】的【哲学思想】：
1.一切皆文件
2.Linux主要由短小，且目的单一的程序组成（所以一个命令一般只干一件事）
3.将多个短小的程序串联起来可以完成复杂的任务
4.尽量避免捕获用户接口（尽量避免跟用户进行接触，从发起-->回车，全自动，不需要用户再操作）
5.通过文件保存软件的配置信息（只需要一个简单的文本编辑器就可以操作整个系统）
=============================================================
【locale】命令：查看所支持的语言编码
  locale -a 可以查看Linuxs所支持的所有语言的编码方式
-------------------------------------------------------
用【who】命令可以查看都有谁在。
用【tty】命令，可以看当前登录的是什么终端。
用“startx”+“& 这个命令会在F7对应的位置上启动一个图形化的工作按钮
用 startx -- :1 :1表示第一个图形化屏幕
    startx -- :2 这样的命令可以启动多个其他的图形界面
-------------------------------------------------------
按着shift+pg up 或者pg down可以实现上下翻屏，查看其他的内容
      按Ctrl+Shift+C进行复制，
      粘贴时是Ctrl+Shift+V
-------------------------------------------------------
  在etc下的【inittab】文件，右键，使用文本编辑器
  更改为id:3就会在启动时变成字符界面
-------------------------------------------------------
【全局有效】的配置文件：
        /etc/profile , 
        /etc/profile.d/*  , 
        /etc/bashrc
      
【局部有效】的配置文件们：
      ~/.bash_profile
      ~/.bashre,
      ~/.bash_.logout
      
      这些文件分两类，
      1是profile类
        通常是用来设置环境变量的。
        用来运行一些命令的（用户登录时要执行的命令）
      2是bashrc类
        一般来讲是用来设置别名的
        用于设置本地变量
        
 shell对用户来讲，分为两大类。
 1 交互式登录式shell ,以一个用户的身份登陆进去，你可以在这里面输入命令的这种登录
      【读取次序】：（越靠后优先级越高）
      /etc/profile --> /etc/profile.d/* --> ~/.bash_profile --> ~/.bashrc --> /etc/bashrc
 2.非登录式shell  :当一个脚本系统能开机自动运行的shell
      【运行次序】：
      ~/.bashrc --> /etc/bashrc --> /etc/profile.d/*
-------------------------------------------------------
【如何使修改后的登录设置立即有效】?
      使用【source】 命令，重读一下配置文件
      source /etc/profile
      使用“【.】” 命令，重读一下配置文件
      其实 . = source 
      比如 . /etc/profile
             不建议使用source ，会影响到其他变量的使用。
-------------------------------------------------------
  如何实现【用户管理】
  1.什么是用户 【User】 :
       是一个使用者获取系统资源的凭证，是权限的结合，为了识别界定每一个用户所能访问的资源及其服务的。只是一种凭证。会有一个表示数字，计算机会首先跟这个数字相匹配。ID号。一般来讲用户名是公开的。
       还要有个一个验证机制，来验证用户就是那个它所声称的那个人。（密码其实是最不可靠的方法）
  2.什么是组  【Group】 :
       一个组，可以识别是一个权限的集合，而且任何加入这个组的人都自动拥有这个组的权限。计算机靠GID（组ID）来识别.
       一个用户组也是有密码的。一般的用户不能随便加入某个组中，需要用管理员协助。密码的作用是让一个没有管理权限的用户临时的加入某组
       
       组分成两种组：（linux下任何一个用户必然会属于某一个组，即便没有分组，系统也会给你分一个跟你同名的组）
              1.私有组：这个里面只有一个用户，而且这个用户名跟组名同名。也叫用户的基本组
              2.公共组 ： 也叫共有组。也叫用户的额外组，或者附加组。
           一个用户可以同时拥有多个组。
              
       UID,GID：其实是保存为无符号十进制数，用十六位二进制表示，0~65535
          UID, GID和UID的编号相同
            管理员的ID号，永远为 0 （root）
            id 命令+ 用户 ，可以查看用户的id以及组。
            
            1-499 ：属于系统用户，让某个程序运行的时候能以某个用户的身份运行。
            500-65534：普通用户
            65535：Nobody特殊用户（也有可能是65536则，溢出，则为-1，相当于Guest，来宾账号）


3.什么是【权限】  【Permission】
           安全上下文：Secure Context
                 一个进程发起的时候，这个进程所具有的权限，而一个进程所具有的权限跟用户所具有的权限是相关联的。
                 
            -rw--r-w--    
            r w x -  t :  - 为没有权限， r是读，w是写，x是执行。 t\
                 每三个是一组
                 第一组，属主 rwx
                 第二组，属组 rwx
                 第三组，其他人的权限 rwx
                 
             文件中包含，
                读 r  : cat ,more，查看
                写 w : 编辑文件
                执行 x :能让文件运行起来的权限，默认普通文件都不具有执行权限
             目录中
             读 ： ls，查看
             写 ：能够删除文件，新建文件.
             执行 ： 能够 cd进去 ls -l 来查看的权限
  
             ---  : 000 0
             --x  : 001 1
             -w- : 010 2
             -wx : 011 3
             r--  : 100 4
             r-x  : 101 5
             rw- : 110 6
             rwx : 111 7
-------------------------------------------------------
Linux的文件类型：
 
  1.普通文件
         开头用 “-”表示的
  2.目录文件
         开头用“d”表示的
  3.符号链接文件（软连接文件）
         开头用“l”表示
  4.设备文件
         块设备，用 d 表示。按照随机存取。通常一次存取一个块。(硬盘)
         字符设备，用 c 表示，通常按照线性（有顺序）的方式进行存储，一次存取的一个单位是字节。比如键盘，鼠标显示器等。字符存储是串行的。
  5.套接字文件
         开头用 "s"  表示
  6.命令管道文件
         开头用“p” 表示
-------------------------------------------------------
【passwd信息】
 -rw-r—r--  1  root  root  0  07-18  22:39  1.txt
    第一段：文件属性+后面9个字符，表示权限信息，每3位为一组。
    第二段：数字，表示为当前文件被 硬链接 的次数，一般目录是2次，普通文件是1次
    第三段：属主
    第四段：属组
    第五段：文件大小
           dev文件下没有文件大小，是主设备号，和次设备号
    第六段：是时间，文件最后一次被修改的时间。
    第七段：文件的名称
-------------------------------------------------------    
Linux常见的1级目录，作用以及功能。
  /bin： binary 二进制目录，放的都是命令文件，二进制文件
  /sbin : 管理命令 super bin 只有root权限才拥有的命令。
  /boot : 引导目录，里面放的是系统引导文件，一般放 内核，grub，驱动映射关系表，initrd(ramdesk)。这里面任何一个文件的损坏都可能导致不能启动
  /dev : device，设备文件目录，也叫特殊文件目录（因为这些文件都没有大小， 都为空，但却是访问设备的必备文件）
  /etc ： 配置文件目录，Linux把所有的配置信息都用文本文件保存，这个目录就是用来保存这些文件的。
  /home ：普通用户的家目录。任何用户都在，用户登录进来之后默认就储存的目录
                       /home/USERNAME  
  /lib : library 库文件目录，库文件是没有程序入口的，只能被其他程序调用的二进制文件。
  /media, /mnt ： 这是额外文件系统的挂载目录   （目录和当前目录关联的过程，就叫挂载的过程）
  /misc ：杂项，被动目录
  /opt : 可选的，可选目录，一般作为第三方软件安装位置的目录。
  /proc : 伪目录，假的，这是内核映像的映射，我们可以通过这个目录，跟内核中正在运行的参数打交道。调优的时候要跟这个目录打交道。
  /selinux ： 安全加强linux的目录
  /srv : 跟特定的服务器软件相关，服务器软件运行时所产生的数据文件，运行时临时产生的文件。
  /sys : system 内核中硬件信息的映射，其实也是伪目录，比如磁盘的参数信息，键盘参数信息。调优的时候要跟这个目录打交道。 
  /tmp : 临时文件目录，这个目录的文件通常每隔30天
  /usr : 第三方软件，用户安装的软件，所生成的文件，都在这个目录下， 帮助文档信息等等。
  /var : 经常发生变化的文件所在的目录，如：用户的邮件队列，临时的缓冲地址，日志文件，打印队列，锁文件等等。
-------------------------------------------------------
【用户信息】  "gentoo:x:503:503::/home/gentoo:/bin/bash"
            用冒号分出了7段
            第一段：用户名
            第二段：x （密码），告诉你加密放在了另一段
            第三段：UID号
            第四段：GID（是用户所属的基本组的ID号，私有组）
            第五段：用户的全名（注释信息，COMMENT信息）可以为空
            第六段：用户的家目录
            第七段：用户默认使用的Shell，默认使用Bash。在/bin下
      
    /etc/shells目录下可以显示出所有可以允许用户使用的的shell
    
【用户密码】，Linux 下默认必须有密码，保存在、/etc/shadow
      当加入用户之后会有一行：
            student:$1$8kkXoZno$naC13rWnhoKfcMyiZr5qy9/:15172:0:99999:7: : :
            第一段：登录名
            第二段：加密后的密码（经过MD5散列加密的密码）
                         加密的方式：对称加密
                                            公钥加密
                                            单项加密 （主要目的在于提取数据的特征值，拿到一段数据可以提取这个数据的特征码。）
                                                        特点有：1.单项
                                                                     2.雪崩效应（不管密码有多长，只要初始条件有一点点改动，结果将有巨大的变化）
                                                                     3.定长输出（无论你输入有多长，而加密有的结果都是一样的。）
                                                        经常用的单项加密是
                                                                     MD5(128bit定长输出) , sha1(160bit定长输出) 
                         用户密码为“！！”指没有密码
                        “ $1$8kkXoZno$naC13rWnhoKfcMyiZr5qy9/  ”
                         $1（代表是MD5算法）$杂质（盐）$内容
            第三段：最近一次修改密码的时间（天数，从1970年1月1日起，到上一次修改时间的天数。）
            第四段：密码最短使用期限（天数，相对于上一次密码修改后的天数）
            第五段：密码最长使用期限，密码过期时间（天数）
            第六段：提前多少天提示用户密码快要过期了（天数）
            第七段：密码过期几天之后账号将被禁用（天数），如果已经即将过期，系统会强制让用户修改密码，否则不能登录
            第八段：用户账号使用期限（天数，绝对时间，能让你使用到从1970年1月1日之后多少天。默认是99999）
            第八段：保留。
-------------------------------------------------------
如何使用【BASH】：
已经遇到的功能：history
                          !$ ,Alt+. , Esc+.
                          
       融合了 ksh,csh的优势遵循GPL的shell
     1.  命令行编辑功能：
              Ctrl+a : 直接跳到命令行的行首
              Ctrl+e：直接跳到命令行的行尾
              Ctrl+u：可以删除从光标开始一直到行首的内容
              Ctrl+k：可以删除光标开始处到行尾的内容
              Ctrl+箭头：可以左右一次跳一个单词
     2.  文件名通配：
              让你可以一次性的快速引用多个文件，通配符
			* ： 任意长度的任意字符
                   比如 ls *.log 就是显示所有.log的文件
             ？ ：任意单个字符，只能匹配一位字符
			[ ] : 匹配指定范围内的任意单个字符。
                     比如 [a-z] 则匹配任意一个小写字符
                     [abc]匹配任意其中的单个。
                     在括号里加
                              “^”表示取反
                     其他用法：[0-9]    [a-zA-Z0-9]
                                     [:keyword:] : 表示特定字符
                                        比如 [:lower:] 全是小写字符
                                                [:alpha:] 所有字母 
                                                [:digit:]所有的数字 0-9
                                                [:alpnum:]                                            
                                                [:space:]
                                                [:punct:]
                                                [:upper:]
                                                
                                        用man grep 可以查看详细用法
                                  用法：:keyword:
                                  
                      - + ： 单目操作符，用来表示正负， 也有别的用法。也可以用来表示加减法运算
				* / % ：
                        ! ~ :  按位取反，取负的
                 << >> : 表示二进制移位的。
                               比如：二进制字符串  10100 让往右移一位
                               10100  >> 
                        <= 
                        >= 
                          < 
                          >：  表示比较测试符
                                        ((1)) <= ((10))
                 == ; != : 表示等于或者不等于
                          & : 按位进行与运算（转换成二进制，然后一个个进行与运算）
                          ^ : 按位取异或运算
                          | ：位或
                      && ：逻辑或
                         || ：逻辑与
                        ** ：次方运算
                               比如  A=$[2**3]  表示取 2的 3此方
                    id++ ：先引用它的值再自加
                   ++id  ： 先自加，后引用它的值。
    表达式 ? 表达式1 : 表达式2   简单判断表达式。判断表达式，可以则走表达式1，不可以则表达式2
     表达式1,表达式2：  连接两个表达式
     
     3. 命令行补全和路径补全
           命令补全：（当你进行命令行补全的时候，他会到某些个特定路径下找一个最佳的跟你的user相匹配的命令并显示出来）
                         但是到哪些目录下去找命令呢？
                         echo $PATH
                         可以看到都有哪些路径
               TAB键：敲击可以补齐
               敲击两次TAB :当有多个时，可以查看都有哪些以这个开头的，相当于CCNA里的 con ?
           路径补全 ：（它不会去PATH下去找，而去目录下找。他会到父目录下去找跟你有关的快速补全）
                       比如 cd /etc/a ?
     4.括号展开：
              ~ ：展开为对应用户的家目录。比如 cd ~redhat
              { }  : 他能在命令行展开的时候展开为多个路径。
                    创建 x/y   x/z   x/z/1   x/z/2
                    则用：mkdir -pv x/{y,z/{1,2}}
                   
                    创建 x/1 x/2  y/1 y/2 
                    则用 mkdir -pv {x,y}_{1,2} “_”多项式展开 (小学数学？)
     5.命令展开（命令扩展）               
              $( ) ：把一个命令的执行结果当做参数传递给另一个命令
              `  `  ：（ESC下的那个键） 跟上面意思是一样的，都表示命令引用
              比如：创建一个月日年小时分钟秒的文件名
                       mkdir -pv $(date "+%Y-%m-%d-%H-%M-%S")
              比如：ls -l `which passwd`
                        则引用了which passwd命令显示之后的内容。然后将其内容进行 ls
-------------------------------------------------------
【回顾系统变量】：
    变量有4种类型：
    1.【本地变量】。对子shell是无效的
    2.【环境变量】。不但对当前shell有效，还对子shell有效的。
            声明的时候一定要用 export 来声明，表示导出一个变量
            export A=3 (直接导出)
            或者
            A=3 
            export A 
          Bash为用户准备了许多变量，以支持用户来调用
          系统中到底有哪些环境变量呢？
          
【export】 不带任何选项的此命令，就能看出现在正在被使用的环境变量。
            DISPLAY="" 用于定义你当前桌面在哪个位置显示，哪个屏幕显示
            HISTSIZE=""命令历史当中可以保存过去多少条命令的 （需要记住的）
            HOME= 用于表示当前用户的家目录的
            HOSTNAME= 用于表示主机名
            LANG= 主机语言
            LOGNAME= 登录到当前用户的用户是
            PATH= 外部命令查找的可执行文件的访问路径
            PWD= 显示当前目录
            OLDPWD= 其实就是 cd - 在上一个目录之间前换
            SHELL= 当前shell
            USER= 当前用户
            PS1= 显示头部文件
                     当前环境变量的某些值来替换 \u 用户名 \h主机名 \W 基名 \$ 管理员用# 其他用户用$
                     \! 命令在历史行里是第多少条命令
                     \t 显示时间
                   恢复成原本
                   export PS1='[\u@\h \W]\$' (这是原有方式
                   特殊标识方法
                   '[\033[31m\u\033[0m@\h \W]\]$' 加颜色
                   \033其实是一种ASII码,控制颜色的
                    
【printenv】 显示部分环境变量
【env】 表示你可以在一个指定的环境下运行某个命令
    3.特殊变量。
          也是Bash内置的变量，
              最著名的变量：$?  
              用于表示上一个命令的执行结果，用于看上一个命令是否执行成功了。
              在linux编程中，0 永远表示 上一个命令成功了，如果失败了，会用1-255表示。
              一般来讲，只要是大于0，都是没有执行成功的。但每个错误会有不同的错误返回值。
    4.位置变量。用这个变量本身的位置调用的
          比如$1 $2 $3... . 可以直接向脚本调用参数并应用的
          脚本中
          echo "the first param: $1"
          echo "the 2 param $2"
          echo "the 3 param $3"
          在命令行下 1sh.sh a b c 则直接将a b c 变为 $1 $2 $3
          --------------------------
          扩展：算术运算
          A=2
          A=3
          echo "$[$A+$B]"  则显示结果
          echo "$(($A+$B))" 用$加双括号，也可以显示
          --------------------------
         练习：想命令行传递两个任意整数并算出两个整数的和：
             #!/bin/bash             
             echo "The sum is : $[$1+$2]"
             保存，命令行
             ./sum.sh 4 5 : 则内部将4直接赋值给$1 ,5赋值给$2 并显示运算结果
==========================================
【passwd】 回车就可以改密码了，不需要输入老密码，可以直接改新密码
  作为普通用户来讲，需要输入老密码，然后才能改新密码。
 
  passwd student 可以改另一个用户的密码。
-------------------------------------------------------
【su】 命令  ： Switch User
        格式：
            su [option] [arguments]
        不加命令是默认进管理员
                      su student 半切换到student目录下
                      su -l student  完全进入student用户，或者：
                           su - student    
-------------------------------------------------------        
【history】 可以看到你之前所使用过的命令：命令历史。最多保存1000条
               想快速执行之前的可以用↑箭头往上翻。也可以用
               “!n”就可以快速使用那个数字n所代表的命令。
               “!字符串”代表使用命令历史中离你刚输入最近的那条，以这个字符串开头的那个命令
               “!!”用以表示使用上一条命令，就是刚用过的那条命令，重复一遍
               “!-n”用于执行倒数第n条命令。
                 history -c  ：清除历史中的命令。       
【HISTCONTROL】参数：
                ignorespace:忽略以空格开头的命令
                ignoredups：忽略重复的命令
                ignoreboth:空格开头和重复的都忽略
         使用方法：     
         export HISTCONTROL=参数               
                撤销HISTCONTROL的控制：
                      unset HISTCONTROL
-------------------------------------------------------
【clear】,清屏
           !$:表示引用上一条命令的最后一个参数
           按住alt+"."，也可以直接实现
            按一下ESC，再点“.”号也可以实现引用上一条命令的最后一个参数
-------------------------------------------------------
【nano】 命令
           nano /etc/inittab  可以直接打开inittab文件
           进入之后，进入nano编辑器，下方有提示
           O：保存退出
           R :读取文件
           Y：下一个页面
           V：后一个页面
           K：剪切
           U：粘贴
-------------------------------------------------------
【ls】命令  ----> list  
              用于显示某一个文件的属性，或者某一个目录旗下子目录的属性。
              ls : 显示目录，文件
              ls /etc/inittab 直接显示这个文件
              ls /： 直接显示根下的文件和子目录
              ls /etc 显示文件夹含有的目录
        显示要遵循 FHS 文件结构
        对于任何一个Linux发行版，要遵循Linux 的文件发行规范。
        ls   常用的选项
               -l :显示目录/文件内详细信息。比如 ls-l /etc 则显示etc目录的详细信息
               -h : 将文件信息中的大小变成人类易读的
               -a : 显示所有文件，包括隐藏文件
               -A : 不显示“.”和“..”这两个特殊目录
               -d : 显示的是目录自身的属性，而不是目录中文件或者子目录的属性
               -r : 显示目录，将以逆序的方式进行排序。从Z-A
               -R : 递归现实，显示目录下的每一个文件和子目录，如果目录还有子目录，则继续显示子目录下的文件和子目录，直到显示完全。
               -i : 选项可以提供inode
-------------------------------------------------------
【cd】:切换目录，Change Directory
         cd :   不带任何参数表示切换回当前用户的家目录
         cd /path/to/dir ：切换到指定目录
         cd - ：表示在上一个目录和这个目录来回切换，类似于电视遥控器上的返回之前
         cd ~ :切换回当前的家目录。
                          cd ~student ：表示切换到别人的家目录
         cd .. : 可以切换到当前目录的父目录
         cd ../.. :可以切换到当前目录父目录的父目录
          
【pwd】 : Printing Working Directory 显示当前目录，/显示工作目录
-------------------------------------------------------
【mkdir】：创建目录
          格式： mkdir /path/to/abc
                -p : 如果创建的目录的父目录不存在的话，则先创建父目录。  mkdir -p /tmp/x/y/z   
                -v : 显示创建的过程
【tree】 : 显示结构的目录树。
          tree /tmp
-------------------------------------------------------
【rmdir 】, 删除目录：
              只能删除空目录。
              rmdir /tmp/x/y/z
            但是不能删除含有内容的父目录。
-------------------------------------------------------
【mv】：剪贴目录（移动目录）：
         mv SOURCE DEST       mv+源目录+目标目录 。
          移动的时候可以是非空的
         比如将tmp下的x1 挪到 var 的x1
         mv /tmp/x1 var/tmp
         如果在移动的时候，源路径和目标路径相同，则是重命名
         比如 mv x1 xx 则是将x1目录更名为 xx
         
         mv /tmp/x var/tmp/y
                如果y不存在 则是 移动x并重命名为y
                如果y存在
                      看y是否是文件，若是则，报错
                      若不是，则将x移动至y目录下 
-------------------------------------------------------
【 touch】 用于修改时间戳的，但是可以用于创建空文件
    touch a.txt    如果文件并不存在，则会创建一个空的文件。
                          如果存在，则会试图去修改它的时间。所有的时间都会变为当前时间
              -a  修改它的访问时间
              -m 修改它的修改时间
              并且可以改变到特定时间。
              touch -m -t 可以修改文件时间戳
-------------------------------------------------------
【mktemp】 命令 ： 【创建临时文件】
        mktemp /tmp/eth.XXXXXX  创建/tep/eth.XXXXX , 这个自动会将XXXXX随即赋值，防止重复
          -p 选项，指定位置。
              mktemp -d /tmp eth.XX
          -d 选项：创建临时目录
              mktemp -d /tmp/test.XX  则创建test.XX的目录。
              
       一般将他创建的文件/目录 引用起来，赋予某个变量
       比如：
            TMPFILE=`mktemp /tmp/eth.XXXXXX`
-------------------------------------------------------
【rm】命令
     rm a.txt   删除a.txt
                     在管理员权限下，会出现提示信息（redhat自带的）
                -i : 删除时提示是否删除。
                -r : 后面可以跟目录，则直接删除非空目录下的文件    *********可以删除非空目录***********
                -f : 不提示，直接删除
-------------------------------------------------------
【cp】命令
      cp SOURCE DEST
               cp /etc/inittab  /root/a.txt
               复制inittab 到   xxx
      cp a b c d  ：copy a b c 到 d,d必须为目录      
      cp /etc/inittab ./a.txt
                 复制inittab到当前目录下的a.txt
          复制是不复制目录的，如果想复制目录，则加
                 -r : 复制目录以及目录中的所有文件
                 -i : 如果目标目录有同名，则提示是否覆盖。
                 -p : 保留保存，主要用于保留属主属组
                 -a = -rp
        备份小技巧：
        cp /etc/sysconfig/network-scripts/{ifcfg-eth0,.bak}
        直接备份
-------------------------------------------------------
【mv】SOURCE DEST
-------------------------------------------------------
【stat】 xx 用于显示文件的元数据信息，可以看出有3个时间 
           Access 时间，表示最近一次被访问的时间
           Modify 时间，最近一次被修改的时间（指文件内容改变了）
           Change 时间，最近一次被改变的时间（指文件属性改变了）
==========================================
【file】 ：命令
           file FILE_NAME         file后面跟文件名
           通过这个命令，可以区别文件的不同类型，也可以判断是否是目录。
-------------------------------------------------------
【hwclock】 命令，用于设定时间
              -w ： 表示我的系统时间是准确的，能够实现把硬件时间设定为与系统时间一致。
              -s ： 表示硬件时间是准确的，把系统时间设定为与硬件时间一致
    
【date】     读取系统时间          
【clock】    读取其硬件时间                、（查看硬时间）
-------------------------------------------------------
【date】 命令，用以显示系统的当前时间。（查看软时间）
          date 命令，还可以设定时间 格式为：
                   date mmddHHMMyy.SS
                   date 月日时分年.秒
                   比如：
                            date 1212121212.12
                   则：时间为，2012年，12月，12日，12时，12分，12秒
          date命令还可以指定时间显示格式：
                   date +FORMAT
                   比如：
                            date "+%H" 只显示小时
                             +%H   显示小时
                             +%M  显示分钟
                             +%S   显示秒
                            date "+%H:%M:%S"显示时分秒
                            +%y    显示年
                            +%Y    显示年的全称 2012
                            +%m   显示月
                            +%d    显示天
                            +%D   显示日期
                            +%F   直接显示年月日
                            +%T   直接显示时分秒
                            date "+Today is %Y-%m-%d"
                    date命令中分号内是可以加任何字符的。%X是宏命令。
           date命令在备份的时候尤其有用。     
           
           特殊时间戳：
                   date "+%s" ：表示自1970年1月1号0点0分0秒 到今天，一共过了多少秒 
-------------------------------------------------------
【cal】 命令 ： 用于显示日历 直接显示当前月
            cal 2011  : 则显示全年
            cal 1 2011 ：则显示2011年1月 [cal 月 年]
            
            最特殊年月
                  cal 9 1752 : 少了3-13号，这是程序员的失误。
-------------------------------------------------------
【which】 命令：用于查看一个命令所对应的二进制文件在什么位置 
              which cd 
              which ls 
   
【type】  命令： 直接查看是什么命令：
              type cd 
              tpye ls 
-------------------------------------------------------
【man】 COMMAND ：详解
      man 为命令提供的使用手册都是分章节的，
              man N COMMAND  : man+章节+命令 直接看该命令在该章节的帮助信息
      
     一般章节：
            第一章节：存放大部分普通用户的命令
            第二章节：显示系统调用
            第三章节：库调用 （关于库信息的说明）
            第四章节：特殊文件（块设备，字符设备）
            第五章节：文件格式 （配置文件的说明，对命令的配置文件的语法进行的说明）
            第六章节：游戏说明
            第七章节：杂项
            第八章节：管理类命令（跟系统相关的只有权限人才有权利执行的命令。比如useradd(添加用户)命令）
            
      whatis COMMAND 查看COMMAND命令在哪一章节。
            手册为了防止庞大，都用压缩的形式进行存放：
            存放位置：usr/share/man
                  *.gz文件：gzip文件，压缩文件
                  
      man命令 先到 地方找到命令的手册页，然后将其解压缩。然后才看到了命令的man手册
      
      man命令查看后其实是遵循一些语法规范的：
            NAME : 用以表示简单的说明
            SYNOPSIS : 命令的简要语法格式
            EXAMPLES : 给你命令的使用样例。
            OPTIONS:选项
            FILES : 跟哪个配置文件相关联。
            DESCRIPTION : 描述信息，用于详细描述命令的功能以及详细的选项，以及选项所对应的意义
            AUTHOR : 命令作者
            REPORTING BUGS : 如果发现BUG了，怎么办
            COPYRIGHT : 版权
            SEE ALSO : 另外说明
            
       用man命令打开手册页后，如何实现上下翻页？
            空格键：可以直接往下翻一屏
            B    键：往前翻一屏
            回车键：往下一次翻一行
            K    键：往文件头一次翻一行
            
       如果不知道man命令怎么用：
            man man 
       man有个选项，可以显示类似于whatis命令的显示结果
            man -f COMMAND ，跟使用whatis的效果是一样的。
       问题：man的-k选项，和-K选项有什么用呢？
            -k指的是keyword，关键词，
            man -k COMMAND ：可以提供哪些命令里面包含COMMAND (他是从whatis数据库中找的)
            -K是从man数据库找到所有的关键词信息，数据量非常庞大。一般不用，查找速度将巨慢无比。
       
       当使用完man后，想退出的话，使用Q键就可以退出
       而且man支持关键词搜索：
                      输入一个斜线“/”然后加关键词，所有关键词会用反黑显示（/是表示从文件首部向文件尾部查找）
                      也可以使用问号“?”跟上关键词，同理 （?是从尾部向首部查找）
               搜索完关键词后，光标会指到第一个关键词上，
                      用 n 和 N 在 下一个 和 上一个 之间进行切换。
-------------------------------------------------------
【cat】 命令： cat + 文件
          concatinate, dump
       功能1，连接，cat可以将多个文件连接到一起。显示出来。
       功能2，dump.倾倒式的查看，瞬间翻至最后一页。
       
       但在某些场景下是很有用的，比如将某些文件显示出来并将它重定向到某地
       比如某文件：cat /etc/sysconfig/network这个文件很小。
       cat会直接查看，查看完后直接退出查看器。
       
              -n : cat可以在显示的时候显示行号，行号不是文件本身的内容
              -E : 用于显示行结束符，会加入 $ 符，是Linux中的行结束符。Windows的行结束符比Linux多1
              
       tac是反着倒……
       
       cat的特殊用法
       cat >>haha<<EOF   (eof标示) 
       > 123
       > 456 
       > 789
       > EOF
       从EOF开头，到EOF结尾的东西，追加到haha中。


-------------------------------------------------------
【more】命令   ：more + 文件
          more，可以分屏显示内容，并且给出显示的百分比
          more的向前翻腾是有问题的，用B键可以使用向前翻页，所以很多教材只介绍more可以向后翻页，不能向前翻
          more 翻到最后之后会自动退出。所以这也是为什么他不能向前翻的最重要原因
-------------------------------------------------------
【less】命令  ： less + 文件
          less可以向前翻，而且翻完之后不会自动退出，会显示
                                 [END]
          实际上,man命令其实调用了less命令的查看方式，所以man支持的，less都支持。
          less命令也是将来用的最多的命令之一。
-------------------------------------------------------
【tail】,【head】命令 ：
           head 命令用于查看文件前 N行  (默认为10行)
           tail 命令用于查看文件的后 N行  （默认为10行）
              head -n 20 
              head -20  都代表看前20行
              tail -n 22 /var/log/messages
              tail -22
                  tail  -f 命令，查看文件而不退出，并且实时显示信息。
                  不想看了，用ctrl+C，则退出。
             
             *当你写了一个命令不想执行的话，用CTRL+C直接返回。
             */var/log/messages 是系统日志，我们经常用tail命令查看其内容
-------------------------------------------------------
【wc】 命令 ： 用于统计一个文件有多少行，多少单词，多少字节
           wc /etc/rc.d/rc.sysinit
           显示
            980   3946  27239    对应，行/单词/字节
                 -l ： 只显示有多少行
                 -w : 只显示有多少单词
                 -c ：显示多少字节（字节包含空格）
                 -m : 显示多少字符
                 -L : 显示文件中最长的行有多长
-------------------------------------------------------
【sort】命令
对文件进行排序。
不会影响文件本身的内容，只是将排完序之后文件的内容输出出来。
-u：可以移除排序完成之后，重复的行 uniq
-n : 按数字排序 numeric
-r：降序排序 revers
    -t : 以指定段分隔符
    -k：以第几个字段进行排序
            sort -t : -k 3 ,以 ：为分隔符，对第三段进行排序
-------------------------------------------------------            
【uniq】 : 移除重复的行=sort -u
     -u：只输出只显示那些没有重复的行。
     -d：只显示重复了的行（跟上面刚好相反）
     -c：显示行以后，能告诉你这个行最多出现过几次（用于做计数）
-------------------------------------------------------
【chown】 修改属主
        格式：chown [options] USERNAME [files]
        比如：chown gentoo a.txt  则是将a.txt的属主更改为gentoo
              一个命令可以同时修改属主属组
                   chown USERNAME:GRPNAME files
                   或者  
                   chown USERNAME.GRPNAME files
                   或者
                   chown :GRPNAME files 只修改组，不修改主
         当你用其改变一个目录的属主的时候，里面的文件的属主不受影响
         
         如果想一起修改目录里的文件则
              -R : 递归修改。
                   比如 chown -R slackware test :修改test文件夹的属主为slackware并递归
             
              --reference=FILE 将某个文件/目录的属主和属组改为和某人一样
                   比如： chown --reference=a.txt b.txt 将b.txt的属主和属组修改为和a.txt一样
-------------------------------------------------------
【chgrp】 修改属组
        格式同chown
        比如：chgrp mygrp a.txt
-------------------------------------------------------
【chmod】 修改权限
        格式：chmod [options] mode files...   (mode指权限)
             修改方式
                    1.使用数字的方式：chmod 777 a.txt  则是将a.txt的权限更改为 -rwdrwdrwd
                    2.使用等于号的方式进行赋值：chmod u=rw-,go=r-- a.txt  (用逗号隔开可以设置多个) 则是将a.txt的权限中属主部分更改为rw-，属组和其他部分改为r--。
                    3.用+/-修改某一类权限的特定位置  chmod u+x,go-x a.txt 则是将a.txt的权限中属主的部分增加执行权限（x）,将属组和其他的部分去掉执行权限（x）
                              u = 属主
                              g = 属组
                              o = 其他
                              a = 全体
                              
            修改目录的话只会修改其目录的属性，目录内部是不会修改的，如果想
                 -R  ： 请加大写R 递归修改
            
            只有管理员才有权利改文件的属主和属组，其他用户可以修改权限。
-------------------------------------------------------
【useradd】 账号名  ：建立账号：
            useradd gentoo:后，则在 /etc/passwd 下增加了一行
          
          -u UID ： 更改ID号（ID号不能使用别人用过的，更改之后新用户从这个号往后计数）
          -g GID ： 更改用户的基本组
          -G GROUP1,GROUP2  ： 可以指定用户的附加组，可以有多个组，多个组用逗号隔开
          -c “COMMENT”： 可以指定用户的注释信息
          -d /path/to/home  ：指定家目录
          -s /bin/kshell ： 指定一个非默认shell
     比如：
             useradd -G mygrp slackware :则创建用户slackware并将用户slackware加入到附加组mygrp中
     比如：
             useradd -u 1000 oracle :则创建用户oracle并将其UID改为1000       
     比如：
             useradd -g mygrp mysql :则创建mysql并将其加入基本组mygrp中
     比如：
             useradd -s /bin/tcsh centos: 则创建centos的shell指定为tcsh
     比如：
             useradd -d /tmp/hello suse :则创建suse并将其家目录设为/tmp/hello
             
      可以组合使用一次指定多个条件。当指定特定组时，这个组必须事先存在
      在用户的家目录中查看隐藏文件，则发现里面有文件，这些都是环境变量文件。


-------------------------------------------------------
【groupadd】 详解：
         -g GID ：指定GID
 
  useradd和groupadd都有一个共同的指令
        -r 把一个用户添加为系统用户或者把一个组添加为系统组。
-------------------------------------------------------
【userdel】 + 用户名 
       -r ：连同用户及其家目录一起删除。
【groupdel】 + 组名
-------------------------------------------------------
【usermod】 命令，用于修改用户的账户信息。
      -u ：修改 UID
      -g ：修改 用户的组
      -G : 修改附加组。（用户原属的附加组将会被删除，所以一般不单独用）
      -aG :修改附加组一般用这样。
      -s : 修改shell
      -c ： 修改注释信息
      -d :修改家目录。如果你想将家目录的所有东西都移动到新地方的话，要加-M
      -l : 修改登录名称。
      
      还支持其他的几个选项
      -e : 可以指定用户的过期时间。
      -U : 表示解锁用户账号
      -L : 表示锁定用户账号
      
【groupmod】 命令，用于修改组的信息
      -g : 修改GID
      -n : 修改组名
-------------------------------------------------------
【passwd】 命令： 给用户加密
      -l : 用于锁定用户账号
      -u : 解锁用户账号
      --stdin ： （把标准输入改为别的输入）为用户添加密码的时候用非标准输入进行创建密码
      -x : 设定密码最长使用期限
      -n : 设定密码最短使用期限
-------------------------------------------------------
【finger】 命令，用于显示用户的信息
【id】 命令，用于查看用户的id相关信息
【who】 命令，查看当前系统上登录的所有用户的
-------------------------------------------------------
 echo ：  显示 一行文本
               -n ：表示不显示换行符
               -e  :  能解释转义字符，比如显示颜色 （用于表示做控制符用的的叫转义字符）
                      echo -e "How are you?\n" 则\n会被编译成换行
-------------------------------------------------------
【alias】命令：我们可以给命令取上别名。
      alias cls=clear 则可以将clear加一个别名为cls
      alias cdnet='cd /etc/sysconfig/network-scripts' 则将CD这条命令简写成一个词
      
      不想用alias的话
      unalias 命令
      比如
      unalias cdnet.
-------------------------------------------------------
【输入输出重定向功能】，管道：
          默认情况下，当你执行完一个命令，这个命令必然会输出一些信息，但是这个信息输出到了什么位置呢？
          输入设备和输出设备有很多种，大多时候，进行命令时，可能都没有明确说明应该输出到什么地方去，或者从什么输入
          当你不指定的时候，linux会输入输出到默认设备上去。
      -------------------    
      标准输入：0, 一般指键盘 keyboard  
            /dev/stdin  (标准输入设备，显示为浅绿色)，
                              其实是一种链接文件。用ll可以看出它有指向。
                              大多数情况下，我们用0 来表示：文件描述符
             重定向一般用 < 表示
                   比如 
                         cat < /etc/fstab 则将fstab的内容输入到了cat下，并用cat命令显示
      --------------------                   
      标准输出： 1,默认是显示器 monitor
            /dev/stdout  
            重定向一般用 1> 表示
                  比如
                       ls > /tmp/ls.out 则将ls的内容，输出到了 /tmp/ls.out
       --------------------     
      错误输出： 2,默认是显示器 monitor
            /dev/stderr     
            重定向一般用 2> 表示
                  比如：
                        lss 2> /tmp/ls2.out
                  但是当你这个信息是正确时候，它不会输出到指定，而是直接显示
       ---------------------           
       合并标准输出和错误输出的输出流：
       " &> " 使用它可以合并。
       ---------------------
       输出重定向会覆盖文件的原有内容，所以，
       " > "号叫覆盖输出重定向 
       " >> "号叫追加输出重定向,可以追加内容，而不覆盖
       
       很多时候，我们可以使用echo命令，往一个文件的最后一行追加一行文字
       echo "-------------------" >> /tmp/ls.out
       
       ---------------------
       
       当使用“2>>” 时可以追加错误重定向
       但 "&>>"是不支持双大于号来追加所有内容的。
       ---------------------
       有时会出现手误少打一个>导致，直接覆盖了原有内容而导致不得恢复
              set -C 命令，打开了禁止使用覆盖重定向 ，想开启的话
              set +C 命令。关闭禁止使用覆盖重定向
       有时我们就是想覆盖文件的话。
              ">| "符号后面加一个竖线，则表示我清楚我在做什么，我非要覆盖。
       ---------------------    
       如何实现将正确的输出流保存在1.txt ,如果错误，则保存错误到2.txt呢？
             ls /var >> /tmp/1.txt 2>> /tmp/2.txt 
             意思是将 ls /var的输出结果 正确的话追加到1.txt ,错误的话追加到 2.txt 只不过这两个符号要分开使用，中间加空格。
-------------------------------------------------------
【管道】：" | "
          COMMAND1 | COMMAND2 | COMMAND3....
                   
          管道的作用：把前一个命令的输入输出执行结果，当做第二个命令的输入命令来处理。
              比如：ls -l /etc | less
                      则是将 ls -l /etc 的输出结果，在less中输入，则可以使用less 查看
              比如：echo "123456" | passwd redhat
                      将123456的结果通过管道输送给 用户redhat的passwd中。 
         
          可以连接多个命令，不光是两个命令的链接。比如：
              ls -l /etc | sort -t | less 
              反向排序之后送给less查看 
                   
【tee】:会把数据流分成两部分，一部分保存，一部分送给后面的命令
              则，将数据先保存一份到ls.out，再用less命令查看
          既想送给less命令分页查看，又想保存一份到文件里去
              ls -l /etc | tee /tmp/ls.out | less
              
          有多个命令的输出，都需要保存在同一文件。为了实现：
              command >> a.out
              command2 >> a.out
              则可以使用一个变量，用脚本实现。但是麻烦，所以
    自定义输出重定向：可以用（3-9）的数字
              【exec】 : 
              exec 3> /tmp/myout.out  （也可以用追加">>" 或者读入"<" ）
              则将3定向为了 myout.out 其实是覆盖为了这个文件
              之后
              ls /var >&3  （必须用 >& 符号）
              则会将显示结果覆盖至 自定义的一个输出重定向 3中
           在多次重定向的场景里，避免多次的反复重定向的那个文件而导致的频繁打开和关闭。
           撤销：
              exec 3>&-
              这样就关闭了此文件
              
     /dev/null：数据黑洞，设备文件的空文件。会把所有送来的数据吞噬掉。
                      我们可以实现把那些输出出来没用的数据，送到这里
                      这样不会占用任何空间。（属于虚拟设备）
-------------------------------------------------------
【for】：循环执行
        想在系统上加入10个用户，user1,user2.....user10。
        在脚本编程中，使用
        格式：
        for I in LIST; do
             statement1
             statement2
        done
            
    LIST的表述形式：
    简单列表：1 2 3 4
    复杂列表： This is Tom\'s cat (此时里面的小分号不被LIST识别，需要转义符)
    变量  `seq 1 $LINES`
    命令  `ls /var`
    通配符 for I in /var/*
        
        第一次，它将I的值取为1，LIST1 之后执行一遍
        之后将I的值取为 LIST2....
        
        for I in 1 2 3 4 5 6 7 8 9 10; do
             useradd user$I
             echo user$I | passwd --stdin user$I
        done           
        则，会自动添加user1-10并将其密码设置为自己的用户名。
        --------为了方便--------
        1.  【seq】 1 10 : 表示，以1开始以10结束的数字展开为一个序列，但是使用的时候要用命令替换
        比如
           for I in `seq 1 10`; do
        2.  {1..10} ：也表示取整数序列，从哪开始，从哪结束。
        
        为了一次能从/etc/passwd下取一行,简单的可以使用：
          for LINE in `cat /etc/passwd`; do  
                                 ^
         
        对于for来说，它识别的是列表，它识别列表的时候，是通过空格来进行分割的  IFS=$'\n' 
         但是空格，TAB，换行符都被LIST识别为拆分
         
         为了避免空格被拆分成一个独立的值去计算，需要在拆分前告诉LIST，
         只需要修改$IFS的值为只识别换行值：
        IFS=$'\n'
-------------------------------------------------------
【cut】 : 将文本内容一行一行的按照某种格式给他剪裂开来
        -d ：用于指定分隔符。“d:”以“：”分割
        -f : 用于指定取第几段 -f1 则为第一段
        比如
        tail -1 /etc/passwd | cut -d: -f6,7 
        则以：为分割，取第6段和第7段 
        
        LINES=`wc -l /etc/passwd | cut -d" " f1`
        echo $LINES
        行数统计，统计完成之后，对每一行进行切割，再向用户进行问好
-------------------------------------------------------
【grep】 命令： 全面搜索正则表达式并显示出来，它是一个家族，家族中分别有
     1.grep   
     2.egrep
     3.fgrep
     正则表达式(re)：其实就是元字符，用一堆的元字符组成，按照一定的规则组成起来，能够实现过滤匹配不同的文本内容。
           1.基本正则表达式
           2.扩展正则表达式，比基本略多


    ----------- 
     格式
     grep [options] "PATTERN" file   能够根据你所指的模式(PATTERN)，从文件中将他找到并显示出来
      比如：
        grep 'root' /etc/passwd
        搜索/etc/passwd中的含有root的信息
        
        常用选项
            -i : 不在乎字符的大小写
            -v：跟默认的动作正好相反（取反），只显示那些没有匹配的
            -n：能够显示所匹配的行在文中所处得行号（行号显示）
            -An：显示结果，并显示结果之后的n行
            -Bn：显示结果，并显示结果之前的n行
            -Cn：显示结果，并显示结果的前 和 后 n 行
            -e : 支持 egrip
            
            --color：会把匹配这个模式的字符串高亮显示
            
【正则表达式】         
         常用模式 ：正则表达式种类
            ^   定义行首，行首匹配锚定符
            $    定义行尾，行尾匹配锚定符
            .     匹配任意单个字符，相当于"?"
			* 次数匹配，表示匹配符前面的这个字符所出现的0次或者任意次。
            ?    次数匹配，表示匹配符前面的这个字符所出现的0次或者1次。
            [  ]  匹配一组字符中的任意一个字符
            [x-y]  匹配指定范围内的一个字符
            [^ ]   表示否定
            \<  词首定位符，必须是单词，而不能是字符  或者 \b 也可以
            \>  词尾定位符  \b 也可以。
            \<..\> 精确匹配
            \(..\)  匹配稍后将要使用的字符的标签
            x\{m\}  表示x精确出现m次
            x\{m,\}  表示x至少出现m次
            x\{m,n\} 表示x至少出现m次，且不超过n次
            
            grep --color "root$" grep.txt   表示root必须出现在行尾
            grep --color "\<root\>" grep.txt  表示要精确匹配root这个单词
            grep --color "root\{1,\}" grep.txt 至少匹配1次
            grep --color "root\{1\}" grep.txt 表示精确匹配1次
            grep --color "root\{0,1\}" grep.txt 表示至多出现 1次
            grep --color "\(root\).*\1able" grep.txt 
            包含了root中间跟了任意字符，后又跟了\1又出现了引用最前面的字符的以及 able字符的字符
-------------------------------------------------------
【egrep】，【grep -E】
      与grep基本相同，但是没有了 \()之类的字符
        {n} : 精确匹配前面的 n次
        + ：匹配一个或多个+号前的字符，相当于 \{1,\}
        ?   : 相当于\{0,1\},匹配此前的字符，1次或0次
        a|b : 匹配a或b
        ( ) : 字符组，把括号里的当做一个单位 
-------------------------------------------------------
【$?】  : 表示上一个命令的执行结果 ，表示执行成功了还是失败了。
  结果显示：
  0 ： 成功了
  1-255 ： 都表示失败了
-------------------------------------------------------
【&&】【与操作】
   command && command： 这表示 只有前面的命令成功了，才执行后面的命令     
      1 && ？ = ？ 意思是前面的命令即使执行成功了，也需要执行后面的命令，才能判断结果是否成功
              即： 短路操作、
              只要前面为0，结果肯定为0
  
【||】  【或操作】
   command || command  : 如果前面不成功，后面的才执行
      短路操作：
      1 || ？ = 1 ：前面已经成功的时候，后面就不执行了，直接判定成功
        只要前面为1，后面肯定为1 
      0 ||  ？ = ？
        若前面不成功，则必须执行后面的命令才行
   
   grep "root" /etc/passwd || useradd root
   判断是否需要执行这个用户，如果前面否定，则执行后面，意思是，若没有用户，则创建。
-------------------------------------------------------
【sed】 : 
     stream editor : 非交互式的，行编辑器。
     SHELL脚本编辑器的利器之一。
    《Sed adn awk》这本书就是专门来讲这两个命令的。
    没有破坏性，不修改原文件（只是把文件的内容读取到内存里），除非使用shell的重定向
    sed本身还支持sed脚本
    将查不到的内容直接显示出来
    模式空间：
              sed用他的模式去处理文本的时候，在内存中的那段空间。
              读取行--->放入内存,进行处理----->输出这一行
              在某些高级模式中，还可以实现处理一次很多行
              Sed是将源文件处理在了内存里，对文件没有任何影响
              
             Sed的使用格式:
             1.sed [options] /PATTERN/COMMAND files...  
             (指定模式)模式需要用两个斜杠括起来。当你使用正则表达式时，需要使用引号
                 比如
                 sed /cache/p /proc/cpuinfo
                 将cpuinfo里包含cache的那一行，再显示一遍。            
             2.sed [options] ADDR1,ADDR2/COMMOND  files...
             sed [options] ADDR1,+N/COMMOND  files...  【从第几行开始往后的N行】
             sed [options] /regexp/,/regexp/COMMOND  files... 【从哪个单词到哪个单词】
             (根据行来指定命令,ADDR1,ADDR2意思是从第几行到第几行，支持模式)
                 比如
                 sed 1,3p /proc/cpuinfo
                 将cpuinfo 里 1-3 行的内容输出
                 
                 比如
                 sed /cache/,/wp/p /proc/cpuinfo
                 另外一种地址表达方式：
                 查找从第一个/cache/表达开始的行开始，到最后一个一个表达/wp/的行结束，以p模式显示
              
          模式： 
                 p:用于打印行
                         比如
                         sed /cache/p /proc/cpuinfo
                         将cpuinfo里包含cache的那一行，再显示一遍。
                         sed -n /^[^Cc]/p /proc/cpuinfo
                         以非C开头的行，第一个用于表示以xxx开头，第二个表示取反
                 d:用于删除模式空间中被匹配到得行
                         sed /^[Cc]/d /proc/cpuinfo
                         以非C开头的行
                 a\后跟内容: 在当前行后添加一行或者多行
                     sed "/^processor/a\#This is my cpu." /proc/cpuinfo
                     以processor 开头的行后添加一行后添加一行：This is my cpu.
                     sed "/^model/a\#This is my cpu" /proc/cpuinfo
                 i\后跟内容：表示在当前行的前一行追加一行或者多行。
                     sed "/^model/i\#This is my cpu" /proc/cpuinfo
                     则在model前加了一行
                     sed "/^model/i\#This is my cpu. \n#haha" /proc/cpuinfo
                     在mode后加一行后，用\n的形式换行，然后再添加一行
                     
                     用\n 的换行符形式，可以在内容后换行，再继续添加
                     
                 s:表示查找，替换。 （用法格式非常奇怪）
                      sed "ADDR1,ADDR2s/要找的串/要换成的串/ig" /proc/cpuinfo 
                      搜索的串可以使用正则表达式，而替换的串不能使用正则表达式
                      (s///)中的///其实是可以替换的，比如替换成s@要找的串@要换成的串@，或者替换成其他的比如AAA
                      
                      ADDR1和ADDR2表示从哪一行开始，到哪一行结束、  
                      i表示不区分大小写
                      g表示在行内进行全局替换 
                      
                      sed '1,$s/yes/YES/g' /proc/cpuinfo
                      在指定范围匹配的时候 $表示一个文件的最后一行
                      这句的意思是：    将文件中所有的yes替换为YES,全局替换，从第一行搜索到最后一行。
                      
                      s支持正则表达式
                      sed '1,$s/\bc/C/g' /proc/cpuinfo   (记住\b是匹配单词的首部)
                      替换文件下所有以c开头的单词，并替换成C
                  
                  &:保存查找串以便在替换串中引用
                     能够匹配整个串
                     sed '1,$s/\b[Cc]pu\b/&s/g' /proc/cpuinfo
                     将所有以Cpu替换成后面加一个s
                     
                     sed '1,$s/\b[Cc]:alpha:*\b/&s/g' /proc/cpuinfo
                     将所有以C开头的单词，后面加s
                                       
                  \(..\):保存已匹配的字符,然后用 \1 可以读取匹配的字符
                     
                  -e: 允许多项编辑,为一个命令指定多个处理办法
                          sed '1,$s/\b[Cc]:alpha:*\b/&s/g' /proc/cpuinfo | sed '1,$s/\b[m]([[:alpha:]_]*\)\b/M\1/g'
                          sed -e '1,$s/\b[Cc]:alpha:*\b/&s/g' -e '1,$s/\b[m]([[:alpha:]_]*\)\b/M\1/g' /proc/cpuinfo
                      【早上9:40】
                  -n:取消默认的输出。
                  -f:可以把-e后面的内容写进一个文件里，并直接把这个文件读出来 【sed脚本】
                       sed -f 去读 files  （去读是一个文件，文件的内容是下面的两行）
                         '1,$s/\b[Cc]:alpha:*\b/&s/g' 
                         '1,$s/\b[m]([[:alpha:]_]*\)\b/M\1/g'
                 
                  -i: 去修改源文件。
-------------------------------------------------------
【tr】 ：转变转换
        tr [options] 'ab' 'AB'
        则可以实现各种转换。
           -d : 可以用于实现删除字符
             比如，想删除一个单词中间的字母a
             tr -d 'a'
-------------------------------------------------------
【awk】：  （念：奥克）
     比sed功能要强大的多的多的文本命令。有内置变量，本来是个开发语言。
     可以完成强大的文本处理
     最早的版本诞生在Bell实验室。
     到Unix的时候开始支持用户自己的变量。 叫nawk
     从一九七几年到现在都一直存在的命令
     它属于unix的命令。
     在九十年代，为GUN项目，开发了完全开源的awk,叫 gawk。
     此时，awk达到了顶峰。甚至加入了网络的处理
     
     awk [options] 'pattern {action}'
           pattern: 
                 /regexp/
                 exp
                 BEGIN
                 END
           action:
           print
           
     awk [options] 'program' file
     
     program完全可以写成文件，利用-f命令来直接读取所有文件内容
     program样子：pattern {action}  所有的action要以花括号括起来，所有的program要以单引号
                          用什么模式处理， 处理成什么样子
                          所有的action要以花括号括起来，
                          所有的program要以单引号


                                  
     
     跟sed一样一次读一个行，然后将这一个行进行切片（以空格为基础进行切片）（field），每一片可以有一个内容引用
       $1 代表引用第一段
       $2 代表引用第二段
       。。。。
       。。。
       $0 代表整个一行。
       
       输入和输出都以行为基准，都将其切片，不光切片一行，如果有多行，还对多行的每一行以一种方式进行切片（以换行符）
     
       print命令：
       awk '{print $2}' /etc/fstab
           则只显示第2列
           
       awk '/^[a-z]/{print $0}'
       
                          pattern:
                          当你指定pattern，则表示他只对被pattern匹配的行做处理 （正则表达式）
                          1.Expression
                          2.pat1,pat2。从第一个pat1行到符合pat2的行
                          3.BEGIN
                                  通常用于实现改变内建变量的值，或者在输出之前先打印标题的
                                  在action之前先执行的
                             END
                                  在action之后进行扫尾工作。
            
     awk 'BEGIN{print "Devices         mount       point"}{print $0}' /proc/meminfo
     添加标题
      【14:50】
     内建变量：
     FS:修改子段分隔符，改变内建变量的值，要在BEGIN中实现
           tail -10 /etc/passwd | gawk 'BEGIN{FS=":"}{print $1}'
     RS:指定输入的时候行与行之间的分割符（默认是换行符） 
           tail -10 /etc/passwd | gawk 'BEGIN{FS=":";RS=";"}{print $1}'
     OFS:显示数据的时候，显示给别人看的时候，是以什么为分隔符显示（默认空格）
           tail -10 /etc/passwd | gawk 'BEGIN{FS=":";OFS=":"}{print $1,$3}'
     ORS:行于行之间是如何分割的。
           tail -10 /etc/passwd | gawk 'BEGIN{FS=":";ORS=" "}{print $1,$3}END{print "\n"}'
           此条中END就在所有处理完成之后，又加入了换行。
     NF：显示每一行一共有多少个字段
     NR：正在被处理的这一行，在整个文件中处于哪一行
          tail -10 /etc/passwd | gawk 'BEGIN{FS=":";OFS=":"}{print NR " " $1,$3}'
                则在输出的时候显示行号      
                
         -F:    : 以“：”为分隔符。不用BEGIN了。


 如何通过awk的辅助取得ip的地址
 ifconfig | awk '/inet addr/{print $2}' | cut -d: -f2
-------------------------------------------------------
【vim】：文本编辑工具
文本：纯ASII码。 跟word编辑的不是一个东西。
linux的重要哲学思想之一是把配置当做文件放在里面。
linux上很著名的文本编辑器，Vi,emacs。
vi ---> vim 

vim其实是一款模式化编辑器。将需要在多个模式下切换
在不同的模式下，你所发出的命令，会被解释成不同的意义。
命令模式下输入v键，可以进入可视化模式
vi有3大模式最重要
1.命令模式：主要用于命令编辑，删除/打开/保存/退出
2.输入模式：击键的大部分命令都将输入到文本中。
3.末行模式：对模式进行配置，类似于比命令模式繁琐，但功能不输于命令模式的一种模式。不能和输入模式之间进行转换

vim能识别大部分的程序，比如C语言的程序，并高亮显示。

模式转换：
命令-->末行   只需要键入一个 ”：“ 则直接进入末行模式
命令-->输入   方法非常多：
              1.输入 I 命令， i:在当前光标所在的地方插入  I:在当前行的行首插入
              2.输入 A 命令   a:在当前光标所在的后方插入 A:在当前行的行尾插入
              3.输入 O 命令  o:在当前光标所在的行的下一行打开一个新行
               O:在当前光标所在的行的上一行打开一个新行
插入/末行-->命令  
              按下ESC键就好，有时需要敲两次，敲多次没有任何其他的弊端。
              
:q： 可以直接退出，只要做了编辑，就不能用:q退出。
:q! ：强制退出，不保存
:x , :wq ：保存并退出
ZZ ：直接保存退出（必须大写），在命令模式下。
  :set nu 显示行号
 ----------------------------
如何打开vim:
   vim +n : 不但打开vi ,还让光标直接处于第n行 
   vim +/pattern files: 可以直接匹配到第一次匹配到这个模式的行的行首
         比如：vim +/redhat ff.rc             
---------------------------
光标移动：（这些都可以和数字组合使用，比如5w,5b 5e ，一次跳到多少个相关的词/行）
一次移动一个字符的：
  HJKL: 
  H向左移动，L向右移动，J向下移动，K向上移动
一次移动一个单词：
  w: 跳到一下一个单词的词首
  e:  跳到下一个单词的词尾（如果不在单词词尾，优先跳到自己的词尾）
  b:  跳到上一个单词的词首（如果不在单词词首，优先跳到自己的词首）
在行内跳转的：
  ^，数字“0”: 用于跳到行首。^:用于跳到这个行的第一字符的符首。 0 用于跳到绝对行首。 
  $  : 用于跳到行尾（绝对行尾） 
在行间跳转：
   G，nG：跳转到第几行，比如10G，则跳回10行。单独一个G，跳到最后一行。gg跳到第一行。
--------------------------
删除字符：
x:nx    通常用于删除一个字符 3x 直接删除3个光标后面的字符
d:通常跟范围表达式组合起来，表示怎么删。
      dd,直接删一行
      ndd ：直接删n行
      dw: 连同单词后的空格一起删
      de: 不删单词后面的空格
      :10,100d ：删除10-100行
      :.,$d : 删除当前光标所在行到最后多少行 （.表示当前光标所在行 $表示最后一行，$-1表示最后一行的前一行）
--------------------------
翻屏功能：
ctrl+f: 往文件尾部翻一屏。
ctrl+b: 往文件首部翻一屏。
ctrl+d<---->ctrl+u ： 往后或者往前一次翻半屏。
--------------------------
修改： 
c：可以实现从命令模式转换到插入模式 ，但是在进入插入模式之前，先修改
    cc,删除一行并进入插入模式
    c$,删除到行尾，并进入插入模式
    与d大致相同。
--------------------------
复制和粘贴
y:复制。y键的使用方式跟d一样
    yy复制一行
    3yy,复制3行
    ye,yw,yb 等等
    只要复制的不是单独的行，在粘贴时就是不单独的行
p：在当前光标所在的下方进行粘贴。 如果复制的是单词，则粘贴在光标的后面
     P:在光标所在的上方进行粘贴。 如果复制的事单词，则粘贴在光标的前面
---------------------------
改错，就如[ctrl+Z]
u:撤销上一次的修改（vim会保持50次的操作）
U:一次性全部撤销。
Ctrl+R  : 可以将上次的撤销，撤销掉
”.“  : 再做一次，就是redo.将此前的操作重复执行。   
-----------------------------
可视化模式
  v：进入可视化模式，以字符选择
  随着光标的移动，各种选中，按y复制
  V: 进入可视化模式，以行选择
  
  可以跟d y 等命令，各种混合。
------------------------------
剪贴：先使用 d命令，再使用p命令，此时，p只能粘贴dd的最后一次操作所删除的内容。
------------------------------
r ：单字符替换
在光标所在位置，按r，然后直接按要替换成什么就好
     替换多个字符
     nra:则替换光标后n个字符为a
-------------------------------
 一次打开多个文件 vim *
 在末行模式下输入
 :next 跳到下一个
 :prev 跳回上一个
 :first  跳到第一个
 :last   跳到最后一个
 --------------------------------
 查找并替换:要在末行模式下执行。
 1,$ s/要查找的内容/要替换的内容/gi          g全局替换， i搜索字符串的时候忽略大小写
 .  ： 光标所在的当前行
 $ ：最后一行
 .,+3 :从当前行到后面3行
 % : 从第一行到最后一行。
 vi查找命令也支持正则表达式
 
 --------------------------------
 
 水平分割分割窗口
 ctrl+w 松开手之后再按s :水平分割窗口。
 ctrl+w 之后再按ctrl+w ，实现两个窗口之间跳转。
 垂直分割窗口
 ctrl+w 松手之后按v : 垂直分割
 ctrl+w 之后再按ctrl+w ，实现两个窗口之间跳转.
 可以分割好几个窗口，
 用ctrl+w 之后按箭头来选择。
 
 vim -o 一次打开多个文件并直接实现窗口分割
 vim -O 水平分割
 -----------------------------------
 定制vim的工作环境。或者工作特征。
 :set + 功能的简写 ：可以设置相关功能，如果想取消则，在功能前加 no
        :set nu :显示行号
        :set nonu ：取消显示行号
        这种设置只对当前文件生效。
     如果想一直生效就需要配置 /etc/vimrc 
     在每个用户的家目录下有 ~/.vimrc,打开或者自己手动建立，然后自己定制
        :set ai ：开启自动缩进
        :set noai ：关闭自动缩进
        :set ic：忽略字符大小写
        :set sm：showmatch 显示两个括号中谁跟谁相匹配。当开启之后，光标定义在其中一个括号上时，他会自动识别跟这个括号匹配的那个反括号。
        :help set 查看set都有哪些
        :set all 查看set 命令的所有可配置选项。
        
        syntax on：是否打开语法高亮（默认打开），通过颜色来判断你的语法是否有错误。
 -----------------------------------
 【vimtutor】命令：
 vim教程，一边教你，一边让你实验。（vim设计者们提供的教程）
-------------------------------------------------------
【test】 命令：
    格式： test expression
    test能直接测试。   
【[ expression ]】  ，   【$[ ] 】算术运算
【[[ expression ]]】   双中括号一般是关键字。asdasd && asdasd 表示连接。

   在第三种即关键字的搜索时，可以用  
        =~  :  做正则表达式的模糊匹配


        [[ $string =~ h[aeiou] ]] 
        看这个变量string中的内容 是否能被 后面的正则表达式 所匹配。能为真，不能为假
         比如：    USERNAME='root'
                       [[ "$USERNAME" =~ ro\{2\}t ]]
-------------------------------------------------------
1.【整数测试】：
需要两个测试数。
套件表达方法比较特殊
 -lt  : 表示左边的是否小于右边的。 [ $A -lt $B ] A中保存的数是否小于B
 -le ：【小于或等于】【小于等于】
 -gt ：【大于】
 -ge ：【大于或等于】【大于等于】
 -eq ：【等于】
 -ne ：【不等于】
   
 [ $1 -ge $2 ] && echo "$1 is the max num." || echo "$2 is the max num."
 判断输入的两个数哪个大
 bash -n 这个脚本。检测脚本语法。
 
2.【字符串测试】：判断两个字符串是否相等。
 == :【表示等于】
 !=  或者  <> 表示不等于
 >  ：【大于】
 <  ：【小于】
 -z 判断一个字符串是否为空，为空就为真 0，不空就为假 1    [ -z $A ]看A的这个变量中间有没有包含字符。
 -n 判断一个字符串是否不空，为空就为真，不空为假
 
 
3.【文件测试】
 -e FILE：判断一个文件是否存在
 -f FILE：判断一个文件是否是普通文件
 -d FILE：测试一个文件是否是目录
 -h/L FILE:判断一个文件是否是符号链接文件
 -r FILE:判断一个文件的对与执行者是否可读
 -w .、 对当前用户是否可写
 -x  对当前用户是否可执行
 -s : 判断大小。是否存在。大小不能为0
 -O :这个文件的当前属主是否就是这个文件的发起者
 -G :这个文件的属组是否就是这个文件的发起者
 
4.【组合条件测试】：
如果一次要制定多个条件怎么办？
   -a 表示 都要满足
        [ -x $FILE -a -w $FILE ] 一个文件必须既有执行权限，又有写的权限
   -o 表示满足一个就行   同上。
   -not 表示取反，也可以用 ！
        [ ! -x $FILE ] 没有执行权限的文件。
 
  比如： 
  [ -x two.sh ] && ./two.sh
-------------------------------------------------------
【if语句】：(单分支)
  if CONDITION; then
     statement
     ...
  fi 
  双分支
  if CONDITION; then
     statement
     ...
  else
     statement
     ...
  fi
  多分支的if语句
  if CONDITION; then
     statement
     ...
   elif CONDITION; then
       statement
       ...
   ......
   else
       statement
       ...
   fi
   
-------------------------------------------------------
【常用的数学运算符】    
   +  -  *  /
   %: 取余数
   += /  -=  / *= / /=：SUM+=1 其实相当于 SUM=[$SUM+1] 但是SUM+=的时候，前面要用let
   ++:自加运算
   -- : 自减运算


-------------------------------------------------------
【while】循环
   while CONDITION; do
        statement;
        ...
        CONDITION修改，让while再判断继续循环或不循环
    done
    
    ---------------------------
    1-100的加法：要自己指定条件。还要设置什么时候while能停止
    let I=1
    let SUM=0
    while [ $I -le 100 ]; do
        let SUM+=$I
        let I++
    done
    echo "$SUM"
    
    对于while来说，也可以一次读一行。
    while read LINE; do
              ......
              ......
    done < /etc/inittab
    这就实现了，从/etc/initab里，每次读一行，将这一行的内容放入LINE这个变量中，然后依次进行处理。
    LINE是个变量，可以随意指定
    -------------------------------------------------------
    读取/etc/passwd 然后将用户名给读取出来，之后显示：
                  root , SHELL: /bin/bash
              ---------------------------------------
              while read LINE;do
                 USERNAME=`echo $LINE | cut -d: -f1`
                 USERSHELL=`echo $LINE | cut -d: -f7`
                 echo "$USERNAME , shell : $USERSHELL 
              done < /etc/passwd  
              ---------------------------------------    
         用awk实现这个while的练习：awk 'BEGIN{FS=":"}{print $1,"  SHELL:" $7}' /etc/passwd
                                 或者 awk -F: '{print $1,"  SHELL:" $7}' /etc/passwd
            --------------------
            用for实现：
              IFS=$'\n'
              for LINE in `cat /etc/passwd`; do
                 USERNAME=`echo $LINE | cut -d: -f1`
                 USERSHELL=`echo $LINE | cut -d: -f7`
                 echo "$USERNAME , shell : $USERSHELL
              done
-------------------------------------------------------
【read】命令的使用：
    read [options] VAR1 VAR2
        -t timeout：等待用户的超时时间间隔。
        -p prompt：键入一些信息之前先显示一些提示信息出来。
        -a array：把读入的信息不是放入变量里，而是放入属组中。将用户键入的信息保存在数组中。
-------------------------------------------------------
【特殊变量】
             特殊变量：$的后跟名
【$?】
【$*】  或者  $@ :  一次性引用你的shell脚本的所有位置参数变量。
     如果运行下面这个脚本a.sh 
     echo $1
     echo $2
     echo $@
     echo $* 
     运行： ./a.sh ab cd ef ggg
     则：$@和$*会引用你所引用的所有参数，不仅仅只是显示$1 和$2 ,还可能有 $3 $4
               $@ 是把所有的变量当做一个字符串来引用了。
     但是，$* 把每一个变量当做一个字符串来引用，只不过一下把他们输出在了一行上。所以看似一样。
     
【$#】 会被替换成整个命令行参数的个数,用于引用你通过命令行向脚本传递的参数的个数
    比如上面那个脚本，如果最后显示$#的话，则会显示为 4
【$0】 表示脚本名字自身。
    但是取得时候会将命令连同./a.sh 一起取出来
     可以使用 basename $0 来将名称给取出来。
【$$】 表示包含了当前这个进程的进程号的
【$_】  表示这个命令中最后一个参数的结果。用于定位最后一次命令执行的是谁的时候特别有用。
【$!】  用于引用在后台运行的最近的这个命令的进程号是什么
【$-】  用于引用 当前这个命令 所能够识别的命令的选项中的引导符是什么。一般都是横线 【用十六进制给表现出来】


-------------------------------------------------------
【exit】 时，可以直接退出脚本，并且可以指定返回值
      exit 0 ，则退出，并返回值为0
      exit 2 ，则退出，并返回值为2
      比如：
           #!/bin/bash
           read FILE 
           if [ -e $FILE ];then
                 echo "$FILE exists."
            else
              exit 6
            fi
        此时，运行之后，用$?则会显示 6 
==========================================


【进程】管理的知识：Process:
 进程：进程是资源分派的单位。是一个程序的正在执行的副本。
 
 将任务以某种方式轮流的分派cpu的资源。      
 在32位内存上，每个进程都假设自己有4G的内存可用
 在每一时刻，进程都相信自己是独享系统的
 在某些特殊时刻到来的时候，让进程以以某种规则来执行
 这就需要
 “进程调度子系统”
 早先的Linux内核在尽心调度的时候会随着进程的数量的增多而性能下降
 但是2.6之后的内核，引入了O(1)的调度方式 
 I/O密集型：大量需要去接口设施
 CPU密集型 ：经常需要和CPU去打交道，大量消耗CPU的性能。
 
      场景设计：一边看电影，一边聊QQ
                  则系统会尽可能多的将cpu的资源交给解码电影
                  但是当你聊QQ一旦敲击键盘，则敲击键盘的瞬间，敲击指令的优先级将会非常高，则将获得cpu的资源
  
  进程优先级：
         静态优先级：你给他一个优先级，他就不变了，一直这么大  [100-139]
                            管理员手动调整的优先级，不过无论怎么调整都不会高过动态优先级的范围的
         动态优先级：用一个十进制的数字表示动态优先级：[0-99]      
                            实时优先级。
   
【nice值】，用于实现一一对应其静态优先级。从-20 到 19 来对应静态优先级的 [100-139]
               作为一个进程来讲你可以把自己的优先级让给别人。才优雅，才Nice.将自己的优先级调低
               管理员可以随意调高调低
               而用户只能调低
               
   【web】： 在有人访问的时候，会向所有访问的用户开启一个 进程 或者 线程。比如1000人访问的时候会有1000个进程
    而，将某进程Kill,查看，调整优先级等操作，则叫做进程管理。
-----------------------------------------------------------
如何实现【进程调度】：
          进程优先级：静态优先级是 nice -20~19 (当你启动一个进程之后，默认的nice值是0)
          调整Nice值。
                1.【nice】 :启动一个进程的时候直接指定nice值。
                         nice -n N COMMAND  (则将命令的nice值改为N)
                         比如 nice -n -3 /usr/sbin/cupsd
                              则将/usr/sbin/cupsd 启动并将其nice值变为-3
                                只有管理员才能降低nice值，所以优雅是需要付出代价的。
                2.【renice】 ： 对已经启动过的进程调整其nice值。
                         renice N PID 只能指定PID
                         renice -5 423 则将PID为423的进程的nice值调整为了-5    
    
   =========================================================== 
   
   
【ps】 命令： 
        命令其实非常庞大，古老，支持的选项非常多。而unix在分裂的过程中，这个命令也被独立维护
        一般来讲用户登录进去之后，系统就是给你一个终端。这都是跟终端相关的。而在登录之前那些都是跟无关的进程
        1.终端相关的进程：他们都附属于某一个进程，比如shell进程，所以shell进程都被称为leader进程。所以kill领导进程的时候，它会将里面的其他所有跟他有关的都杀了。
        2.终端无关的进程：他们都独立。优哉游哉的独立于世外生存。
        选项：BSD风格选项都没有“-”
        
            -e: 用于查看所有进程：无论是终端相关还是终端无关的所有进程
            a : 跟终端无关的所有进程。 
            x :表示跟终端相关的所有进程 
            u: 表示显示这个进程是由哪个用户发起的。
            axu : 正是一般查看进程时最重要的一项命令组合。
            -eF: 显示额外信息，小f显示完整信息。
            j : jobs format 作业的格式来显示进程状态信息。
            -ejH :H,可以显示进程见关系，直接树状显示出进程关系
            axjf ： 真正树状图的形式显示进程关系
            -o : 自己定义只显示哪些字段。
                       比如： ps -eo pid,%CPU,comm  用逗号隔开，可以各种指定显示
            
            常用：
            ps axjf
            ps aux
            ps ef
            
            
            进程属性：样式
            PID(进程号) ：CPU是靠着task_structure结构体来标示进程的，在这个结构体里，它会给进程分配PID
                                task_structure：是个循环链表，会给每一个进程派发身份证。如果一个进程结束了，就会将这个进程身份证拿走。
                                一个进程除了PID之外还有
                                PPID，父进程的进程号。对于Linux来讲，每一个进程都是又上帝带来的。所以所有
                                进程的父进程都是init，所以这个进程的进程号是1.而上帝的本尊已经在父进程出来之后退居幕后了，他叫swap。进程号是0
                                这个进程通过复制自身得来的。它复制自身得来子进程，而每一个子进程都可以生成子子进程
             tty: 是否跟终端相关。
                           ？表示不相关
                           tty1 表示相关
             STAT：进程状态：
                          1.running 运行态 : 从cpu 一旦获得时间，则变成了running。如果时间完了，进程还没运行完，则将进程切换回Ready。
                                            这种来回切换的过程叫：
                                            上下文切换 （CS:Context Switch）.把数据弄出去，再等有时间了弄回来。
                                            而系统调优，就是调这些每一个进程让其获得多少cpu的时间。
                                            交互式进程越短越好。
                                            通过系统中断，可以实现，新来的进程如何抢先进入那些刚获得进程时间的还没有运行完得进程。
                                            最重要的中断，时钟中断
                          2. Ready 就绪态 ：所有都具备了，只欠cpu的运行时间。轮到你了你就Running,轮不到你你就running
                          3. Stopped 停止态：指的是管理员通过触发某种事件，让这个进程永久的沉睡下去了。
                                                      只有当管理员唤醒它，它才能进入运行循环
                          4. Sleep 睡眠态，等待某个I/O事件完成的时候，就从running态转变成了睡眠态
                                                一般等待用户输入数据，或者等待读入数据时。不睡眠就进入就绪态
                                                可中断睡眠（interruptible Sleep），可以叫醒。
                                                                这种进程因为无事可做而慢慢睡眠的进程。
                                                不可中断睡眠（uninterruptible sleep） 别人叫不醒，只能自己起来：
                                                               这个进程本身正在完成一些其他操作，比如I/O,必须等待将其加载完成
                         进程状态：
                         D：表示不可中断的睡眠
                         R：Running 或者 Ready 正在运行或者等待运行
                         S : 可中断的睡眠
                         T :  停止态
                         Z：Zombie。僵尸态：一个进程执行结束了，应该将内存释放出来，但是这种态，没有释放！
                                              发生有两种可能性
                                              1.将一个进程向操作系统发出结束进程的时候，他会自我清理。在发出结束消息之后已经没进程号了，但他还在内部结束着自己。
                                                 每一个进程在死亡的时候并实现自我清理的时候，由其父进程帮其收尸。
                                              2.当一个进程正在准备清理的时候，父进程死了。则这个进程就会进入僵尸态
                                                孤儿进程。
                                                但是linux不允许孤儿进程出现，则会在父进程死之前，会给他找一个新爹，而新爹一般都是init，即社会福利院。
                                                一个好的程序员要随时关心它的父进程，而要在父进程死之前将进程找给Init。
                            对于BSD风格：
                            < : 表示这是一个高优先级进程
                            N：表示这是一个低优先级进程
                            + ：表示跟某一个前台进程相关，属于某一个前台进程组的进程。（领导死了都会带下属一起陪葬的）
                            s ： 某一个进程组的 Leader进程，领导进程。
                            l : 则表示这是一个多线程进程
                TIME : 获得CPU时间的累计时间
                COMMAND: 由哪个命令发起的这个进程。对于init来讲，它是 init [数字]：表示init的级别，有0-6 7个级别
                                     加了中括号的，表示是内核线程，
                %CPU： 占用CPU的比率
                %MEM ： 占用内存比率
                VSZ : 虚拟内存级 大小是KB 虚拟地址空间的大小
                RSS : 物理内存级，真正占用物理内存空间多大。
                START：启动时间
       
       
       【线程】：thread表示：比进程更轻量级的资源分派单位。
       对于每一个进程来说，它认为他占用了所有的操作系统资源。如果你在一个系统上发起了200个进程，如果两个进程需要数据之间访问怎么办？
       1.自己到外面自己转一圈，然后回来。（实现自我通信）
       2.在内存空间内进行，两个进程建立一个内存空间（共享区域），叫共享进程。然后他们能在共享区域内通信。（进程内相互通信）
                  场景：Web服务器中浏览页面
                  进程是：将每一个用户当一个进程，放入cpu，然后Ok.占满为止
       而线程是：将页面放入内存中后，线程将这内存分为小的进程，让访问相同页面的人都处于一片小内存中。
       如果要使用线程，必须要防止几个用户同时修改一个文件。这就需要给加锁。
       Linux并不是完整意义上的支持线程的。
       
       【Web服务器】：
       apache Web服务器:prefort模块，如果有动态页面，4G 顶多有2000个用户访问
                    worker模块，
       Nginx  Web服务器：如果只解析纯静态页面，4G的内存他能相应2W个用户的访问
       
       对于内核来说他是靠进程来工作的。而进程又分了线程。
          比如pdflush线程，将内存中的东西同步到硬盘的。
       4G的内存，其实是分为两块的。
       1G+3G, 这1G的其实是内核空间。3G才是用户空间
       真正的能跟硬件打交道的只有内核。也只有内核才有这样的权限。
          比如  mkdir 由用户在用户空间提出申请。然后交给shell ，shell联系内核，然后内核联系硬件，才在硬件上建立了目录。
          用户控件的程序不是不能随便跟内核空间打交道的。
          而打交道的方法是 1.：系统调用
                                     2.：中断                            
       
       对于linxu来讲，只要有物理内存，它是不会用虚拟内存的。
       Windows只要开机，他就只用虚拟内存。
                 
        ----------------------------------------------
        查看有多少个cupsd的进程
            ps aux | grep cupsd
          ps一般专门跟 grep一起使用
          而还有一个ps的专有命令:
------------------------------------------------------------          
【 pgrep】 : 
              -u  专门查看某个特定用户的进程。 但是只显示属于root用户进程的进程id 比如 pgrep -u root
              -G  专门显示某个组的进程。    
          pidof :  查看某进程的进程号
                    比如 pidof cupsd 则显示进程号。
         -------------------------------------------
         进程间通信机制：IPC
                  1. 共享内存机制
                  2. 信号：就是一种非常微小的信息单位，可以从一个进程到另一个进程，以实现另一个进程发出通知，或者让另一个进程采取特殊的动作
                           我们向一个进程发送信号，一般使用kill命令，来向另一个空间中的某个进程发送命令。
【kill】 : 只能kill对方的进程号
                    【   kill -l : 可以列出当前系统上的所有可用信号。】
                                        每一个信号前都有个数字
                           Kill -9 : 则发出第9种信号
                           kill -HUP , 发送简写为HUP的信号
                           kill -SIGHUP   ，以【信号】的SIGHUP
【常用信号】 
                  1.SIGHUP信号：相当于向对方发出重载，重新载入的时候非常有用。
                  2.SIGINT信号  ：相当于向对方发送了一个Ctrl+C, 中断
                  9.SIGKILL信号 ：强行杀死对方。飞来横祸，直接死亡，会造成数据丢失的。
                  15.SIGTERN信号：相当于让另一个进程停止的信号 。在杀死对方的时候允许向家人告别。（处理完进程该处理的，从容死去）
                  18.SIGCONT信号:把一个以停止的作业让他继续运行
                  19.SIGSTOP信号: 将一个进程暂时停止  
                  从35之后的信号，可以自定义。
                  
                  如何向另一个进程传递信号？
                  kill  2288 （向PID2288的进程发送15信号）
                       默认什么信号都不加，则使用15信号 
                  kill -15 2288 则是发送15信号给进程号是2288的进程。
                  
         一次杀死多个进程：
【killall】 进程名 ： 后面必须跟的事进程名
                  比如 killall -15 httpd 则用15号信号的方式杀死所有进程名为httpd的进程
【pkill】             
             pkill SIGNAL pattern:
                     表达式   进程名
                     
-----------------------------------------------------
【top】命令：
              也是用来查看进程的。跟ps一样。
              但是ps只是显示那一刻！
              用top 可以一直显示，每5秒刷新一次。
              信息非常重要：
              ---------------------------------------------------------------------------------------------------------------------------------
              开机时间，运行时长  登录几个用户， 系统平均负载率 1分钟 5分钟 15分钟 （在CUP里等待运行的任务的个数，一般当它大于3的时候，基本上就是系统瓶颈了，证明CPU太差了。）
              一共有多少进程正在运行   运行状态的个数  多少个睡眠的  多少个停止的  多少个僵尸
              显示cpu利用率（s,多cpu平均值）： 花费在用户空间执行程序上的比例  内存空间上的比率 调整为nice值的比率  空闲的百分比  等待IO事件上比率（wa）
              Mem 一共有多少内存， 使用了多少 ，空闲了多少，多少用于缓冲（为了平衡时间，先放到缓冲里，慢慢使用，用于减轻速度慢的一方的压力的）数据了
              swap 一共有虚拟内存 ，使用了多少， 空闲了多少，用于多少做缓存（为了重复使用的，能够实现加速的功能，所以有命令支持）了
                                  （Linux加速系统访问的机制，将空闲内存全部变成缓存）
               【16：52】
               
                 常用选项：
                   -b -n N: 在-b模式下，可以指定让top显示指令几次，然后退出
                            top -b -n 2 : 则表示，将信息抓出来，抓2次，然后退出。
                   -d : 可以指定每隔多少秒刷新一次 
                            top 10
----------------------------------------------------
【free】命令：
                   查看内存信息的命令
                   物理内存和交换内存的信息
                   -m : 表示以M(兆)为单位，显示其信息大小
 ----------------------------------------------------
【uptime】 命令：
                   显示系统运行时间的
                   每一分钟，5分钟，15分钟的系统负载
             ----------------------------------------------------
 【vmstat】 命令：
                   显示内存信息,缓存，io,系统，cpu的信息
                   io:中断次数     cs：上下文切换的次数
                   vmstat N : 每隔N秒钟显示一次。最大的时候cs可能达到10W次。。。。
                   vmstat N1 N2: 每隔N1秒钟刷新，抓取N2次数后退出
--------------------------------------------------
【 pstree】 命令：
                    可以显示当前系统的进程的进程树。
                    清楚的显示进程的进程树
-------------------------------------------------------
【until】循环：
   条件满足就退出，条件不满足就继续
   until CONDINTION do
         ....
          ...
    done    
    
    1+到100的运算
    let I=1
    until [ $I -gt 100 ] ;do
        let SUM+=$I
        let I++
    done   
    echo $SUM    
-------------------------------------------------------
【sleep】 命令：
        让整个执行流程延迟多少秒
        比如 sleep 5 则延迟5秒
------------------------------------------
【wall】 命令：
           可以向每个用户的终端都发送一个信息
           比如
             wall "Hello" 则向全终端发送整个信息。
-------------------------------------------------------
【作业控制】：
          通过前台发起的某个命令，但是这个命令可能会发起多个进程。一个或一组进程，一个job
              比如： cp -r /etc /tmp/abc 则是一个作业，他会开启多个进程来完成作业
              作业分前台和后台：
              1.【前台】：在命令发起的时候如果这个命令没有结束，则一直占据着shell，则叫前台执行（比如 刚才的例如）
              2.【后台】：执行的时候即便没有成功，也将shell释放。
                        cp -r /etc /tmp/abc &
                        加入了【&】，则将此命令在后台fg运行。
 ----------------------------------           
             让其跟终端无关的：
【nohup】命令：模拟，让你的某个命令跟终端没有任何关系
                     如果以nohup 发起命令的话
                            nohup cp -r /etc /tmp/cab &
                            则这条命令是跟终端无关的，即使终端退出了，它也依然运行，跟终端无关。
                         -----------------------------------
                 让一个正在前台的命令发送到后台去：
                  .把一个前台运行的作业发送到后台去。
                    Ctrl+Z : 则将一个前台命令送到了后台去
                         Ctrl+Z其实就是19信号
---------------------------------------------------------------    
【jobs】 命令，可以查看当前被放到后台的所有作业有什么。
                        前面的编号是这个作业的作业号。
                    fg %作业号， 则调回作业号的内容。（fg可以省略“%”号）
                         比如 fg 3 则调回作业号为3 的命令
                         直接使用fg 则调回作业号后面带+ 号的那个命令
                    bg %作业号：将一个已经调入后台的作业开启Running状态
                    kill  %作业号： 将后台的作业直接Kil掉，让其从容就义。（保存完成的结果，结束作业）
                    
                 -----------------------------------------------
                 通过 &放入后台的程序 默认是Running状态。
                 而通过 Ctrl+Z 送入后台的程序默认是 Stopped 状态。
         显示当前系统上所有其VSZ段的值大于4000的进程的进程名、进程号和VSZ的值的大小
         ps aux |awk '$5>4000 {print $2 "\t" $5 "\t" $11}' |grep -v "PID"
-------------------------------------------------------
        如何为echo 命令加上【颜色】。
        ANSI 【color】，颜色种类比较少。只有7种。显示的时候需要用控制符
【\033】 : 表示是 ESC 键的 十六进制码
          3开头表示是前景色
          4开头表示是背景色
                0是黑色
                7是白色
                1 红 色
                2 绿色
          
        
    echo -e "\033[31mThis is a desk;\033[0m"
    
    \033[0m : 不管是什么控制，颜色，字体，斜体，粗体，都用0m结束
    
    可以实现对esc键的直接键入
    按ctrl+V 然后按 ESC键
    则直接用二进制表示ESC 会显示 ^[
    
    echo -e "^[32mThis is  a desk;^[0m"
    -------------------------
    想让背景和前景都实现
    
    echo -e "\033[31;42mMy color.\033[0m"
    echo -e "\033[1;31mMy color.\033[0m"
    
    第一种：单独。
    0：正常模式
    1 ：加粗
    2 ：
    5 ： 闪烁
    8 ： 跟背景色一样。用于隐藏文字


 ============================================================
主机的【网络属性】配置：
    1.图形界面里：跟windows类似。
        一般用 ：  system-config-network-gui  (redhat提供的)
        
        --------------------------------------------
        linux到底是如何给网卡命名的
        最终我们给网卡设备取了一个别名：
        1.以太网卡 eth 开头， eth0,eth1.....
        2.PPP网卡 ppp 开头，ppp0,ppp1,ppp2.....
        --------------------------------------------
        /etc/sysconfig/network
        这里面主要用于定义，linux接入网络后所需要配置的重要信息
        这个文件是全局的。
        1：NETWORKING 表示是否打开主机的网络功能 yse/no
        2：是否启用本机的IPv6的网络功能。yes/no
                 IPv6是内核中以模块的形式存在，在这设置为no，也关闭不了ipv6
        3：HOSTNAME：主机名
        4：GATEWAY:设置网关
        
     2. 基于字符的图形界面：system-config-network-tui：使用这种方式修改的命令不会立即生效，要重启网络命令（service network restart ）才行
             1.配置网卡   
                Name 设备名
                Device 设备
                Use DHCP 是否使用DHCP (用空格切换进去)
              2.配置DNS
                 有个搜索，当你使用不完全合格域名的时候，则自动补全这里面的搜索内容，即搜索域
                 
             FQDN:Full Qualified Domain Name 完全合格域名。  
            -----------------
       【setup】 命令
       打开类似于windows控制面板的东西。然后就可以进入一种全局配置。


      3. 命令符方式
        对于Redhat来讲
        /etc/sysconfig/network-scripts/ifcfg-ethX
        所有的网络设备的配置文件都保存在这里      
        这里面有很多网络设备的控制脚本。
             两个重要的脚本ifdown---> ../../../sbin/ifdown
                                    ifup ---> ../../../sbin/ifup
                    ifup:启用某个设备的
                    ifdown:禁用某个设备的。
          
          每一个网络设别都有一个在/etc/sysconfig/network-scripts/下有一个以ifcfg开头，以设备名命名的文件
          
          对于Linux来讲，地址是属于主机的，并不属于网卡。
          
           /etc/sysconfig/network-scripts/ifcfg-ethX 进入后
           1.DEVICE: 对应的哪个设备的
           2.BOOTPROTO:定义设备启动的时候所使用的协议（配置的时候只能4选1）
                         1.dhcp协议：配置了这个之后，下面的ip什么的都无效的。
                         2.bootp：动态指派ip地址，但是没有租约的改建。（dhcp的前身）
                         3.static(静态协议)
                         4.none
           3.HWADDR: 硬件地址 MAC地址
           4.ONBOOT=yes ：在主机启动的时候是否启动这块网卡。 No的话，必须手动启动这块网卡
           5.NETMASK 子网掩码
           6.IPADDR IP地址
           7.GATEWAY: 网关 （不是必须配置的。）
           8.TYPE:表示说明网卡说明类型 
           9.USERCTL: 是否允许普通用户来禁用/启用这块网卡 一般是 =no 的。
         10.PEERDNS=(yse|no):这个通常在BOOTPROTO在bootp或者dhcp.结合用的。设定是否dhcp/bootp协议是否更改你的DNS地址
            当改完这些内容之后都不是立即生效的。而是必须要重新开启网络命令的。
         
            /etc/resolv.conf 文件，配置DNS
            search : 
            nameserver : DNS服务器的IP地址，最多可以指定3个      
            
            service network restart 重启网络服务 
            /etc/init.d/network restart 跟上面一样
               service脚本的保存目录
            
   第四种： 【ifconfig】 配置：临时配置,但是立即生效！ 重启网络服务或者重启操作系统都会让他立即失效。
                  -a 显示所有的信息
              配置的格式：
                 ifconfig ethX ip/netmask
                 比如：
                 ifconfig eth0 192.168.0.188/24
-----------------------------------------------------------------
 配置主机名：
           1修改 /etc/sysconfig/network
           HOSTNAME=
           必须重启则才能实现。 
            2.立即生效的主机名,但是重启失效。
            hostname www.a.com 
            
            不带任何选项的hostname命令，可以查看当前Hostname
            其实hostname命令指示直接显示了 /proc/sys/kernel/hostname这个文件
            所以
               echo "elinux.example.com" > /proc/sys/kernel/hostname
               则直接修改了
               这个文件不能使用vi修改，必须使用echo 以重定向的方式修改
            
             --------------------------------
             网关的配置。(如果，2个地方都配置了，则优先网卡的。)
                         设定信息的级越小，优先级越高。
             1.网卡的配置文件里
             2./etc/sysconfig/network


---------------------------------------------------------------------
如何【添加路由】。
         
             到主机的路由：route add -host IP gw GATEWAY
             到网络的路由： route add -net NETWORK/NETMASK gw GATEWAY
             添加默认网关： route add -net 0.0.0.0/0.0.0.0 gw GATEWAY
                                     route add default gw GATEWAY (表示添加默认网关，一般使用这个命令)
                                                 
             删除路由：route del [-net|-host]
                             route del -host IP    删除到主机的路由
                             route del -net NETWORK/NETMASK  删除到网络的路由
---------------------------------------------------------------------
1.如何【判断ip地址】是否是正确的ip
    ip的特征：
         [[ $MYIP =~   ^([1-9]|[1-9][0-9]]]
  2.如何判断子网掩码是否是正确的
    ^255(\.(0|255))[3]$
    【14:42】
    
  3.如何判断网关和网络是否在同一网段内
    用一个 & 做位与运算
       & 怎么用的： 
               A=7
               B=3
               C=$[$A&$B] 让A和B做与运算 则结果肯定是3
    那么如何判断IP呢？
       A=192.168.0.186
       B=192.168.0.254
       C=255.255.255.0
       
       for I in {1..4}.do
          AA=`echo $A | cut -d. -f $I`
          BB=`echo $B | cut -d. -f $I`
          CC=`echo $C | cut -d. -f $I`
       
  ①        [ $[$AA&$CC] -eq $[$BB&$CC] ] && echo $I same || echo $I deffent
        done
        
        在真正写脚本的时候，要将AA BB CC 等直接替换成 内容即可。
        ----------------------------------------------------------------------
        如何判断只要有一段不一样，则提前结束的
       则将①改为： 
        [ $[$AA&$CC] -ne $[$BB&$CC] ] && echo $I deffent && break
                             
---------------------------------------------------------------------
【break】 : 提前跳出当前循环
        break n :跳出n层循环
【continue】：提前进入下一次循环。
       continue n 返回一个n值
    
     A和B想与取反 
     ![A&B]=!A|!B 
---------------------------------------------------------------------
【case】 语句：
     case $VAR in
     PATTERN1)
          ...
     ;;     
     PATTERN2)
          . . . 
     ;;
     *)
          ....
     ;;
     esac 
     检查￥VAR的值，到底能被哪个模式所匹配，一般只能以一个模式所匹配。
     -----------
     例如： 当用户输入的是Q，则退出，如果输入的是其他，则显示“这是一个其他字符“
           read -p "A character" VAR
           case $VAR in
           q|Q)
               echo "$VAR"
               ;;
           *)
               echo "Other"
               ;;
           esac     
---------------------------------------------------------------------
【function】 : 功能模块
       将一个完整的功能放在一个代码块里，然后需要用的时候直接调用。
       在shell脚本里，也可以先声明好，需要用的时候直接调用就好了。
       
       格式：
            function F_NAME {
                函数体
             }
             
             或者
             F_NAME(){
                 函数体
             }
         一般要在数据段结束的时候加指定返回值
         return 1-255 : 明确指定返回值是什么。在函数中。exit 是在脚本中明确指定退出脚本的返回值
         ----------------------------------------
        能提醒用户输入两个数,显示想家结果，并循环3次
        1.不适用函数：用脚本写：
            for I in {1..3};do
                read -p "Two integers"  A B
                echo "The sum is : $[$A+$B]"
             done 
        2.如果使用函数：
           function SUM2 {
              read -p "Two integers:" A B
              echo "Sum is $[$A+$B]."
            }
            SUM2
            SUM2
            SUM2                  ## 则调用了SUM2函数3次
            ----------------------------------------------
        函数还可以接受参数，跟脚本一样。
        这个参数需要通过函数体调用的时候传递给参数
  
        CIP 1 2
       通过函数调用两个数，不能在函数体内获取这两个数：
       #!/bin/bash
       function sum2 [
       echo "Sum is $[$1+$2]."
        }
        read -p "Two intergers:" A B 
        sum2 $A $B                   ##这里，$A的将值传递给了$1,$B传递给了$2 
---------------------------------------------------------------------
【locate】 ：基于某个事先存在的文件数据库来查找的。
               【有一个专门用来搜集系统上文件都叫什么的数据库】，模糊匹配
     locate FILES
     比如，locate passwd，则直接查找出了所有包含passwd的文件/文件夹
     
     如何生成locate数据库？
     updatedb 命令：但是生成速度极慢。
     
     常用选项：
         -i : 忽略字符大小写
         -n N : 搜索到查找到的东西之后，只显示前N行
                比如 locate -n 2 passwd 则只显示passwd出来的前2行
---------------------------------------------------------------------
【find】
    find [DIR,...] [CRITERIA(标准，查找规则)] [ACTION..]
    find [指定路径] [查找标准] [处理办法]
    
    find /root /home 可以指定多个目录，多目录间用空格隔开
    
    ACTION：对于找到的文件如何处理，比如显示，删除。。。
                    默认是显示。
    
    CRITERIA:
           -name ：以文件名基本来查找，本身是严格区分大小写的。
           -iname  : 以文件名来查找，但是不区分大小写
                    find /etc -name "passwd"
                    在etc目录以及子目录下，精确查找passwd
                    
          支持文件名通配
          *任意字符   ？单个字符  [ ]指定范围内的单个字符
                   find /etc -name "*passwd*"
                   则在etc目录以及子目录下，查找passwd以及passwd前后都有字符的文件
           
           -user  :  查询用户名的文件
                        用法： -user redhat
                        比如 ： find /home -user redhat
                        查找所有home下的用户是 redhat 的文件
                        查看则需要用：
                         ls -lh `find /home -user redhat`
                         则将find的内容送给了某命令
           -group：查看用户组的文件
           -uid : 查询所属用户id的文件（文件还在，但是用户被删，则文件属于用户删前id）
           -gid : 查询所属用户组Id的文件
           
           -----------------------------------
           -a : 和关系 连接两个查找条件，必须满足两个条件
           -o : 或关系 满足之一
           -not : 非关系，对一个条件取反的 ,也可以直接写成 “！” 号   
                    查找/tmp目录下，以test开头，后跟任意字符，并且属于redhat用户的文件
                    find /tmp -name "test*" -a -user redhat
                         中间的-a此时就表示连接了-a前后的两个条件，一个是 -name "test*" 另一个是 -user redhat 的，必须满足两个条件
                    
                    find /tmp -not -user root
                         则表示，取所有用户名不是root的文件
                         
                    既不属于redhat 又不叫test的文件：
                    find /tmp -not -user redhat -a -not -name "test*"
                    或者
                    find /tmp -not \( -user root -o -name "test*" \)
                    
                    在tmp下，既不属于root用户，又不属于redhat的文件
                    find /tmp -not \( -user root -o -user redhat \)    
                    
            ------------------------------------
            以时间搜索
            -atime  以天为单位 
            -mtime 以天为单位
            -ctime 以天为单位
            -amin  以分钟为单位
            -mmin
            -cmin   
            [+/-]N ：[+/-5]最近多少天 以外访问过 +5天之外访问过 -5五分钟以内访问过
            如果只有一个N
            则表示，正好在第N天前访问过
            
                在etc下已经有5天没有访问过的文件
                find /etc -atime +5 
                stat `find /etc -atime +5` | head -1    
                
            ------------------------------------
            跟其他文件所作的相对比较
            -anewer FILES  比 FILES访问还要近的文件
            -cnewer
            -newer :文件内容被改变的时间，相当于mnewer
              find /etc -anewer /etc/passwd ：表示查找比/etc/passwd还要近的文件
            -----------------------------------
           根据文件类型查找：
           -type 
                f 普通文件
                d 目录文件
                l 连接文件
                s
                b
                c
                p 
                
                find /tmp -type d
            ------------------------------------
            根据文件大小查找：
            -size
               也支持+ 、-，               -表示小于，+表示大于
               [+/-]N   N代表N兆 一般能接受的单位 K G M等
               当你指定某个单位之后，可能出现异常状况
               find /etc -size 1M : 表示找到/etc下的小于1M的文件
               但是
               find /etc -size 2M：精确查找2M的文件
               
               意思是，当指定大小为1的时候，找的是小于1M的内容,但是一旦变成2，则是精确的。
               
               find /etc -size -100K 意思是小于100K的，+100K则是大于100k的。
            
            -----------------------------------
            根据文件权限来查找：
            -perm [+-/]mode : 只不过+号很少用了 
                不带符号的情况下，mode表示权限的精确匹配 
                find /tmp -perm 755 表示查找权限为755的文件
                
                “-”号：-755 表示每一类用户【属主，属组，其他人】权限都要匹配
                ”/“ 号：/755表示，只要某一类用户有那么一类权限就可以。
                find  /etc -perm /222
                则表示在etc目录下查找 权限为 222 的只要有一类用户能匹配此权限的所有文件
                
                使用/777: 只要某一类用户有那么一类权限就可以。所以/777，只要是有一点权限的文件，则都能匹配。
                
                查找/etc目录下，其他用户有执行权限的文件：
                ls -l `find /etc -perm /001`
                ls -ld `find /etc -perm /001 -not -type d -not -type -l`
                查找/etc目录下，权限模糊匹配001 的不是目录，不是链接的文件
 
          --------------------------------------
          常用查找选项：没有用户，没有组的文件。
          -nouser 
          -nogroup     
     ----------------------------------------------------------
     常用的ACTION：
       -ls 选项：相当于 ls -l `find....`
       -print : 默认就是这个，显示出来
       -ok COMMAND： 每一个命令都需要确认一下
       -exec  COMMAND：不需要确认，直接执行。
       
       find ./ -perm /001 -not -type d -exec chmod o-x {} \;
       {}表示占位符，用于表示find 查找到的文件。结束之后要用 \;结尾
       
       find ./ -name ":alpha::digit:" -exec mv {} {}.old \;
       表示，在目录下，找到名字以字母开头，后跟数字的，文件并将其改名为“文件名.old”
       
       find /tmp -atime +30 exec rm -rf {} \;
       表示查找/tmp下 大于30天没有访问过的 文件并删除，强制删除。
---------------------------------------------------------------------
xargs 命令：
     xargs COMMAND FILES
     他也能实现把find查找到的文件做一系列的操作的。
     find ./ -name "*.old" | xargs chmod 755
     将find找到的*.old的文件传递给 xargs 让其进行权限更改为755的操作。
============================================================


网络客户端命令的使用：
【elinks】
【links】
   外部网页服务
   ----------------------------
   elinks [option]... [ip]
   -dump [0|1] 以纯文本的形式显示,将所有的信息倾倒在屏幕上
   -source  以源码的方式显示
   
   elinks http://192.168.0.254
   elinks -dump http://192.168.0.254
   elinks -source http://192.168.0.254 
   以后用于实现探测网站服务是否供应正常


------------------------------------------------------------


【wget】 : 基于文本的网络下载工具
     一般支持http ftp协议
     wget [option] [URL]
          --tries=N : 无法一次完整下载的到，可以多来几次
          -o file : 将你的连接信息等 整个过程保存在日志里面
          -r : 打开递归模式的       
          
        所以，wget可以将对方的网站全部下载过来
        例子：
               wget http://192.168.0.254/workstation.cfg
        
------------------------------------------------------------
【axel】 : Linux下的多线程下载工具
  
------------------------------------------------------------
【ssh】: secure SHell
      协议，为了取代telnet（远程登录 ）而出现的
      用户登录的时候，能够实现用户的认证过程和传输过程都是加密的。
      C/S的工具。
          OpenSSH
          sshd
          ssh 
       用于远程连接SSHserver 的工具
       ssh 192.168.0.74
           默认，以当前你登录的用户的身份登录另一个服务器
       ssh USERNAME@192.168.0.74
       或者
       ssh -l USERNAME 192.168.0.74
           都是指定身份然后以指定的身份连入主机
      ----------------------------------------------------------------     
           对称
           公钥           dsa rsa两种格式
           单向           
           双方在通信之前会有个 host key，用于在主机进行通讯之前，登录之前，先用host key 进行加解密。他们是公钥加密的。
           公钥和私钥一般是不能用来加密的。
           必须要用对称加密
           双方建立通讯之后，会临时加一个对称加密。
           为了防止暴力破解，机器会在1个小时每次的状态下，每小时更换一次对称加密的密码
     ------------------------------------------------------------------     
       ssh的功能还有
            ssh root@192.168.0.182 'ifconfig'
            用ssh也可以用非交互的方式，直接让对方使用一个命令，并将其显示出来。
            
       ssh的用户认证。
       1.基于口令的认证
       2.基于密钥的认证：这样每次以后登录就不需要密码了  S:私钥，P公钥
             P-------> 放在打算访问的用户的远程服务器下的 、~USERNAME/.ssh/authorized_keys2 下。
             
             ssh-keygen 命令
                ssh_keygen -t rsa     ##表示创建密钥认证，然后用rsa格式
                问题1：是否更改公钥保存地址
                问题2：可以对密钥加密，可以再输入一个密码
                显示私钥保存在---->
                公钥保存在
                
            ssh-copy-id :我可以把你当前用户的公钥文件，拷贝到一个特定的服务器当中去
               ssh-copy-id -i .ssh/id_rsa.pub root@192.168.0.182
       
       当密钥认证搞定之后，则以后登录之后就会自动传递密钥，然后不用输入密码。
       但是这种认证过程是单向的。
    -------------------------------------------------
    ssh默认工作在22号端口上
    用
    netstat -tnl  命令，可以查看现在所有的端口
    【7-27 10:40】
    
    
------------------------------------------------------------
      两主机之间如何传递文件
【scp 】
    可以实现跨主机的复制，并且复制过程是加密的
    scp SOURCE DEST
    可以从自己主机复制到别人主机，也可以从别人主机复制到自己主机。
    
    scp root@192.168.0.182:/root/id_rsa_1024.pub ./ 
    讲别人的东西烤过来
    scp ./setif.sh root@192.168.0.182:/root/
    将自己的东西拷过去
    
    使用scp命令，如果目标文件夹已经有这个文件，则默认不提示直接覆盖。
    和cp命令一样，cp命令支持的基本它也支持
     -r   -a   -p
     
     -C： 先压缩再复制，可以节省带宽。
     
------------------------------------------------------------
 ftp的客户端工具：
 【ftp】
     ftp 192.168.0.254       
     5开头的，永久性错误
     2开头的，正常的
     1开头，正常信息
     3开头，正常但是不完整
     4开头，临时信息
     
     进去之后，
     cd :进入目录
     is :查看
     put :用于上传 
     get rhci.iso :则用于下载，下载到哪了？下载到登陆之前的当前目录了。
     mput :一次性上传多个
     mget :一次性下载多个
     !pwd ：加叹号，然后跟命令，直接使用你在之前的登陆端的命令
        !pwd :则显示登录ftp之前的客户端的命令
     lcd ： 直接切换你在登录之前的目录
       lcd /var/tmp
     bye: 退出ftp
     help：查看支持哪些命令
 
 但是ftp命令不强大，不能支持tab，不支持目录下载。
 所以有了
------------------------------------------------------------
【lftp】 命令
    lftp 192.168.0.254
      基本都跟ftp命令一样
      
      mirror ：镜像，可以直接把某个目录镜像到本机下。（即为下载）
         mirror Files/  则下载了Files目录下的所有文件
         -----------------------------
     lftp -u ftp,ftp 192.168.0.254
        这是匿名登录，用ftp名字，并且以ftp为密码，登录。
           --------------------
     lftpget : 专门用于下载的。使用方法类似于get
         -c 支持断点续传
      
------------------------------------------------------------
图形界面的ftp工具，【gftp】 
     yum install gftp 则用于安装
------------------------------------------------------------
【ping】 
     -c  ：指定检测次数
     -W ：指定检测时间
     -l :指定数据包长度
------------------------------------------------------------
【traceroute】 : 追踪路由命令
       基于ping命令实现的
       traceroute URL
------------------------------------------------------------
                 DNS的客户端工具
【dig】命令
       正向的：dig -t A FQDN
       反向的：dig -x IP
------------------------------------------------------------       
【host】命令
        正向：host -t A FQDN
        反向：host -t PTR IP
   比如我们要知道A记录：
   host -t A instructor.example.com
   dig -t A instructor.example.com
   
   知道ip地址，如何知道主机名称
   host -t PTR 191.168.0.254
   dig -x 192.168.0.254
------------------------------------------------------------
【netstat】 :非常强大的网络命令
        既可以实现监听的服务，也可以查看连接，查看路由表等等 
        -t   显示已经建立的tcp的连接
        -u  显示正在通信的udp的连接
        -l   监听的所有服务
        可以命令组合
        比如
        -lt   -lu
        
        -n  表示以数字的方式，解析主机地址。而不要以主机名的形式
        -tunl 则以数字的方式显示以tcp udp连接的所有服务
        
        -p  可以显示，正在监听的服务到底是由哪个进程提供的。 
       ---------------------------------- 
        -r   查看本机路由表
             比如： netstat -r
             等于    route -r 
        组合
        -rn  -tnl  -unl  -tunl  -tunlp
---------------------------------------------------------------------
                  如何去创建连接？
【ln】 命令：ln [options] 源文件 链到什么地方去
        -s ： 创建软链接
        -v ：能显示创建过程
        
        例如：
        ln /var/tmp/Files/setif.sh /tmp/setif2.sh -v
        则创建硬链接：setif.sh到目录中的setif2.sh并显示创建过程
           创建后，setif.sh 发现链接数加1.
           
        例如：
        ln -sv /var/tmp/Files/rh033.txt /tmp
        在tmp下创建软链接rh033.txt。
         创建软链接的时候，一定要用绝对路径创建，尽量不用相对路径。
             当你复制软链接的时候，复制的其实是链接的原文件。
---------------------------------------------------------------------
【df】：显示分区，文件系统
      -h： 单位换算
      -i :显示节点号的相关信息
  ---------------------------------------------------------------------    
【du】 : 查看目录/文件大小的
     -s : 只看目录统计
     -h : 单位换算 
---------------------------------------------------------------------
【/dev】 目录下的文件。【特殊文件】：
      特殊文件不需要大小。
      特殊文件只是访问一个设备的入口而已。而不表示设备文件所对应的内容有哪些。
      它不在磁盘的磁盘块中存储，所有的东西都在inode里。
      两个数字： 用于表示这个设备的类型。
      前一个数字，代表大类，  后一个数字代表小类
      主设备号，     次设备号。
      
      创建设备文件：
---------------------------------------------------------------------      
【mknod】 : 表示用于创建设备文件的。
            mknod mydevice c     201          1
            创建      名字     类型  主设备号 次设备号
            
         设备文件不能跨系统重启而存在。
         这里的文件是在每一次设备重启的时候自动创建的。
         早期的dev目录下有上万个文件，因为他不能判断到底有没有这个设备。
         2.6内核之后，除了一个叫UDEV的东西，在系统启动的时候会自动检测硬件信息，并自动创建特殊文件。
---------------------------------------------------------------------
【at】/【batch】
    at 能够接受各种各样时间的制定方法，比如在某月某天，或者中午，午夜，或者往后3小时
        at [options] TIME    明确制定几点几分时，是下一次的几点几分。
        at>
        at>
        完成后用 Ctrl+d 提交
        at作业不会将内容显示到屏幕上，而是将内容发送成邮件
        ------------------------------------
         查看at作业队列
         at -i  或者  atq         
         ---------------------------------
         如何删除作业
         at- d N 用于删除编号为N的作业。
         --------------------------------------
         如何接受邮件：
         只用输入  mail 即可。
             在mail 里，按相关数字能直接看相关邮件
             输入 d 1 则删除第一封
             输入 d * 则删除所有
             按  q 则退出
        -------------------------------------
        比如：从此刻开始过两分钟后执行某个特定任务
         at now+2min         
         at>ls /etc
         at>cp /etc/inittab /tmp
         用Ctrl+D提交。
         
         -f FILES：at也支持把一个作业命令写在一个文件里,则从文件中读取命令让at执行
---------------------------------------------------------------------
【batch】:跟at基本一样，但是batch 不许要制定时间，它会自动在系统负载比较低的时间运行。
---------------------------------------------------------------------
【crond】 ： 按照某个周期固定运行的命令
          这属于一个服务可以用
           service crond status 来调用查看
           
          一类：系统crond:为了维护系统的正常运行，跟用户无关，所有的作业都规定在/etc/crontab,而这个文件又被列成了N小片
          一类：用户crond：用户自己的crond作业。会在跟用户名同名的/var/spool/cron/USERNAME下
          
          系统级别的是定义以哪个身份运行
          一般都是由6个字段来定义的
          -------------------------------------------
          用户crond  6段字符
          min hour day month weed COMMAND
          min:[0-59]
          hour [0-23]
          day [1-31]
          month [1-12]
          week: [0-7]
          
          比如执行ls 命令
          10 02 03 * * ls
          
          crond 只搜索/bin ;/sbin; /usr/bin ; /usr/sbin
          如果不想将命令写入这些sh里那就使用绝对路径
          命令执行结束之后，也是发邮件到邮箱的
          
          比如：每个两分钟就执行一下date命令。
          2 * * * * date : 但这是每个小时的第二分钟，并不表示每两分钟
          */2 * * * * date: 
               数字啊前  加  */   则能表示“每”
               
           比如：每3个小时：
           10 */3 * * * date 
           
           /  : 表示除，表示“每”
           ,   : 表示离散时间  表示值中的的第多少分钟/小时/...， 
              20,50 * * * * date  每小时的第20分钟和50分钟
           -  : 表示从几到几
              10 00 * * 1-5 date 每周一到周五的10:00执行
            ----------------------------------------------------
           crontab 
              -e   : 编辑任务计划
              -r  ：移除任务计划
              -l  ：列出任务计划
              -u USERNAME ：帮其他人定义计划。
            
            比如：
                crontab -e   之后，会打开任务计划
                */1 * * * * /bin/echo "How are you?"
      ---------------------------------------------------
     【系统级别】的crond 
     min hour day month weed USER COMMAND
     分    小时   天       月       周 以谁的身份  什么命令
     /etc/crontab
     里面
     /MAILTO= : 必须指定到底发给谁          
          
       run-parts: 每当每个小时的第一分钟到来的时候，他就会把这个目录下的某个脚本执行一下。
       目录里，数字越小，越靠前的优先级越高。
       
       每隔两分钟就同步时间
       
      crond 的缺陷
      它是用来被设计在服务器上的。它是7x24 开机着得
      当命令被关机的时候而不能执行的时候，则就不执行了。
      
      crontab有个服务，能够判断你的任务到底执行了没有，如果没有执行，则会寻求某个时间点来执行。通常可以定义开机后多长时间来执行。
      这个服务叫
         anacron ：只能用作cron的补充，服务默认是关闭的。
             比如查看一下  service anacron status
          它所有的配置都在 /etc/anacrontab下
            格式如下：
               周期多长（天）      开机之后多长时间执行      作业描述符    执行什么命令
           比如     1                          65                          cron.daily      run-parts /etc/cron.daily
                      7                           70                          cron.weekly   run-parts /etc/cron.weekly
                       
============================================================
如何在脚本中实现信号捕捉：
【trap】 命令：
      trap 'COMMAND' SIGNAL
      比如，要捕捉对方发的ctrl+C 而且不让他退出，并显示：我就不退出
        脚本：
            trap 'echo "NO quit..."' 2     ## ctrl+C的信号是 2 或者写成 SIGINT
            
            trap 'echo "NO quit..." ; exit 1' 2
            kill 信号是无法捕捉的，不能让自己就不死。
            
            但是如果trap想要执行的东西太多的话，光靠写一个句子已经不行了，所以要调用函数！
            CLEANUP () {                  ## 先写一个函数
              echo ""
              echo ""
              exit
             } 
            
            trap 'CLEANUP' SIGINT    #捕捉到信号，调用函数
---------------------------------------------------------------------
【bashname】，可以快速的取出这种基名。
