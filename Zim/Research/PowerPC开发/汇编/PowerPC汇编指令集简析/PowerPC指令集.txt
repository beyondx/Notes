Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2011-12-04T21:53:18+08:00

====== PowerPC指令集 ======
Created Sunday 04 December 2011

http://hi.baidu.com/power_nq/blog/item/07915d005fd20c0b1d958396.html

PowerPC 体系结构规范（PowerPC Architecture Specification）发布于 1993 年，它是一个 64 位规范 ( 也包含 32 位子集 )。几乎所有常规可用的 PowerPC（除了新型号 IBM RS/6000 和所有 IBM pSeries 高端服务器）都是 32 位的。

PowerPC 处理器有 32 个（32 位或 64 位）GPR（通用寄存器）以及诸如 PC（程序计数器，也称为 IAR／指令地址寄存器或 NIP／下一指令指针）、LR（链接寄存器）、CR（条件寄存器）等各种其它寄存器。有些 PowerPC CPU 还有 32 个 64 位 FPR（浮点寄存器）。MPC555使用的PowerPC CPU是带有FPR的。一些常用寄存器介绍如下：

通用寄存器的用途：

r0　　　在函数开始（function prologs）时使用。
r1　　　堆栈指针，相当于ia32架构中的esp寄存器，idapro把这个寄存器反汇编标识为sp。
r2　　　__内容表__（toc）指针，idapro把这个寄存器反汇编标识为rtoc。系统调用时，它包含__系统调用号__（这个好像跟系统有关吧）。
r3　　　作为__第一个参数__和返回值。
r4-r10　函数或系统调用开始的参数。
r11　　 用在指针的调用和当作一些语言的__环境指针__。
r12　　 它用在异常处理和glink（动态连接器）代码。
r13　　 保留作为__系统线程ID__。
r14-r31 作为**本地变量**，非易失性。

专用寄存器的用途：

lr　　　链接寄存器，它用来存放函数调用结束处的返回地址。
ctr　　 计数寄存器，它用来当作循环计数器，会随特定转移操作而递减。
xer　　 __定点异常寄存器__，存放整数运算操作的进位以及溢出信息。
msr　　 机器状态寄存器，用来配置微处理器的设定。
cr　　　条件寄存器，它分成8个4位字段，cr0-cr7，它反映了某个算法操作的结果并且提供条件分支的机制。

寄存器r1、r14-r31是**非易失性**的，这意味着它们的值在函数调用过程保持不变。寄存器r2也算非易失性，但是只有在调用函数在调用后必须恢复它的值时才被处理。

寄存器r0、r3-r12和特殊寄存器lr、ctr、xer、fpscr是易失性的，它们的值在函数调用过程中会发生变化。此外寄存器r0、r2、r11和r12可能会被交叉模块调用改变，所以函数在调用的时候不能采用它们的值。

条件代码寄存器字段cr0、cr1、cr5、cr6和cr7是易失性的。cr2、cr3和cr4是非易失性的，函数如果要改变它们必须保存并恢复这些字段。

__sc__是PowerPC用来表示系统调用，r2寄存器指定系统调用号，r3-r10寄存器是给该系统调用的参数。在执行系统调用指令之前有两个额外的先决条件：LR寄存器必须保存返回系统调用地址的值并且在系统调用前执行crorc cr6, cr6, cr6指令（？）。

===== 应用程序二进制接口（ABI） =====

从技术而言，开发人员可以将任一 GPR 用于任何操作。例如，由于不存在：“堆栈指针寄存器”，为此程序员就可以使用任何寄存器。实际上，定义一组约定很有用，这样二进制对象就可以与不同的编译器和预先编写好的汇编代码进行互操作。

调用约定是由使用的 ABI（应用程序二进制接口）决定的。ppc32 Linux 和 NetBSD 实现使用 SVR4（System V R4）ABI，而 ppc64 Linux 仿效了 AIX，使用 PowerOpen ABI。ABI 还指定当调用子例程时哪些寄存器被认为是易失型的（调用者保存(caller-save)）以及哪些被认为是非易失型的（被调用者保存(callee-save)），以及许多其它内容。

SVR4 ABI 指定了一些行为的具体示例：

-由于 PowerPC 拥有如此多的 GPR（32 个，而相比之下 IA32 只有 8 个），所以**传递参数的寄存器从 gpr3 **开始。
-寄存器 gpr3 到 gpr12 是易失型的（调用者保存）寄存器，如果需要的话，在调用子例程之前必须先保存它们并在返回之后恢复它们。 -寄存器 gpr1 用来作为栈帧指针。

===== 指令格式 =====

PowerPC指令包括操作码和操作数两部分，PowerPC支持三操作数的指令格式。如算术指令：

add rD，rA，rB

表示把（rA）＋（rB）的和存放到rD寄存器中。

注意：

指令中的点号“.”表示：指令将__更新条件寄存器CR0__。如add. rD，rA，rB。
指令中的字母“c”表示：指令显示说明结果__影响XER寄存器中的进位位__[CA]，如addc rD，rA，rB。
指令中的字母“e”表示：在指令中__把XER[CA]中的数据作为一个操作数__，并在XER[CA]位记录进位位 ，如adde rD，rA，rB
指令中的字母“o”表示：__溢出标志__。对于整数，在XER[OA]位记录溢出和在CR0[SO]记录溢出位，如addo rD，rA，rB

===== 条件寄存器 =====

条件寄存器CR包括8个4bit的字段，即CR0～CR7。每个字段可以表示整数运算或比较的结果。每个条件字段可以记录比较结果，即大于、小于、等于和总体溢出等。条件寄存器格式如图1所示。

===== 异常处理器 =====

整数异常寄存器XER是一个特殊功能寄存器，它包括一些对增加计算精度有用的信息和出错信息。XER的格式如下：

SO为总体溢出标志：一旦有溢出位OV置位，SO就会置位。
OV为溢出标志：当发生溢出时置位，否则清零；在作乘法或除法运算时，如果结果超过寄存器的表达范围，则溢出置位。
CA为进位标志：当最高位产生进位时，置位，否则清零；扩展精度指令（后述）可以用CA作为操作符参与运算。

===== 存储/加载指令 =====

1 整数存储指令

整数存储指令如表2所示。

表2 整数存储指令

名称									助记符			语法格式				
字节存储（偏移地址寻址）					stb				rS, d(rA)
字节存储（寄存器寻址）					stbx			rS, rA, rB
记录有效地址的字节存储（偏移地址寻址）	stbu			rS, d(rA)
记录有效地址的字节存储（寄存器寻址）		stbux			rS, rA, rB
半字存储（偏移地址寻址）					sth				rS, d(rA)
半字存储（寄存器寻址）					sthx			rS, rA, rB
记录有效地址的半字存储（偏移地址寻址）	sthu			rS, d(rA)
记录有效地址的半字存储（寄存器寻址）		sthux			rS, rA, rB
字存储（偏移地址寻址）					stw				rS, d(rA)
字存储（寄存器寻址）						stwx			rS, rA, rB
记录有效地址的字存储（偏移地址寻址）		stwu			rS, d(rA)
记录有效地址的字存储（寄存器寻址）		stwux			rS, rA, rB

（1） 字节存储指令stb（偏移地址寻址）

stb rS，d（rA）

有效地址为rA的内容加shuzhi d，rS的**低8位**内容存储到有效地址为EA的存储器中。

（2） 字节存储指令stbx（寄存器寻址）

stbx rS，rA，rB

有效地址为rA的内容加上rB的内容，rS的低8位内容存储到有效地址为EA的存储器中。

（3） 记录有效地址的字节存储指令stbu（偏移地址寻址）

stub rS，d（rA）

有效地址EA＝（rA）＋d，rS的低8位内容存储到有效地址为EA的存储器中。__rA＝EA__，如果rA＝0，则指令无效。

（4） 记录有效地址的字节存储指令stbux（寄存器寻址）

stbux rS，rA，rB

有效地址EA＝（rA）＋（rB），rS的低8位内容存储到有效地址为EA的存储器中，rA＝EA，如果rA＝0，则指令无效。

（5） 半字存储指令sth（偏移地址寻址）

sth rS，d（rA）

有效地址EA＝（rA）＋d，rS的低16位内容存储到有效地址为EA的存储器中。

（6） 记录有效地址的半字存储指令sthu（偏移地址寻址）

sthu rS，d（rA）

有效地址EA＝（rA）＋d，rS的低16位内容存储到有效地址为EA的存储器中。rA＝EA，如果rA＝0，则指令无效。

（7） 字存储指令stw（偏移地址寻址）

stw rS，d（rA）

有效地址EA＝（rA）＋d，rS的32位内容存储到有效地址为EA的存储器中。

（8） 记录有效地址的字存储指令stwu（偏移地址寻址）

stwu rS，d（rA）

有效地址EA＝（rA）＋d，rS的32位内容存储到有效地址为EA的存储器中，rA＝EA，如果rA＝0，则指令无效。

（9） 记录有效地址的字存储指令stwux（寄存器寻址）

stwux rS，rA，rB

有效地址EA＝（rA）＋（rB），rS的32位内容存储到有效地址为EA的存储器中。rA＝EA，如果rA＝0，则指令无效。

（10）字存储指令stwx（寄存器寻址）

stwx rS，rA，rB

有效地址EA＝（rA）＋（rB），rS的32位内容存储到有效地址为EA的存储器中。
