Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2012-09-03T20:42:27+08:00

====== OSPF动态路由协议基本工作原理 ======
Created Monday 03 September 2012
http://net.zdnet.com.cn/network_security_zone/2010/0414/1705709.shtml

随着Internet技术在全球范围内的飞速发展，IP网络作为一种最有前景的网络技术，受到了人们的普遍关注。而作为IP网络生存、运作、组织的核心——IP路由技术提供了解决IP网络动态可变性、实时性、QoS等关键技术的一种可能。在众多的路由技术中，OSPF协议已成为目前Internet广域网和Intranet企业网采用最多、应用最广泛的路由技术之一。本文在分析OSPF动态路由协议基本工作原理的基础上，提出了Dijkstra算法和OSPF路由表计算的实现方法。

目前应用较多的路由协议有RIP和OSPF，它们同属于__内部网关协议__，但RIP基于__距离矢量算法__，而OSPF基于链路状态的__最短路径优先算法__。它们在网络中利用的传输技术也不同。

RIP是利用__UDP的520号端口__进行传输，实现中利用套接口编程，而OSPF则直接在IP上进行传输，它的协议号为89.

在RIP当中，所有的路由都由__跳数__来描述，到达目的地的路由最大不超过16跳，且只保留__唯一__的一条路由，这就限制了RIP的__服务半径__，即其只适用于小型的简单网络。同时，运行RIP的路由器需要定期地(一般30s)将自己的路由表__广播__到网络当中，达到对网络拓扑的聚合，这样不但聚合的速度慢而且极容易引起广播风暴、累加到无穷、路由环致命等问题。为此，OSPF应运而生。OSPF是基于链路状态的路由协议，它克服了RIP的许多缺陷：

　　第一，OSPF不再采用跳数的概念，而是根据接口的吞吐率、拥塞状况、往返时间、可靠性等实际链路的负载能力定出__路由代价__，同时选择最短、最优路由并允许保持到达同一目标地址的__多条路由__，从而平衡网络负荷;
　　第二，OSPF支持不同服务类型的不同代价，从而实现__不同QoS的路由服务;__
　　第三，OSPF路由器不再交换路由表，而是同步各路由器对网络状态的认识，即__链路状态数据库__，然后通过Dijkstra最短路径算法计算出网络中各目的地址的最优路由。

这样OSPF路由器间不需要定期地交换大量数据，而只是保持着一种连接，一旦有链路状态发生变化时，才通过__组播方式__对这一变化做出反应，这样不但减轻了不参与系统的负荷而且达到了对网络拓扑的快速聚合。而这些正是OSPF强大生命力和应用潜力的根本所在。

　　一、OSPF工作原理分析

OSPF是一种__分层次__的路由协议，其层次中最大的实体是__AS(自治系统)__，即遵循**共同路由策略**管理下的一部分网络实体。在每个AS中，将网络划分为不同的__区域__。每个区域都有自己特定的标识号。对于__主干(backbone)区域__，负责在区域之间分发链路状态信息。这种分层次的网络结构是根据OSPF的实际提出来的。当网络中自治系统非常大时，网络拓扑数据库的内容就更多，所以如果不分层次的话，一方面容易造成数据库溢出，另一方面当网络中某一链路状态发生变化时，会引起整个网络中每个节点都重新计算一遍自己的路由表，既浪费资源与时间，又会影响路由协议的性能(如聚合速度、稳定性、灵活性等)。因此，需要把自治系统划分为多个域，__每个域内部维持本域一张唯一的拓扑结构图__，且各域根据自己的拓扑图各自计算路由，__域边界路由器把各个域的内部路由总结后在域间扩散。__这样，当网络中的某条链路状态发生变化时，此链路所在的域中的每个路由器重新计算本域路由表，而其它域中路由器只需**修改其路由表中的相应条目**而无须重新计算整个路由表，节省了计算路由表的时间。

OSPF由两个互相关联的主要部分组成：__“呼叫”协议和“可靠泛洪”机制__。**呼叫协议检测**__邻居__**并维护**__邻接__**关系，可靠泛洪算法可以确保统一域中的所有的OSPF路由器始终具有一致的链路状态数据库，而该数据库构成了对域的网络拓扑和链路状态的映射。**链路状态数据库中每个条目称为__LSA(链路状态通告)__，共有5种不同类型的LSA，路由器间交换信息时就是交换这些LSA. 每个路由器都维护一个用于跟踪网络链路状态的数据库，然后各路由器的路由选择就是基于链路状态，通过Dijkastra算法建立起来最短路径树，用该树跟踪系统中的每个目标的最短路径。**最后再通过计算域间路由、自治系统外部路由确定完整的路由表。**与此同时，OSPF动态监视网络状态，一旦发生变化则迅速扩散达到对网络拓扑的快速聚合，从而确定出新的网络路由表。

OSPF的设计实现要涉及到**指定路由器**、备份指定路由器的选举、协议包的接收、发送、泛洪机制、路由表计算等一系列问题。本文仅就Dijkstra算法与路由表的计算进行讨论。

　　二、Dijkstra算法

　　Dijkstra算法是路由表计算的依据，通过Dijkstra算法可以得到有关网络节点的最短路径树，然后由最短路径优先树得到路由表。

　　1.Dijkstra算法的描述如下：

　　(1)初始化集合E，使之只包含源节点S，并初始化集合R，使之包含所有其它节点。初始化路径列O，使其包含一段从S起始的路径。这些路径的长度值等于相应链路的量度值，并以递增顺序排列列表O.

　　(2)若列表O为空，或者O中第1个路径长度为无穷大，则将R中所有剩余节点标注为不可达，并终止算法。

　　(3)首先寻找列表O中的最短路径P，从O中删除P.设V为P的最终节点。若V已在集合E中，继续执行步骤2.否则，P为通往V的最短路径。将V从R移至E.

　　(4)建立一个与P相连并从V开始的所有链路构成的侯选路径集合。这些路径的长度是P的长度加上与P相连的长度。将这些新的链路插入有序表O中，并放置在其长度所对应的等级上。继续执行步骤2.

　　2.Dijkstra算法举例：

　　下面我们以路由器A为例，来说明最短路径树的建立过程：

　　(1)路由器A找到了路由器B、C，将它们列入候选列表.
　　(2)从候选列表中找出最小代价项B，将B加入最短路径树并从候选列表中删除。接着从B开始寻找，找到了D，将其放入候选列表.
　　(3)从列表中找出C，再由C又找到了D.但此时D的代价为4，所以不再加入候选列表。最后将D加入到最短路径树。此时候选列表为空，完成了最短路径树的计算。

　　三、OSPF路由表的计算与实现

　　有关路由表的计算是OSPF的核心内容，它是动态生成路由器内核路由表的基础。在路由表条目中，应包括有目标地址、目标地址类型、链路的代价、链路的存活时间、链路的类型以及下一跳等内容。关于整个计算的过程，主要由以下五个步骤来完成：

　　(1)保存当前路由表，当前存在的路由表为无效的，必须从头开始重新建立路由表;
　　(2)域内路由的计算，通过Dijkstra算法建立最短路径树，从而计算域内路由;
　　(3)域间路由的计算，通过检查Summary-LSA来计算域间路由，若该路由器连到多个域，则只检查主干域的Summary-LSA;
　　(4)查看Summary-LSA：在连到一个或多个传输域的域边界路由器中，通过检查该域内的Summary-LSA来检查是否有比第(2)(3)步更好的路径;
　　(5)AS外部路由的计算，通过查看AS-External-LSA来计算目的地在AS外的路由。

通过以上步骤，OSPF生成了路由表。但这里的路由表还不同于路由器中实现路由转发功能时用到的内核路由表，它只是OSPF本身的内部路由表。因此，完成上述工作后，往往还要通过路由增强功能与内核路由表交互，从而实现多种路由协议的学习。

OPSF作为一种重要的内部网关协协议的普遍应用，极大地增强了网络的可扩展性和稳定性，同时也反映出了动态路由协议的强大功能。但是，在有关OSPF协议的研究、实现中尚存在一些问题，如数据库的溢出、度量的刻画、以及MTU协商等等。同时，在IPv6中，OSPFv3基于链路的处理机制、IP地址的变化、泛洪范围的增加、包格式、LSA的变化以及邻居的识别等技术都将是我们共同探讨的课题。
